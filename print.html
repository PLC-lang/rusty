<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RuSTy User Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro_1.html"><strong aria-hidden="true">1.</strong> RuSTy</a></li><li class="chapter-item expanded "><a href="build_and_install.html"><strong aria-hidden="true">2.</strong> Build and Install</a></li><li class="chapter-item expanded "><a href="using_rusty.html"><strong aria-hidden="true">3.</strong> Using RuSTy</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Writing ST Programs</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Multiple Files</div></li><li class="chapter-item expanded "><a href="libraries.html"><strong aria-hidden="true">4.2.</strong> Libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="libraries/external_functions.html"><strong aria-hidden="true">4.2.1.</strong> External Functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Using in external programs</div></li></ol></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">5.</strong> Variables</a></li><li class="chapter-item expanded "><a href="datatypes.html"><strong aria-hidden="true">6.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="direct_variables.html"><strong aria-hidden="true">7.</strong> Direct Bit Access</a></li><li class="chapter-item expanded "><a href="arch/architecture.html"><strong aria-hidden="true">8.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arch/parser.html"><strong aria-hidden="true">8.1.</strong> Parser</a></li><li class="chapter-item expanded "><a href="arch/indexer.html"><strong aria-hidden="true">8.2.</strong> Indexer &amp; Symbol-Table</a></li><li class="chapter-item expanded "><a href="arch/linker.html"><strong aria-hidden="true">8.3.</strong> Linker</a></li><li class="chapter-item expanded "><a href="arch/validation.html"><strong aria-hidden="true">8.4.</strong> Validation</a></li><li class="chapter-item expanded "><a href="arch/codegen.html"><strong aria-hidden="true">8.5.</strong> Codegen</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RuSTy User Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rusty"><a class="header" href="#rusty">RuSTy</a></h1>
<p>RuSTy is a <a href="https://en.wikipedia.org/wiki/Structured_text">structured text (ST)</a>
compiler written in Rust and based on the
LLVM compiler backend. We use the <a href="https://crates.io/crates/logos/0.8.0"><em>logos</em></a>
crate library to perform lexical analysis before the custom parser runs. RuSTy
puts out static or shared objects as well as LLVM IR or bitcode by the flip of
a command line flag. We are aiming towards an open-source industry-grade ST compiler
supporting at least the features in 2nd edition IEC 61131 standard. </p>
<p>You might also want to refer to the <a href="api/rusty/">API documentation</a>.</p>
<h2 id="supported-language-concepts"><a class="header" href="#supported-language-concepts">Supported Language Concepts</a></h2>
<h3 id="pous"><a class="header" href="#pous">POUs</a></h3>
<ul>
<li>✔ Program</li>
<li>✔ Function</li>
<li>✔ FunctionBlock</li>
<li>✔ Action</li>
</ul>
<h3 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h3>
<ul>
<li>✔ IEC 61131-3 numeric types</li>
<li>✔ Strings</li>
<li>✔ Wide Strings</li>
<li>✔ Struct types</li>
<li>✔ Enum types</li>
<li>✔ Array data types</li>
<li>✔ Alias types</li>
<li>✔ Sub-ranges types</li>
<li>✔ Date and Time types</li>
<li>✔ Sized String types</li>
<li>✔ Sized Wide String types</li>
<li>✔ Initial values</li>
</ul>
<h3 id="declarations"><a class="header" href="#declarations">Declarations</a></h3>
<ul>
<li>✔ VAR</li>
<li>✔ VAR_INPUT</li>
<li>✔ VAR_OUTPUT</li>
<li>✔ VAR_IN_OUT</li>
</ul>
<h3 id="statements"><a class="header" href="#statements">Statements</a></h3>
<ul>
<li>✔ Assignments</li>
<li>✔ Call statements</li>
<li>✔ Implicit call arguments</li>
<li>✔ Explicit call arguments</li>
<li>✔ EXIT, CONTINUE statements</li>
</ul>
<h3 id="control-structures"><a class="header" href="#control-structures">Control Structures</a></h3>
<ul>
<li>✔ IF Statement</li>
<li>✔ CASE Statement</li>
<li>✔ FOR Loops</li>
<li>✔ WHILE Loops</li>
<li>✔ REPEAT Loops</li>
<li>✔ RETURN statement</li>
</ul>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<ul>
<li>✔ Arithmetic Operators</li>
<li>✔ Relational Operators</li>
<li>✔ Logical Operators</li>
<li>✔ Bitwise Operators</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-installing"><a class="header" href="#building-and-installing">Building and Installing</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>To be able to build the source code, you will need to <a href="https://www.rust-lang.org/tools/install">install Rust</a>
and the following dependencies:</p>
<ul>
<li>the usual <strong>standard build tools</strong> (aka <code>build-essential</code>)</li>
<li><strong>LLVM 12</strong>: On Ubuntu, the package manager version of LLVM (e.g. <code>llvm-12-dev</code>, <code>liblld-12-dev</code>) will work fine,
on debian you'll need to add additional repository sources (<code>deb http://apt.llvm.org/bullseye/ llvm-toolchain-bullseye-12 main</code>), since Debian 11 (latest) only includes LLVM packages up to version 11. For Windows, you need a
<a href="https://github.com/PLC-lang/llvm-package-windows/releases/tag/v12.0.1">special build</a>.</li>
<li><strong>zlib</strong> (apt: <code>libz-dev</code>)</li>
<li><strong>Polly</strong> in the form of a static library (included in apt package <code>libclang-common-12-dev</code>). Alternatively,
building LLVM from source should also provide you with that file. Building from source may take a while, though.</li>
<li>If you want to clone and work on the repository, you'll also need <strong>git</strong>.</li>
</ul>
<h3 id="tips-for-troubleshooting"><a class="header" href="#tips-for-troubleshooting">Tips for troubleshooting</a></h3>
<ul>
<li>Because of weak compatibility guarantees of the LLVM API, the LLVM installation must exactly match the
major version of the <code>llvm-sys</code> crate. Currently you will need to install LLVM 12 to satisfy this constraint.
<a href="https://crates.io/crates/llvm-sys">Read more</a></li>
<li>To avoid installation conflicts on Linux/Ubuntu, make sure you don't have a default installation available
(like you get by just installing <code>llvm-dev</code>), which may break things. If you do, make sure you have set
the appropriate environment variable (<code>LLVM_SYS_120_PREFIX=/usr/lib/llvm-12</code> for LLVM 12), so
the build of the <code>llvm-sys</code> crate knows what files to grab.</li>
</ul>
<h2 id="cloning-the-repository"><a class="header" href="#cloning-the-repository">Cloning the repository</a></h2>
<p>On your local computer, open up a shell and clone the repository.</p>
<pre><code class="language-bash">git clone https://github.com/PLC-lang/rusty
cd rusty
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Building is as easy as typing a single command. If you just want to use the
compiler without doing development, building the release configuration will
give you a smaller and likely a faster binary.</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>You can find the binary at <code>./target/release/rustyc</code>.</p>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rusty"><a class="header" href="#using-rusty">Using RuSTy</a></h1>
<p><code>rustyc</code> offers a comprehensive help via the -h (--help) option. <code>rustyc</code> takes 
one output-format parameter and any number of input-files. The input files can also be
written as <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob patterns</a>.</p>
<p><code>rustyc [OPTIONS] &lt;input-files&gt;... &lt;--ir|--shared|--pic|--static|--bc&gt;</code></p>
<p>Note that you can only specify at most one output format. In the case that no output
format switch has been specified, the compiler will select <code>--static</code> by default.</p>
<p>Similarily, if you do not specify an output filename via the <code>-o</code> or <code>--output</code> options,
the output filename will consist of the first input filename, but with an appropriate
file extension depending on the output file format. A minimal invocation looks like this:</p>
<p><code>rustyc input.st</code> ... this will take in the file input.st and compile it into a static object
that will be written to a file named input.o.</p>
<p>More examples:</p>
<ul>
<li><code>rustyc --ir file1.st file2.st</code> will compile file1.st and file2.st.</li>
<li><code>rustyc --ir src/*.st</code> will compile all st files in the src-folder.</li>
<li><code>rustyc --ir &quot;**/*.st&quot;</code> will compile all st-files in the current folder and its subfolders recursively.</li>
</ul>
<h2 id="example-building-a-hello-world-program"><a class="header" href="#example-building-a-hello-world-program">Example: Building a hello world program</a></h2>
<h3 id="writing-the-code"><a class="header" href="#writing-the-code">Writing the code</a></h3>
<p>We want to print something to the terminal, so we're going to declare external functions
for that and link with libc when we're done. This program can also be found at
<code>examples/hello_world.st</code> in the source tree of Rusty. </p>
<ul>
<li>
<p><code>_start</code> is our entry point to the program, because most linker scripts define it this way. </p>
</li>
<li>
<p>Since we don't have a <code>crt0</code> right now, we have to call the <code>exit()</code> function by ourselves after we're
done. Otherwise, the program will most likely crash (because it tries to return to a function that never
existed).</p>
</li>
</ul>
<pre><code class="language-st">@EXTERNAL FUNCTION puts : DINT
VAR_INPUT
    text : STRING;
END_VAR
END_FUNCTION

@EXTERNAL FUNCTION exit : DINT
VAR_INPUT
    status : DINT;
END_VAR
END_FUNCTION

FUNCTION _start : DINT
    puts('hello, world!');
    exit(0);
END_FUNCTION
</code></pre>
<h3 id="compiling-with-rusty"><a class="header" href="#compiling-with-rusty">Compiling with rusty</a></h3>
<p>Compiling with rusty is very easy. If you just want to build an object file, then do this:</p>
<pre><code class="language-bash">rustyc -c hello_world.st -o hello_world.o
</code></pre>
<h3 id="linking-an-executable"><a class="header" href="#linking-an-executable">Linking an executable</a></h3>
<p>Instead, you can also compile this into an executable and run it:</p>
<pre><code class="language-bash">rustyc hello_world.st -o hello_world -L/path/to/libs -lc
./hello_world
</code></pre>
<p>Please note that RuSTy will attempt to link the generated object file by default to generate
an executable if you didn't specify something else (option <code>-c</code>).</p>
<ul>
<li>The <code>-lc</code> flag tells the linker it should link against <code>libc</code>. Depending on the available libraries on your system,
the linker will prefer a dynamically linked library if available, and revert to a static one otherwise.</li>
<li>You add library search pathes by providing additional <code>-L /path/...</code> options. By default, this will be
the current directory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>RuSTy does not currently have support for separate libraries.
Libraries can be compiled together with the application as a normal files.</p>
<p>Precompiled libraries or system functions can be called by declaring an
<a href="libraries/external_functions.html">External Function</a> for each POU in that library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h1>
<p>A <code>POU</code> (<code>PROGRAM</code>, <code>FUNCTION</code>, <code>FUNCTION_BLOCK</code>) can be marked as external,
which will cause the compiler to ignore its implementation</p>
<pre><code class="language-iecst">@EXTERNAL
FUNCTION log : DINT
VAR_INPUT
  message : STRING[1024];
  type : (Err,Warn,Info) := Info;
END_VAR
END_PROGRAM
</code></pre>
<p>At compilation time, the function <code>log</code> will be defined,
and can be called from <code>ST</code> code.</p>
<blockquote>
<p>Note : At linking time, a <code>log</code> function with a compatible signature must be found.</p>
</blockquote>
<h2 id="calling-c-functions"><a class="header" href="#calling-c-functions">Calling C functions</a></h2>
<p><code>ST</code> code can call into foreign functions natively.
To achive this, the called function must be defined in a <code>C</code> compatible API
e.g. <code>extern &quot;C&quot;</code> blocks</p>
<p>The interface of the function has to be declared in <code>ST</code> using the <code>@EXTERNAL</code> keyword.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Given a <code>min</code> function defined in <code>C</code> as follows</p>
<pre><code class="language-C">int min(int a, int b) {
//...
}
</code></pre>
<p>An interface of that function in <code>ST</code> can be defined as</p>
<pre><code class="language-iecst">@EXTERNAL
FUNCTION min : DINT
VAR_INPUT
  a : DINT;
  b : DINT;
END_VAR
</code></pre>
<h3 id="variadic-arguments"><a class="header" href="#variadic-arguments">Variadic arguments</a></h3>
<p>Some foreign functions, especially ones defined in <code>C</code>,
could be <a href="https://en.cppreference.com/w/c/variadic">variadic functions</a>.</p>
<p>These functions are usually defined with the last parameter <code>...</code>, and signify
that a function can be called with unlimited parameters.</p>
<p>An example of a variadic function is printf.</p>
<p>Calling a variadic function is supported in <code>ST</code>. To mark an external function
as variadic, you can add a parameter of type <code>...</code> to the <code>VAR_INPUT</code> block</p>
<h4 id="variadic-function-example"><a class="header" href="#variadic-function-example">Variadic Function Example</a></h4>
<p>Given the <code>printf</code> function defined as</p>
<pre><code class="language-C">int printf( const char *restrict format, ... );
</code></pre>
<p>The <code>ST</code> interface can be defined as</p>
<pre><code class="language-iecst">@EXTERNAL
FUNCTION printf : DINT
VAR_INPUT
  format : STRING;
  args : ...;
END_VAR
END_FUNCTION
</code></pre>
<h4 id="full-example"><a class="header" href="#full-example">Full Example</a></h4>
<p>With the printf function available on the system, there is no need to declare
the C function</p>
<p>Declare an <code>ST</code> program called <code>ExternalFunctions.st</code> with the following code:</p>
<pre><code class="language-iecst">@EXTERNAL FUNCTION printf : DINT
VAR_INPUT
    format : STRING;
    args: ...;
END_VAR
END_FUNCTION


(**
* The main function of the program prints a demo to the standard out
*)
FUNCTION main : DINT
  main := 1;
  printf('Value %d, %d, %d', main, main * 10, main * 100);
END_FUNCTION
</code></pre>
<p>Compile the previous code with the following command</p>
<pre><code class="language-sh">rustyc ExternalFunctions.st -o ExternalFunctions.o  --static \
  &amp;&amp; clang ExternalFunctions.o -o ExternalFunctions
</code></pre>
<blockquote>
<p>Note: that we use clang to link the generated object file and generate an executable</p>
</blockquote>
<p>You can then run the demo with <code>./ExternalFunctions</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Variable declaration blocks can be delcared as CONSTANT. All variables 
of a constant declaration block become constants. Constant variables can not be changed and need to be initialized.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-iecst">TYPE OneInt : INT := 1; END_TYPE

VAR_GLOBAL CONSTANT
    MAX_SIZE : INT := 99;
    MIN_LEN : INT := 1;
    counter : OneInt;  // 1
END_VAR

PROGRAM PLC_PRG
    VAR CONSTANT
        DEFAULT_INPUT : BOOL := FALSE;
    END_VAR
END_PROGRAM
</code></pre>
<h2 id="variable-initialization"><a class="header" href="#variable-initialization">Variable Initialization</a></h2>
<p>Initializers of variables are evaluated at compile time. Therefore 
they can only consist of literals, other constants or expressions
consisting of a combination of them. Note that initializers must not contain
recursive definitions.</p>
<p>If a variable has no initializer, the variable may be initialized with it's datatype's default value
or else with <code>0</code>.</p>
<h3 id="array-initialization"><a class="header" href="#array-initialization">Array Initialization</a></h3>
<p>Arrays can be initialized using array literals.
If the array-initial value does not contain all required elements, the array's inner type's default value
will be used to fill the missing values.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-iecst">TYPE SignalValue : INT := -1; END_TYPE

VAR_GLOBAL CONSTANT
    MIN_LEN : INT := 1;
    MAX_LEN : INT := 100;

    SIZE : INT := MAX_LEN - MIN_LEN;
END_VAR

PROGRAM PLC_PRG
    VAR_INPUT
        signals: ARRAY[0..SIZE] OF SignalValue := [99, 99]; // rest is -1
    END_VAR

    ...
END_PROGRAM
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datatypes-1"><a class="header" href="#datatypes-1">Datatypes</a></h1>
<h2 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h2>
<p>A variety of numeric types exist with different sizes and properties complying
with IEC61131.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<table><thead><tr><th>Type name</th><th>Size</th><th>Properties</th></tr></thead><tbody>
<tr><td>SINT</td><td>8 bit</td><td>signed</td></tr>
<tr><td>USINT</td><td>8 bit</td><td>unsigned</td></tr>
<tr><td>INT</td><td>16 bit</td><td>signed</td></tr>
<tr><td>UINT</td><td>16 bit</td><td>unsigned</td></tr>
<tr><td>DINT</td><td>32 bit</td><td>signed</td></tr>
<tr><td>UDINT</td><td>32 bit</td><td>unsigned</td></tr>
<tr><td>LINT</td><td>64 bit</td><td>signed</td></tr>
<tr><td>ULINT</td><td>64 bit</td><td>unsigned</td></tr>
<tr><td>REAL</td><td>32 bit</td><td>float</td></tr>
<tr><td>LREAL</td><td>64 bit</td><td>float</td></tr>
</tbody></table>
<p>When such a variable is declared without being initialized, it will
be default-initialized with a value of <code>0</code> or <code>0.0</code> respectively.</p>
<h3 id="a-word-on-integer-literals"><a class="header" href="#a-word-on-integer-literals">A word on integer literals</a></h3>
<p>Integer literals can be prefixed with either <code>2#</code> (binary), <code>8#</code> (octal) or
<code>16#</code> (hexadecimal). They will then be treated with regard to the respective number system.</p>
<p>Examples:</p>
<ul>
<li><code>i1 : DINT := 34;</code> - declares and initializes a 32bit signed integer with value 42.</li>
<li><code>i1 : DINT := 2#101010;</code> - declares and initializes a 32bit signed integer with value 42.</li>
<li><code>i1 : DINT := 8#52;</code> - declares and initializes a 32bit signed integer with value 42.</li>
<li><code>i1 : DINT := 16#2A;</code> - declares and initializes a 32bit signed integer with value 42.</li>
</ul>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<table><thead><tr><th>Type name</th><th>Size</th><th>Encoding</th></tr></thead><tbody>
<tr><td>STRING</td><td>n+1</td><td>UTF-8</td></tr>
<tr><td>WSTRING</td><td>2n+2</td><td>UTF-16</td></tr>
</tbody></table>
<p>When such a variable is declared without being initialized, it will
be default-initialized with a value of '' or &quot;&quot; respectively (empty strings).</p>
<h3 id="string"><a class="header" href="#string">STRING</a></h3>
<p>rusty treats <code>STRING</code>s as byte-arrays storing UTF-8 character bytes with a Null-terminator (0-byte) at the end. 
So a String of size n requres n+1 bytes to account for the Null-terminator.
A <code>STRING</code> literal is surrounded by single-ticks <code>'</code>.</p>
<p>A String has a well defined length which can be defined similar to the array-syntax. A String-variable 
<code>myVariable: STRING[20]</code> declares a byte array of length 21, to store 20 utf8 character bytes. When 
declaring a <code>STRING</code>, the length-attribute is optional. The default length is 80.</p>
<p>Examples</p>
<ul>
<li><code>s1 : STRING;</code> - declares a String of length 80</li>
<li><code>s2 : STRING[20];</code> - declares a String of length 20</li>
<li><code>s3 : STRING := 'Hello World';</code> - declares and initializes a String of length 80, and initializes it with the utf8 characters and a null-terminator at the end</li>
<li><code>s4 : STRING[55] := 'Foo Baz';</code> - declares and initializes a String of length 55 and initializes it with the utf8 characters and a null-terminator at the end.</li>
</ul>
<h3 id="wstring-wide-strings"><a class="header" href="#wstring-wide-strings">WSTRING (Wide Strings)</a></h3>
<p>rusty treats <code>WSTRING</code>s as byte-arrays storing UTF-16 character bytes with two Null-terminator bytes at the end. The bytes are stored in Little Endian encoding. A Wide-String of size n requres 2 * (n+1) bytes to account for the 2 byes per utf16 character and the Null-terminators. A <code>WSTRING</code> literal is surrounded by doubly-ticks <code>&quot;</code>.</p>
<p>A <code>WSTRING</code> has a well defined length which can be defined similar to the array-syntax. A <code>WSTRING</code>-variable 
<code>myVariable: WSTRING[20]</code> declares a byte array of length 42, to store 20 utf16 character bytes. When 
declaring a <code>WSTRING</code>, the length-attribute is optional. The default length is 80.</p>
<p>Examples</p>
<ul>
<li><code>ws1 : WSTRING;</code> - declares a Wide-String of length 80</li>
<li><code>ws2 : WSTRING[20];</code> - declares a Wide-String of length 20</li>
<li><code>ws3 : WSTRING := &quot;Hello World&quot;;</code> - declares and initializes a Wide-String of length 80, and initializes it with the utf16 characters and a utf16-null-terminator at the end</li>
<li><code>ws4 : WSTRING[55] := &quot;Foo Baz&quot;;</code> - declares and initializes a Wide-String of length 55 and initializes it with the utf8 characters and a utf16-null-terminator at the end.</li>
</ul>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and Time</a></h2>
<h3 id="overview-2"><a class="header" href="#overview-2">Overview</a></h3>
<table><thead><tr><th>Type name</th><th>Size</th><th>Internally stored as</th></tr></thead><tbody>
<tr><td>TIME</td><td>64 bit</td><td>Timespan in nanoseconds</td></tr>
<tr><td>TIME_OF_DAY</td><td>64 bit</td><td>Milliseconds since Jan 1, 1970 UTC</td></tr>
<tr><td>DATE</td><td>64 bit</td><td>Milliseconds since Jan 1, 1970 UTC</td></tr>
<tr><td>DATE_AND_TIME</td><td>64 bit</td><td>Milliseconds since Jan 1, 1970 UTC</td></tr>
</tbody></table>
<p>Note that the internal representation and sizes of these types are specific
to RuSTy and not defined by the IEC61131 standard.</p>
<h3 id="date"><a class="header" href="#date">DATE</a></h3>
<p>The <code>DATE</code> datatype is used to represent a Date in the Gregorian Calendar. Such a value is 
stored as an i64 with a precision in milliseconds and denotes the number of milliseconds 
that have elapsed since January 1, 1970 UTC not counting leap seconds. DATE literals start 
with <code>DATE#</code> or <code>D#</code> followed by a date in the format of <code>yyyy-mm-dd</code>.</p>
<p>Examples</p>
<ul>
<li><code>d1 : DATE := DATE#2021-05-02;</code></li>
<li><code>d2 : DATE := DATE#1-12-24;</code></li>
<li><code>d3 : DATE := D#2000-1-1;</code></li>
</ul>
<h3 id="date_and_time"><a class="header" href="#date_and_time">DATE_AND_TIME</a></h3>
<p>The <code>DATE_AND_TIME</code> datatype is used to represent a certain point in time in the Gregorian Calendar.
Such a value is stored as an <code>i64</code> with a precision in milliseconds and denotes the
number of milliseconds that have elapsed since January 1, 1970 UTC not counting leap seconds.
DATE_AND_TIME literals start with <code>DATE_AND_TIME#</code> or <code>DT#</code> followed by a date and time in the
format of <code>yyyy-mm-dd-hh:mm:ss</code>.</p>
<p>Note that only the seconds-segment can have a fraction denoting the milliseconds.</p>
<p>Examples</p>
<ul>
<li><code>d1 : DATE_AND_TIME := DATE_AND_TIME#2021-05-02-14:20:10.25;</code></li>
<li><code>d2 : DATE_AND_TIME := DATE_AND_TIME#1-12-24-00:00:1;</code></li>
<li><code>d3 : DATE_AND_TIME := DT#1999-12-31-23:59:59.999;</code></li>
</ul>
<h3 id="time_of_day"><a class="header" href="#time_of_day">TIME_OF_DAY</a></h3>
<p>The <code>TIME_OF_DAY</code> datatype is used to represent a specific moment in time in a day.
Such a value is stored as an <code>i64</code> value with a precision in milliseconds and denotes the
number of milliseconds that have elapsed since January 1, 1970 UTC not counting leap seconds.
Hence this value is stored as a <code>DATE_AND_TIME</code> with the day fixed to 1970-01-01.
<code>TIME_OF_DAY</code> literals start with <code>TIME_OF_DAY#</code> or <code>TOD#</code> followed by a time in the
format of <code>hh:mm:ss</code>.</p>
<p>Note that only the seconeds-segment can have a fraction denoting the milliseconds.</p>
<p>Examples</p>
<ul>
<li><code>t1 : TIME_OF_DAY := TIME_OF_DAY#14:20:10.25;</code></li>
<li><code>t2 : TIME_OF_DAY := TIME_OF_DY#0:00:1;</code></li>
<li><code>t3 : TIME_OF_DAY := TOD#23:59:59.999;</code></li>
</ul>
<h3 id="time"><a class="header" href="#time">TIME</a></h3>
<p>The <code>TIME</code> datatype is used to represent a time-span. A <code>TIME</code> value is stored as an
<code>i64</code> value with a precision in nanoseconds.
TIME literals start with <code>TIME#</code> or <code>T#</code> followed by the <code>TIME</code> segements. Supported segements are:</p>
<ul>
<li><code>d</code> ... <code>f64</code> days</li>
<li><code>h</code> ... <code>f64</code> hours</li>
<li><code>m</code> ... <code>f64</code>minutes</li>
<li><code>s</code> ... <code>f64</code> seconds</li>
<li><code>ms</code> ... <code>f64</code> milliseconds</li>
<li><code>us</code> ... <code>f64</code> microseconds</li>
<li><code>ns</code> ... <code>u32</code> nanaoseconds</li>
</ul>
<p>Note that only the last segment of a <code>TIME</code> literal can have a fraction.</p>
<p>Examples</p>
<ul>
<li><code>t1 : TIME := TIME#2d4h6m8s10ms;</code></li>
<li><code>t2 : TIME := T#2d4.2h;</code></li>
<li><code>t3 : TIME := T#-10s4ms16ns;</code></li>
</ul>
<h2 id="other-types"><a class="header" href="#other-types">Other types</a></h2>
<p>The <code>BOOL</code> type can either be assigned <code>TRUE</code> or <code>FALSE</code>. The type <code>__VOID</code> is the
empty type and has an undefined size.</p>
<table><thead><tr><th>Type name</th><th>Size</th><th>Properties</th></tr></thead><tbody>
<tr><td>BOOL</td><td>8 bit</td><td>signed</td></tr>
<tr><td>__VOID</td><td>undefined</td><td></td></tr>
</tbody></table>
<table><thead><tr><th>Type name</th><th>Size</th><th>Properties</th></tr></thead><tbody>
<tr><td>BYTE</td><td>8 bit</td><td>unsigned</td></tr>
<tr><td>WORD</td><td>16 bit</td><td>unsigned</td></tr>
<tr><td>DWORD</td><td>32 bit</td><td>unsigned</td></tr>
<tr><td>LWORD</td><td>64 bit</td><td>unsigned</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-bit-access-on-variables"><a class="header" href="#direct-bit-access-on-variables">Direct (Bit) Access on Variables</a></h1>
<p>The IEC61131-3 Standard allows reading specific <code>Bits</code>, <code>Bytes</code>, <code>Words</code> or <code>DWords</code> from an <code>ANY_BIT</code> type.
RuSTy supports this functionalty and extends it to support all <code>INT</code> types.</p>
<h2 id="constant-based-direct-access"><a class="header" href="#constant-based-direct-access">Constant based Direct Access</a></h2>
<p>To access a bit sequence in a variable, a direct access instruction <code>%&lt;Type&gt;&lt;Value&gt;</code> is used.
<code>Type</code> is the bit sequence size required and is described as follows : </p>
<table><thead><tr><th>Type</th><th>Size</th><th>Example</th></tr></thead><tbody>
<tr><td>X</td><td>1</td><td>`%X1</td></tr>
<tr><td>B</td><td>8</td><td>`%B1</td></tr>
<tr><td>W</td><td>16</td><td>`%W1</td></tr>
<tr><td>D</td><td>32</td><td>`%D1</td></tr>
</tbody></table>
<blockquote>
<p><em>For <code>Bit</code> access, the <code>%X</code> is optional.</em></p>
</blockquote>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-st">FUNCTION main : DINT
VAR 
    variable    : LWORD; 
    bitTarget   : BOOL;
    bitTarget2  : BOOL;
    byteTarget  : BYTE;
    wordTarget  : WORD;
    dwordTarget : DWORD;
END_VAR

variable    := 16#AB_CD_EF_12_34_56_78_90;
bitTarget   := variable.%X63; (*Access last bit*)
byteTarget  := variable.%B7; (*Access last byte*)
wordTarget  := variable.%W3; (*Access last word*)
dwordTarget := variable.%D1; (*Access last dword*)
(*Chaining an access is also allowed *)
bitTarget2  := variable.%D1.%W1.%B1.%X1;

END_FUNCTION
</code></pre>
<h2 id="varirable-based-direct-access"><a class="header" href="#varirable-based-direct-access">Varirable based Direct Access</a></h2>
<p>While the IEC61131-3 Standard only defines variable access using constant int literals, 
RuSTy additionally supports access using Variables
The Syntax for a variable based access is <code>%&lt;Type&gt;&lt;Variable&gt;</code>
The provided varibale has to be a direct Reference variable (non Qualified)</p>
<blockquote>
<p><em>Short hand access for Bit (Without the <code>%X</code> modifier) is not allowed.</em></p>
</blockquote>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-st">FUNCTION main : DINT
VAR 
    variable    : LWORD; 
    access_var  : INT;
    bitTarget   : BOOL;
    bitTarget2  : BOOL;
    byteTarget  : BYTE;
    wordTarget  : WORD;
    dwordTarget : DWORD;
END_VAR
variable    := 16#AB_CD_EF_12_34_56_78_90;
access_var := 63;
bitTarget   := variable.%Xaccess_var; (*Access last bit*)
access_var := 7;
byteTarget  := variable.%Baccess_var; (*Access last byte*)
access_var := 3;
wordTarget  := variable.%Waccess_var; (*Access last word*)
access_var := 1;
dwordTarget := variable.%Daccess_var; (*Access last dword*)
(*Chaining an access is also allowed *)
bitTarget2  := variable.%Daccess_var.%Waccess_var.%Baccess_var.%Xaccess_var;
END_FUNCTION
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Rusty is a Compiler for Structured Text. It utilizes the llvm compiler infrastructurue and contributes a <a href="https://en.wikipedia.org/wiki/Structured_text">Structured Text</a> Frontend that translates Structured Text into llvm's language independent intermediate representation (IR). The Further optimization and native code generation is performed by the existing LLVM infrastructure, namely llvm's common optimizer and the platform specific backend (see <a href="https://www.aosabook.org/en/llvm.html">here</a>). </p>
<pre><code class="language-ignore">    ┌──────────────────┐    ┌───────────────┐    ┌────────────────┐
    │                  │    │               │    │                │
    │      Rusty       │    │  LLVM Common  │    │  LLVM Backend  │
    │                  ├───►│               ├───►│                │
    │  LLVM Frontend   │    │   Optimizer   │    │   (e.g Clang)  │
    │                  │    │               │    │                │
    └──────────────────┘    └───────────────┘    └────────────────┘
</code></pre>
<p>So Rusty consists of the frontend part of the llvm compiler-infrastructure. This means that this compiler can benefit from llvm's existing compiler-optimizations, as well as all backend target platforms available.</p>
<h2 id="rusty-frontend-architecture"><a class="header" href="#rusty-frontend-architecture">Rusty Frontend Architecture</a></h2>
<p>Ultimately the goal of a compiler frontend, is to translate the original source code into the infrastructure's intermediate representation  (in this case we're talking about <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>). Rusty treats this task as a compilation step of its own. While a fully fledged compiler generates machine code as a last step, rusty generates LLVM IR assembly code.</p>
<pre><code class="language-ignore">      ┌────────┐                                                          ┌────────┐
      │ Source │                                                          │  LLVM  │
      │        │                                                          │   IR   │
      │ Files  │                                                          │        │
      └───┬────┘                                                          └────────┘
          │                                                                    ▲
          ▼                                                                    │
    ┌────────────┐   ┌────────────┐   ┌────────────┐   ┌────────────┐   ┌──────┴─────┐
    │            │   │            │   │            │   │            │   │            │
    │            │   │            │   │            │   │            │   │            │
    │   Parser   ├──►│   Indexer  ├──►│   Linker   ├──►│ Validation ├──►│   Codegen  │
    │            │   │            │   │            │   │            │   │            │
    │            │   │            │   │            │   │            │   │            │
    └────────────┘   └────────────┘   └────────────┘   └────────────┘   └────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser">Parser</a></h1>
<p>The role of the parser is to turn source-code which is fed as a string (in the form of files) into a tree-representation of that source-code. This tree is typically called the <em>Abstract Syntax Tree (AST)</em>. The step of parsing consists of two distinct stages. 
The first one is the <em>lexical analysis (Lexer)</em> which is performed by a lexer. After lexing we perform the <em>syntactical analysis (Parser)</em> to construct the syntax tree.</p>
<pre><code class="language-ignore">                                                                   ┌──┐
       ┌──────────────┐                                            │  │
       │              │                                            └──┘
       │  Source Code │                                            /  \
       │              │   ┌─────────┐        ┌──────────┐         /    \
       │  ──────────  │   │         │        │          │     ┌──┐      ┌──┐
       │              ├───►  Lexer  │        │  Parser  ├────►│  │      │  │
       │  ─────────   │   │         │        │          │     └──┘      └──┘
       │              │   └────┬────┘        └──────────┘      /\        /\
       │  ────        │        │                  ▲           /  \      /  \
       │              │        │                  │        ┌──┐ ┌──┐ ┌──┐ ┌──┐
       │  ────────    │        ▼                  │        │  │ │  │ │  │ │  │
       │              │   ┌───────────────────────┴──┐     └──┘ └──┘ └──┘ └──┘
       │              │   │                          │
       └──────────────┘   │  ┌───┐ ┌───┐ ┌───┐ ┌───┐ │       Abstract Syntax
                          │  │ T │ │ T │ │ T │ │...│ │            Tree
                          │  └───┘ └───┘ └───┘ └───┘ │
                          │                          │
                          └──────────────────────────┘
                                 Token-Stream
</code></pre>
<h2 id="lexer"><a class="header" href="#lexer">Lexer</a></h2>
<p>The lexer performs the lexical analysis. This step turns the source-string into a sequence of well known tokens. The Lexer (or sometimes also called <em>tokenizer</em>) splits the source-string into <em>tokens</em> (or <em>words</em>). Each token has a distinct type which corresponds to a grammar's element. Typical token-types are keywords, numbers, identifiers, brackets, dots, etc. So with the help of this token-stream it is much easier for the parser to spot certain patterns. E.g. a floating-point number consists of the token-sequence: <em>number</em>, <em>dot</em>, <em>number</em>.</p>
<p>The lexer is implemented in the <code>lexer</code>-module. It uses the <a href="https://github.com/maciejhirsz/logos">logos</a> crate to create a lexer that is able to identify all different terminal-symbols. Compared to other languages, Structured Text has a quite high number of keywords and other tokens, so Rusty's lexer identifies a quite large number of different tokens.</p>
<h3 id="discussion-rusty-lexer"><a class="header" href="#discussion-rusty-lexer">Discussion: Rusty-Lexer</a></h3>
<p>The logos crate uses <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macros</a> to generate the code required to  lex the source-string. The number of tokens identified by the rusty-lexer is quite high, so as of january 2022 the rust sdk for vs-code (rust-analyzer) reports problem with the number of macro-generated tokens (<em>macro invocation exceeds token limit...</em>).</p>
<p>The tokens identified by the lexer follow the formal definition provided by the IEC61131-3 (2013) standard.</p>
<p>Following strategies increase the number of tokens and should be reconsidered:</p>
<ul>
<li>case insensitivity</li>
<li>optional underscores in keywords (e.g. <code>END_IF</code> == <code>ENDIF</code>)</li>
<li>unrolled tokens instead of grouping tokens (e.g. <code>KEYWORD_TRUE</code> &amp; <code>KEYWORD_FALSE</code> instead of <code>KEYWORD_BOOL</code>)</li>
<li>etc.</li>
</ul>
<h2 id="parser-1"><a class="header" href="#parser-1">Parser</a></h2>
<p>The parser takes the token stream and creates the corresponding AST that represents the source code in a structured, hierarchical way. The parser is implemented in the <code>parser</code> module whereas the model for the AST is implemented in the <code>ast</code> module.</p>
<h3 id="ast---abstract-syntax-tree"><a class="header" href="#ast---abstract-syntax-tree">AST - Abstract Syntax Tree</a></h3>
<p>The abstract syntax tree is a tree representation of the source code. Some parser implementations use a generic tree-data-structure consisting of <code>Nodes</code> which can have an arbitrary number of children. These nodes usually have dynamic properties like a type and an optional value and sometimes they even have dynamic properties stored in a map to make this representation even more flexible.</p>
<p>While this approach needs very little source code we decided to favour a less flexible approach. The rusty-AST models every single ast-node as its own <em>struct</em> with all necessary fields including the possible child-nodes. While this approach needs much more code and hand-written changes, its benefits lie in the clearness and simplicity of the data-structure. Every element of the AST is easily identified, debugged and understood. (e.g. while in a generic node based AST it is easily possible to have a binary-statement with no, one, or seven child-nodes, the rusty-AST enforces the structure of every node. So the rusty-Binary-Statement has exactly two children. It is impossible to construct it differently.).</p>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<p>So an assignment <code>a := 3;</code> will be parsed with the help of the following Structures:</p>
<pre><code class="language-rs">struct Reference {
   name: string
}

struct LiteralInteger {
   value: i128
}

struct Assignment {
   left: Box&lt;AstStatement&gt;,
   right: Box&lt;AstStatement&gt;
}
</code></pre>
<h3 id="recursive-descent-parser"><a class="header" href="#recursive-descent-parser">Recursive Descent Parser</a></h3>
<p>There are a lot of different frameworks to generate parsers from formal grammars. While they generate highly optimized parsers we felt we wanted more control and more understanding of the parsing process and the resulting AST. The fact that at that point in time we were pretty new to rust itself, writing the parser by hand also gave us more practice and a stronger feeling of control and understanding. Using a parser-generator framework will definitely be an option for future improvements.</p>
<p>As for now, the parser is a hand-written <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> inside the <code>parser</code>-module. </p>
<p>As the parser reads the token stream <code>Reference</code>, <code>KeywordEquals</code>, <code>Number</code>, <code>Semicolon</code> it instantiates the corresponding syntax tree: </p>
<pre><code class="language-ignore">                      ┌─────────────────┐
                      │   Assignment    │
                      └──────┬──┬───────┘
                   left      │  │     right 
                 ┌───────────┘  └──────────┐
                 ▼                         ▼
        ┌──────────────────┐     ┌──────────────────┐
        │    Reference     │     │  LiteralInteger  │
        ├──────────────────┤     ├──────────────────┤
        │    name: 'a'     │     │    value: '3'    │
        └──────────────────┘     └──────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexer"><a class="header" href="#indexer">Indexer</a></h1>
<p>The indexing step is responsible of building and maintaining the Symbol-Table (also called <em>Index</em>). The <em>Index</em> contains all known referable objects such as <em>variables</em>, <em>data-types</em>, <em>POUs</em>, <em>Functions</em>, etc. The Symbol-Table also maintains additional information about every referable object such as: the object's type, the objects' datatype, etc.</p>
<p>Indexing is performed by the <em>index</em> module. It contains the index itself (a.k.a. Symbol Table), the <em>visitor</em> which collects all global names and their additional information as well as a data structure that handles compile time constant expressions (<em>constant_expressions</em>).</p>
<h2 id="the-index-symbol-table"><a class="header" href="#the-index-symbol-table">The Index (Symbol Table)</a></h2>
<p>The index stores information about all referable elements of the program. Depending on the type of element, we store different meta-information alongside the name of the element.</p>
<table><thead><tr><th>Index Field</th><th>Description</th></tr></thead><tbody>
<tr><td>global_variables</td><td>All global variables accessible via their name.</td></tr>
<tr><td>enum_global_variables</td><td>All enum elements accessible via their name (as if they were global variables, e.g. 'RED')</td></tr>
<tr><td>enum_qualified_variables</td><td>All enum elements accessible via their qualified name (e.g. 'COLOR.RED').</td></tr>
<tr><td>member_variables</td><td>Member variables of structured types (Structs,Functionblocks, etc. This map allows to query all members of a container by name.)</td></tr>
<tr><td>implementations</td><td>All callable implementations (Programs, Functions, Actions, Functionblocks) accessible by their name.</td></tr>
<tr><td>type_index</td><td>All data-types (intrinsic and complex) accessible via their name</td></tr>
<tr><td>constant_expressions</td><td>The results of constant expressions that can be evaluated at compile time (e.g. the initializer of a constant: <code>VAR_GLOBAL CONST TAU := 3.1415 * 2; END_VAR</code>)</td></tr>
</tbody></table>
<p>There are 3 different type of entries in the index:</p>
<ul>
<li><strong>VariableIndexEntry</strong>
The VariableIndexEntry holds information about every <em>Variable</em> in the source code and offers additional information relevant for linking, validation and code-generation.</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────────┐              ┌─────────────────┐
        │  VariableIndexEntry         │              │     &lt;enum&gt;      │
        │                             │              │   VariableType  │
        ├─────────────────────────────┤   var_type   ├─────────────────┤
        │                             │              │  - Local        │
        │  - name: String             ├─────────────►│  - Temp         │
        │  - qualified_name: String   │              │  - Input        │
        │  - is_constant: bool        │              │  - Output       │
        │  - location_in_parent: u32  │              │  - InOut        │
        │  - data_type_name: String   │              │  - Global       │
        │                             │              │  - Return       │
        └───────────┬─────────────────┘              └─────────────────┘
                    │
                    │initial_value
                    │
                    │
                    │            ┌──────────────────┐
                    │            │ ConstExpression  │
                    │       0..1 ├──────────────────┤
                    └───────────►│                  │
                                 │ ...              │
                                 │                  │
                                 └──────────────────┘
</code></pre>
<ul>
<li><strong>ImplementationIndexEntry</strong>
The ImplementationIndexEntry offers information about any callable implementation (Program, Functionblock, Function, etc.). It also offers metadata about the implementation type, the name of the method to call and the name of the parameter-struct (this-struct) to pass to the function.</li>
</ul>
<pre><code class="language-ignore">                                                  ┌───────────────────────┐
        ┌──────────────────────────┐              │       &lt;enum&gt;          │
        │ ImplementationIndexEntry │              │   ImplementationType  │
        ├──────────────────────────┤     type     │                       │
        │                          ├─────────────►├───────────────────────┤
        │ - call_name: String      │              │   - Program           │
        │ - type_name: String      │              │   - Function          │
        │                          │              │   - FunctionBlock     │
        └──────────────────────────┘              │   - Action            │
                                                  │   - Class             │
                                                  │   - Method            │
                                                  │                       │
                                                  └───────────────────────┘
</code></pre>
<ul>
<li><strong>DataType</strong>
The entry for a DataType offers information about any data-type supported by the program to be compiled (internal data types as well as user defined data types). For each data-type we offer additional information such as it's initial value, its type-nature (in terms of generic functions - e.g: ANY_INT) and some additional information about the type's internal structure and size (e.g. is it a number/array/struct/etc).</li>
</ul>
<pre><code class="language-ignore">                      ┌─────────────┐                   ┌────────────────────┐
                      │  DataType   │                   │ ConstantExpression │
                      ├─────────────┤   initial_value   ├────────────────────┤
                      │             ├──────────────────►│                    │
                      │ - name      │                   │  ...               │
                      │             ├─────────┐         │                    │
                      └──────┬──────┘         │         └────────────────────┘
                             │                │
                             │                │         ┌────────────────────┐
                             │                │         │ TypeNature         │
                             │                │         ├────────────────────┤
                             │ information    │         │ - Any              │
                             │                └────────►│ - Derived          │
                             │                nature    │ - Elementary       │
                             │                          │ - Num              │
                             ▼                          │ - Int              │
                      ┌───────────────────────┐         │ - Signed           │
                      │    &lt;abstract&gt;         │         │ - ...              │
                      │  DataTypeInformation  │         └────────────────────┘
                      ├───────────────────────┤
                      │                       │
                      └───────────────────────┘
                                  ▲
                                  │
                                  │
                                  │
         ┌────────────────┬───────┴───────┬──────────────┬──────────────┐
         │                │               │              │              │
┌────────┴───────┐ ┌──────┴──────┐ ┌──────┴─────┐  ┌─────┴──────┐  ┌────┴─────┐
│ Struct         │ │  Array      │ │ Integer    │  │  String    │  │ ...      │
├────────────────┤ ├─────────────┤ ├────────────┤  ├────────────┤  ├──────────┤
│ - name         │ │- name       │ │ - name     │  │ - size     │  │ ...      │
│ - member_names │ │- inner_type │ │ - signed   │  │ - encoding │  │          │
│                │ │- dimensions │ │ - size     │  │            │  │          │
└────────────────┘ └─────────────┘ └────────────┘  └────────────┘  └──────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linker"><a class="header" href="#linker">Linker</a></h1>
<p>The linker's task is to decide where all references in the source code point to. There are different references in Structured Text:</p>
<ul>
<li>variable references<br />
<code>x := 4</code> where <em>x</em> is a reference to the variable x.</li>
<li>type references<br />
<code>i : MyFunctionBlock</code> where <em>MyFunctionBlock</em> is a reference to the declared FunctionBlock</li>
<li>Program references<br />
<code>PLC_PRG.x := 4</code> where <em>PLC_PRG</em> is a reference to a Program-POU called <em>PLC_PRG</em></li>
<li>Function references<br />
<code>max(a, b)</code> where <em>max</em> is a reference to a Function-POU called <em>max</em>.</li>
</ul>
<p>So the linker decides where a reference points to. A reference has a corresponding declaration that matches the reference's name:</p>
<pre><code class="language-iecst">        PROGRAM PLC_PRG
             VAR

        ┌──────► x : INT;
        │
        │    END_VAR      
        │
        └────┐
             │
             x := 3;
        END_PROGRAM
</code></pre>
<p>The linker's results will be used by the semantic validation step and by the code-generation. </p>
<p>The validator decides whether the name you put at a certain location is valid or not. In order to decide whether a certain reference is valid or not, we need to know where it is pointing to, so whether we expect a variable, a datatype or something different.</p>
<p>The code-generation needs to know what certain names mean, in order to successfully generate the IR-code that reflects the behavior of your program.</p>
<h2 id="annotated-syntax-tree"><a class="header" href="#annotated-syntax-tree">Annotated Syntax Tree</a></h2>
<p>The AST generated by the parser is a pretty static data-structure. So where should we store the linking information for a reference? Even if we would add fields for potential linking-information to the AST, the ownership concepts of Rust would give us a hard time to fill this information piece by piece during linking. So what we end up doing, is to use the <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">arena-pattern</a> to handle the different lifetimes of the parts of an AST (the AST itself is constructed very early in the compilation process, where the linking information is allocated later). We don't store the linking information directly in the AST, but we store it inside the mentioned arena-data-structure and link it with certain AST-elements.</p>
<p>The rusty linker stores the linking information in an arena called AnnotationMap. The AnnotationMap can store two type of annotations for any AST-element. So the first step is that we need a way to uniquely identify every single AST-node so we can use this ID as a key for the annotations stored in the AnnotationMap to automatically associate it with the given AST-Node. The parser assigns a unique ID to every Statement-Tree-Node (Note that we only assign IDs to Statements, not every AST-Node).</p>
<p>So the expression <code>a + 3</code> now looks like this:</p>
<pre><code class="language-ignore">                      ┌─────────────────┐
                      │ BinaryOperation │
                      ├─────────────────┤
                      │  operator: Plus │
                      │  ID: 1          │
                      └──────┬──┬───────┘
                             │  │
                   left      │  │     right 
                 ┌───────────┘  └──────────┐
                 │                         │
                 │                         │
                 ▼                         ▼
        ┌──────────────────┐     ┌──────────────────┐
        │    Reference     │     │  LiteralInteger  │
        ├──────────────────┤     ├──────────────────┤
        │    name: 'a'     │     │    value: '3'    │
        │    ID: 2         │     │    ID: 3         │
        └──────────────────┘     └──────────────────┘
</code></pre>
<p>The AnnotationMap stores 5 different types of annotation:</p>
<ul>
<li><code>Value</code><br />
The Value-annotation indicates that this AST-Element resolves to a value with the given resulting datatype. So for Example the LiteralInteger(3) node gets a Value-Annotation with a resulting type of <code>DINT</code>.</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────┐
        │   Value                 │
        ├─────────────────────────┤
        │                         │
        │  resulting_type: String │
        │                         │
        └─────────────────────────┘
</code></pre>
<ul>
<li><code>Variable</code>
The Variable-annotation indicates that this AST-Element resolves to a variable with the given qualified name (and some comfort-information like whether it is a constant and whether it is an auto-deref pointer). Similar to the value-Annotation it also saves the resulting datatype.</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────┐
        │   Variable              │
        ├─────────────────────────┤
        │                         │
        │  resulting_type: String │
        │  qualified_name: String │
        │  constant: bool         │
        │  is_auto_deref: bool    │
        │                         │
        └─────────────────────────┘
</code></pre>
<ul>
<li><code>Function</code>
The Function-annotation indicates that this AST-Element resolves to a Function-POU (a call-statement) with the given qualified name. Similar to the value-Annotation it also saves the resulting datatype but this time as the function's return type (<em>return_type</em>).</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────┐
        │   Function              │
        ├─────────────────────────┤
        │                         │
        │  return_type: String    │
        │  qualified_name: String │
        │                         │
        └─────────────────────────┘
</code></pre>
<ul>
<li><code>Type</code>
The Type-annotation indicates that this AST-Element resolves to a DataType (e.g. a Declaration: <code>x: INT</code>) with the given name.</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────┐
        │   Type                  │
        ├─────────────────────────┤
        │                         │
        │  type_name : String     │
        │                         │
        └─────────────────────────┘
</code></pre>
<ul>
<li><code>Program</code>
The Program-annotation is very similar to the Function-annotation. Since a Program has no return-value it also offers no return-type information.</li>
</ul>
<pre><code class="language-ignore">        ┌─────────────────────────┐
        │   Program               │
        ├─────────────────────────┤
        │                         │
        │  qualified_name: String │
        │                         │
        └─────────────────────────┘
</code></pre>
<p>So the example expression from above `a + 3* will be annotated like this: Note that the resulting type of the Binary-Operation must be calculated by the linker by determining the bigger of both types.</p>
<pre><code class="language-ignore">                  ┌─────────────────┐
                  │ BinaryOperation │
                  ├─────────────────┤
                  │  operator: Plus │
                  │  ID: 1          │
                  └──────┬──┬───────┘
                         │  │
               left      │  │     right
             ┌───────────┘  └──────────┐
             │                         │
             │                         │
             ▼                         ▼
    ┌──────────────────┐     ┌──────────────────┐
    │    Reference     │     │  LiteralInteger  │
    ├──────────────────┤     ├──────────────────┤
    │    name: 'a'     │     │    value: '3'    │
    │    ID: 2         │     │    ID: 3         │
    └──────────────────┘     └──────────────────┘



                             ┌────────────────────────────┐
                             │        Value               │
┌───────────────────┐        ├────────────────────────────┤
│    AnnotationMap  │   ┌───►│  resulting_type: DINT      │
│                   │   │    │                            │
├───────┬───────────┤   │    └────────────────────────────┘
│ ID: 1 │ Value     ├───┘
├───────┼───────────┤        ┌────────────────────────────┐
│ ID: 2 │ Variable  ├────┐   │        Variable            │
├───────┼───────────┤    │   ├────────────────────────────┤
│ ID: 3 │ Value     ├──┐ │   │  resulting_type: SINT      │
└───────┴───────────┘  │ └──►│  qualified_name: PLC_PRG.a │
                       │     │        constant: false     │
                       │     │   is_auto_deref: false     │
                       │     └────────────────────────────┘
                       │
                       │     ┌────────────────────────────┐
                       │     │        Value               │
                       │     ├────────────────────────────┤
                       └────►│  resulting_type: DINT      │
                             │                            │
                             └────────────────────────────┘
</code></pre>
<p>Another example where the annotated AST carries a lot of useful information is with complex expressions like array-expressions or qualified references. Lets consider the following statement:</p>
<pre><code class="language-iecst">PLC_PRG.a.b[2]
</code></pre>
<p>It is annotated in the following way:</p>
<pre><code class="language-ignore">                ┌────────────────────┐
                │ QualifiedReference │
                ├────────────────────┤
                │ ID: 1              │
                └─────────┬──────────┘
                          │          elements: Vec&lt;AstStatement&gt;
                ┌─────────┴──────────┬─────────────────────┐
                │                    │                     │
                ▼                    ▼                     ▼
        ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
        │    Reference     │  │    Reference     │  │   ArrayAccess    │
        ├──────────────────┤  ├──────────────────┤  ├──────────────────┤
        │  name: 'PLC_PRG' │  │  name: 'a'       │  │                  │
        │  ID: 2           │  │  ID: 3           │  │    ID: 4         │
        └──────────────────┘  └──────────────────┘  └─────┬──────┬─────┘
                                                          │      │
                                             reference    │      │       access
                                                 ┌────────┘      └─────────┐
                                                 ▼                         ▼
                                        ┌──────────────────┐   ┌──────────────────┐
                                        │    Reference     │   │  LiteralInteger  │
                                        ├──────────────────┤   ├──────────────────┤
                                        │  name: 'b'       │   │    value: '2'    │
                                        │  ID: 5           │   │    ID: 6         │
                                        └──────────────────┘   └──────────────────┘


                                     ┌────────────────────────────┐
                                     │        Value               │
                                ┌───►├────────────────────────────┤
                                │    │  resulting_type: INT       │
                                │    │                            │
                                │    └────────────────────────────┘
                                │
                                │    ┌────────────────────────────┐
        ┌───────────────────┐   │    │       Program              │
        │    AnnotationMap  │   │ ┌─►├────────────────────────────┤
        │                   │   │ │  │  qualified_name: PLC_PRG   │
        ├───────┬───────────┤   │ │  │                            │
        │ ID: 1 │ Value     ├───┘ │  └────────────────────────────┘
        ├───────┼───────────┤     │
        │ ID: 2 │ Program   ├─────┘  ┌────────────────────────────┐
        ├───────┼───────────┤        │        Variable            │
        │ ID: 3 │ Variable  ├───────►├────────────────────────────┤
        ├───────┼───────────┤        │ resulting_type: MyStruct   │
        │ ID: 4 │ Value     ├─────┐  │ qualified_name: PLC_PRG.a  │
        ├───────┼───────────┤     │  └────────────────────────────┘
        │ ID: 5 │ Variable  ├───┐ │
        ├───────┼───────────┤   │ │  ┌────────────────────────────┐
        │ ID: 6 │ Value     ├─┐ │ │  │        Value               │
        └───────┴───────────┘ │ │ └─►├────────────────────────────┤
                              │ │    │ resulting_type: INT        │
                              │ │    │                            │
                              │ │    └────────────────────────────┘
                              │ │
                              │ │    ┌─────────────────────────────────┐
                              │ │    │        Variable                 │
                              │ └───►├─────────────────────────────────┤
                              │      │ resulting_type : ARRAY[] OF INT │
                              │      │ qualified_name : MyStruct.b     │
                              │      └─────────────────────────────────┘
                              │
                              │      ┌────────────────────────────┐
                              │      │        Value               │
                              │      ├────────────────────────────┤
                              └─────►│ resulting_type: DINT       │
                                     │                            │
                                     └────────────────────────────┘
</code></pre>
<h2 id="type-vs-type-hint"><a class="header" href="#type-vs-type-hint">Type vs. Type-Hint</a></h2>
<p>The AnnotationMap not only offers annotations regarding the AST-node's type, but it also offers a second type of annotation.</p>
<p>Consider the following snippet:</p>
<pre><code class="language-iecst">PROGRAM PLC_PRG
   VAR
      x : SINT;
      y : INT;
      z : BYTE;
   END_VAR

   z := x + y;

END_PROGRAM
</code></pre>
<p>The assignment <code>z := x + y</code> is loaded with different types:</p>
<ul>
<li><code>x</code> is annotated as <em>Variable</em> of type <em>SINT</em> and will be auto-upgraded to <em>DINT</em></li>
<li><code>y</code> is annotated as <em>Variable</em> of type <em>INT</em> and will be auto-upgraded to <em>DINT</em></li>
<li><code>z</code> is annotated as <em>Variable</em> of type <em>BYTE</em></li>
<li><code>x + y</code> is annotated as <em>Value</em> of type <em>DINT</em> (the bigger of both)</li>
</ul>
<p>In order to make life easier for validation and code-generation we add an additional annotation to <code>x + y</code> to indicate, that while it technically results in a <em>DINT</em>, it should rather be treated as a <em>BYTE</em> since it is going to be assigned to <code>z</code>. This second annotation is called the <em>type-hint</em>. It indicates that while it technically is not the real type of this expression, the program's semantic wants the compiler to treat it as this type.</p>
<p>The expression <code>z := x + y</code> is annotated like this:</p>
<table><thead><tr><th>expression</th><th>type annotation</th><th>type-hint annotation</th><th>explanation</th></tr></thead><tbody>
<tr><td><code>x</code></td><td>SINT</td><td>DINT</td><td>auto-upgraded to DINT</td></tr>
<tr><td><code>y</code></td><td>INT</td><td>DINT</td><td>auto-upgraded to DINT</td></tr>
<tr><td><code>z</code></td><td>BYTE</td><td>-</td><td></td></tr>
<tr><td><code>x + y</code></td><td>DINT</td><td>BYTE</td><td>type-hint indicates that the resulting DINT needs to be cast to BYTE</td></tr>
</tbody></table>
<p>With the help of the type-hint annotations the validation can decide whether certain type-cast operations are valid very easily. The code-generation steps can easily decide when to generate casts, by simply comparing a node's type annotation and it's type-hint annotation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>The validation module implements the semantic validation step of the compiler. The validator is a hand-written visitor that offers a callback when visiting the single AST-nodes to then perform the different validation tasks. The validation rules are implemented in dedicated validator-structs:</p>
<table><thead><tr><th>Validator</th><th>Responsibilities</th></tr></thead><tbody>
<tr><td>pou_validator</td><td>Semantic rules on the level of Programs, Functionblocks and Functions</td></tr>
<tr><td>variable_validator</td><td>Semantic rules on the level of variable declarations (e.g. empty var-blocks, empty structs, etc. )</td></tr>
<tr><td>stmt_validator</td><td>Semantic rules on the level of statements (e.g. invalid type-casts )</td></tr>
</tbody></table>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p>Problems (semantic or syntactic) are represented as <em>Diagnostics</em> <sup class="footnote-reference"><a href="#1">1</a></sup>. Diagnostics carry information on the exact location inside the source-string (start- &amp; end-offset), a custom message and a unique error-number to identify the problem. There are 3 types of <em>Diagnostics</em>:</p>
<table><thead><tr><th>Diagnostic</th><th>Description</th></tr></thead><tbody>
<tr><td>SyntaxError</td><td>A syntax error is a diagnostic that is created by the parser if it discovers a token-stream that does not match the language's grammar.</td></tr>
<tr><td>GeneralError</td><td>General errors are problems that occured during the compilation process, that cannot be linked to a malformed input (e.g. file-I/O problems, internal LLVM errors, etc.)</td></tr>
<tr><td>Improvement</td><td>Problems that may not prevent successful compilation but are still considered a flaw in the source-code. (e.g. use proprietary <em>POINTER TO</em> instead of the norm-compliant <em>REF_TO</em>)</td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>:(i): The diagnostics are subject to change since they don't elegantly represent the different types of problems (e.g. semantic problems).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-generation"><a class="header" href="#code-generation">Code-Generation</a></h1>
<p>The codegen module contains all code that turns the parsed and verified code represented as an AST into <a href="https://llvm.org/docs/LangRef.html">llvm-ir</a> code. To generate the <em>IR</em> we use a crate that wraps the native llvm <a href="https://github.com/TheDan64/inkwell">C-API</a>.</p>
<p>The code-generator is basically a transformation from the ST-AST into an IR-Tree representation. Therefore the AST is traversed in a visitor-like way and transformed simultaneously. The code generation is split into specialized sub-generators for different tasks:</p>
<table><thead><tr><th>Generator</th><th>Responsibilities</th></tr></thead><tbody>
<tr><td>pou_generator</td><td>The pou-generator takes care of generating the programming organization units (Programs, FunctionBlocks, Functions) including their signature and body. More specialized tasks are delegated to other generators.</td></tr>
<tr><td>data_type_generator</td><td>Generates complex datatypes like Structs, Arrays, Enums, Strings, etc.</td></tr>
<tr><td>variable_generator</td><td>Generates global variables and their initialization</td></tr>
<tr><td>statement_generator</td><td>Generates everything of the body of a POU except expressions. Non-expressions include: IFs, Loops, Assignments, etc.</td></tr>
<tr><td>expression_generator</td><td>Generates expressions (everything that <em>possibly</em> resolves to a value) including: call-statements, references, array-access, etc.</td></tr>
</tbody></table>
<h2 id="generating-pous"><a class="header" href="#generating-pous">Generating POUs</a></h2>
<p>Generating POUs (Programs, Function-Blocks, Functions) must generate the POU's body itself, as well as the POU's interface (or state) variables. In this segment we focus on generating the interface for a POU. Further information about generating a POU's body can be found [here].</p>
<h3 id="programs"><a class="header" href="#programs">Programs</a></h3>
<p>A program is <em>static</em> POU with some code attached. This means that there is exactly one instance. So wherever from it is called, every caller uses the exact same instance which means that you may see the residuals of the laster caller in the program's variables when you call it yourself. </p>
<pre><code class="language-iecst">PROGRAM prg
    VAR
        x : DINT;
        y : DINT;
    END_VAR

END_PROGRAM
</code></pre>
<p>The program's interface is persistent across calls, so we store it in a global variable. Therefore the code-generator creates a dedicated struct-type called <code>prg_interface</code>. A global variable called <code>prg_instance</code> is generated to store the program's state across calls. This global instance variable is passed as a <code>this</code> pointer to calls to the <code>prg</code> function. </p>
<pre><code class="language-llvm">%prg_interface = type { i32, i32 }

@prg_instance = global %prg_interface zeroinitializer

define void @prg(%prg_interface* %this) {
entry:
  ret void
}
</code></pre>
<h3 id="functionblocks"><a class="header" href="#functionblocks">FunctionBlocks</a></h3>
<p>A FunctionBlock is an POU that is instantiated in a declaration. So in contrast to Programs, a FunctionBlock can have multiple instances. Nevertheless the code-generator uses a very similar strategy. A struct-type for the FunctionBlock's interface is created but no global instance-variable is allocated. Instead the function block can be used as a DataType to declare instances like in the following example:</p>
<pre><code class="language-iecst">FUNCTION_BLOCK foo
  VAR_INPUT
    x, y : INT;
  END_VAR
END_FUNCTION_BLOCK

PROGRAM prg
  VAR
    f : foo;
  END_VAR
END_PROGRAM
</code></pre>
<p>So for the given example, we see the code-generator creating a type for the FunctionBlock's state (<code>foo_interface</code>). The declared instance of foo, in <code>prg's</code> interface is seen in the program's generated interface struct-type (<code>prg_interface</code>).</p>
<pre><code class="language-llvm">; ModuleID = 'main'
source_filename = &quot;main&quot;

%prg_interface = type { %foo_interface }
%foo_interface = type { i16, i16 }

@prg_instance = global %prg_interface zeroinitializer

define void @foo(%foo_interface* %0) {
entry:
  ret void
}

define void @prg(%prg_interface* %0) {
entry:
  ret void
}
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Functions generate very similar to program's and function_block's. The main difference is, that no instance-global is allocated and the function's interface-type cannot be used as a datatype to declare your own instances. Instances of the program's interface-type are allocated whenever the function is called for the lifetime of a single call. Otherwise the code generated for functions is comparable to the code presented above for programs and function-blocks.</p>
<h2 id="generating-data-types"><a class="header" href="#generating-data-types">Generating Data Types</a></h2>
<p>IEC61131-3 languages offer a wide range of data types. Next to the built-in intrinsic data types, we support following user defined data types:</p>
<h3 id="range-types"><a class="header" href="#range-types">Range Types</a></h3>
<p>For range types we don't generate special code. Internally the new data type just becomes an alias for the derived type.</p>
<h3 id="pointer-types"><a class="header" href="#pointer-types">Pointer Types</a></h3>
<p>For pointer types we don't generate special code. Internally the new data type just becomes an alias for the pointer-type.</p>
<h3 id="struct-types"><a class="header" href="#struct-types">Struct Types</a></h3>
<p>Struct types translate direclty to llvm struct datatypes. We generate a new datatype with the user-type's name for the struct.</p>
<pre><code class="language-iecst">TYPE MyStruct: 
  STRUCT
    a: DINT;
    b: INT;
  END_STRUCT
END_TYPE
</code></pre>
<p>This struct simply generates a llvm struct type:</p>
<pre><code class="language-llvm">%MyStruct = type { i32, i16 }
</code></pre>
<h3 id="enum-types"><a class="header" href="#enum-types">Enum Types</a></h3>
<p>Enumerations are represented as <code>DINT</code>. </p>
<pre><code class="language-iecst">TYPE MyEnum: (red, yellow, green);
END_TYPE
</code></pre>
<p>For every enum's element we generate a global variable with the element's value.</p>
<pre><code class="language-llvm">@red = global i32 0
@yellow = global i32 1
@green = global i32 2
</code></pre>
<h3 id="array-types"><a class="header" href="#array-types">Array Types</a></h3>
<p>Array types are generated as fixed sized llvm vector types - note that Array types must be fixed sized in <em>ST</em>:</p>
<pre><code class="language-iecst">TYPE MyArray: ARRAY[0..9] OF INT; 
END_TYPE

VAR_GLOBAL
  x : MyArray;
  y : ARRAY[0..5] OF REAL;
END_VAR
</code></pre>
<p>Custom array data types are not reflected as dedicated types on the llvm-level.</p>
<pre><code class="language-llvm">@x = global [10 x i16] zeroinitializer
@y = global [6 x float] zeroinitializer
</code></pre>
<h4 id="multi-dimensional-arrays"><a class="header" href="#multi-dimensional-arrays">Multi dimensional arrays</a></h4>
<p>Arrays can be declared as multi-dimensional:</p>
<pre><code class="language-iecst">VAR_GLOBAL
  x : ARRAY[0..5, 2..5, 0..1] OF INT;
END_VAR
</code></pre>
<p>The compiler will flatten these type of arrays to a single-dimension. To accomplish that, it calculates the total
length by mulitplying the sizes of all dimensions:</p>
<pre><code class="language-ignore">    0..5 x 2..5 x 0..1
      6  x   4  x   2  = 64
</code></pre>
<p>So the array <code>x : ARRAY[0..5, 2..5, 0..1] OF INT;</code> will be generated as:</p>
<pre><code class="language-llvm">@x = global [64 x i16] zeroinitializer
</code></pre>
<p>This means that such a multidimensional array must be initialized like a single-dimensional array:</p>
<ul>
<li><em>wrong</em></li>
</ul>
<pre><code class="language-iecst">VAR_GLOBAL
  wrong_array : ARRAY[1..2, 0..3] OF INT := [ [10, 11, 12], 
                                              [20, 21, 22], 
                                              [30, 31, 32]]; 
END_VAR
</code></pre>
<ul>
<li><em>correct</em></li>
</ul>
<pre><code class="language-iecst">VAR_GLOBAL
  correct_array : ARRAY[1..2, 0..3] OF INT := [ 10, 11, 12, 
                                                20, 21, 22, 
                                                30, 31, 32]; 
END_VAR
</code></pre>
<blockquote>
<p><em>Nested Arrays</em></p>
<p>Note that arrays declared as <code>x : ARRAY[0..2] OF ARRAY[0..2] OF INT</code> are different from mutli-dimensional 
arrays discussed in this section. Nested arrays are represented as multi-dimensional arrays on the LLVM-IR 
level and must also be initialized using nested array-literals!</p>
</blockquote>
<h3 id="string-types"><a class="header" href="#string-types">String Types</a></h3>
<p>String types are generated as fixed sized vector types.</p>
<pre><code class="language-iecst">VAR_GLOBAL
    str  : STRING[20];
    wstr : WSTRING[20];
END_VAR
</code></pre>
<p>Strings can be represented in two different encodings: <em>UTF-8 (STRING)</em> or <em>UTF-16 (WSTRING)</em>. </p>
<pre><code class="language-llvm">@str = global [21 x i8] zeroinitializer
@wstr = global [21 x i16] zeroinitializer
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="iecst.min.js"></script>
        <script type="text/javascript" src="llvm.min.js"></script>
        <script type="text/javascript" src="custom.js"></script>
        <script type="text/javascript" src="highlight.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
