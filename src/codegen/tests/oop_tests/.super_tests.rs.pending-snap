{"run_id":"ce259dbe-37ee-4f67-8779-b6193b41158b","line":1806,"new":{"module_name":"rusty__codegen__tests__oop_tests__super_tests","snapshot_name":"super_with_structured_types","metadata":{"source":"src/codegen/tests/oop_tests/super_tests.rs","assertion_line":1806,"expression":"result"},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%Complex_Type = type { i16, i16, float }\n%parent = type { %Complex_Type, [2 x %Complex_Type] }\n%child = type { %parent }\n\n@__parent.arr_data__init = unnamed_addr constant [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }]\n@__Complex_Type__init = constant %Complex_Type zeroinitializer\n@__parent__init = constant %parent { %Complex_Type zeroinitializer, [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }] }\n@__child__init = constant %child { %parent { %Complex_Type zeroinitializer, [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }] } }\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___Test, i8* null }]\n\ndefine void @parent(%parent* %0) {\nentry:\n  %this = alloca %parent*, align 8\n  store %parent* %0, %parent** %this, align 8\n  %data = getelementptr inbounds %parent, %parent* %0, i32 0, i32 0\n  %arr_data = getelementptr inbounds %parent, %parent* %0, i32 0, i32 1\n  ret void\n}\n\ndefine void @child(%child* %0) {\nentry:\n  %this = alloca %child*, align 8\n  store %child* %0, %child** %this, align 8\n  %__parent = getelementptr inbounds %child, %child* %0, i32 0, i32 0\n  ret void\n}\n\ndefine void @child_test(%child* %0) {\nentry:\n  %this = alloca %child*, align 8\n  store %child* %0, %child** %this, align 8\n  %__parent = getelementptr inbounds %child, %child* %0, i32 0, i32 0\n  %local_data = alloca %Complex_Type, align 8\n  %1 = bitcast %Complex_Type* %local_data to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%Complex_Type* @__Complex_Type__init to i8*), i64 ptrtoint (%Complex_Type* getelementptr (%Complex_Type, %Complex_Type* null, i32 1) to i64), i1 false)\n  call void @__init_complex_type(%Complex_Type* %local_data)\n  call void @__user_init_Complex_Type(%Complex_Type* %local_data)\n  %x = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 0\n  %data = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %x1 = getelementptr inbounds %Complex_Type, %Complex_Type* %data, i32 0, i32 0\n  %load_x = load i16, i16* %x1, align 2\n  store i16 %load_x, i16* %x, align 2\n  %y = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 1\n  %data2 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %y3 = getelementptr inbounds %Complex_Type, %Complex_Type* %data2, i32 0, i32 1\n  %load_y = load i16, i16* %y3, align 2\n  store i16 %load_y, i16* %y, align 2\n  %z = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 2\n  %data4 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %z5 = getelementptr inbounds %Complex_Type, %Complex_Type* %data4, i32 0, i32 2\n  %load_z = load float, float* %z5, align 4\n  store float %load_z, float* %z, align 4\n  %arr_data = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data, i32 0, i32 0\n  %x6 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar, i32 0, i32 0\n  %arr_data7 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar8 = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data7, i32 0, i32 1\n  %x9 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar8, i32 0, i32 0\n  %load_x10 = load i16, i16* %x9, align 2\n  store i16 %load_x10, i16* %x6, align 2\n  %arr_data11 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar12 = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data11, i32 0, i32 0\n  %z13 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar12, i32 0, i32 2\n  %data14 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %z15 = getelementptr inbounds %Complex_Type, %Complex_Type* %data14, i32 0, i32 2\n  %load_z16 = load float, float* %z15, align 4\n  store float %load_z16, float* %z13, align 4\n  ret void\n}\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\ndefine void @__init_complex_type(%Complex_Type* %0) {\nentry:\n  %self = alloca %Complex_Type*, align 8\n  store %Complex_Type* %0, %Complex_Type** %self, align 8\n  ret void\n}\n\ndefine void @__init_parent(%parent* %0) {\nentry:\n  %self = alloca %parent*, align 8\n  store %parent* %0, %parent** %self, align 8\n  %deref = load %parent*, %parent** %self, align 8\n  %data = getelementptr inbounds %parent, %parent* %deref, i32 0, i32 0\n  call void @__init_complex_type(%Complex_Type* %data)\n  %deref1 = load %parent*, %parent** %self, align 8\n  %data2 = getelementptr inbounds %parent, %parent* %deref1, i32 0, i32 0\n  %load_x = getelementptr inbounds %Complex_Type, %Complex_Type* %data2, i32 0, i32 0\n  store i16 10, i16* %load_x, align 2\n  %deref3 = load %parent*, %parent** %self, align 8\n  %data4 = getelementptr inbounds %parent, %parent* %deref3, i32 0, i32 0\n  %load_y = getelementptr inbounds %Complex_Type, %Complex_Type* %data4, i32 0, i32 1\n  store i16 20, i16* %load_y, align 2\n  %deref5 = load %parent*, %parent** %self, align 8\n  %data6 = getelementptr inbounds %parent, %parent* %deref5, i32 0, i32 0\n  %load_z = getelementptr inbounds %Complex_Type, %Complex_Type* %data6, i32 0, i32 2\n  store float 3.050000e+01, float* %load_z, align 4\n  ret void\n}\n\ndefine void @__init_child(%child* %0) {\nentry:\n  %self = alloca %child*, align 8\n  store %child* %0, %child** %self, align 8\n  %deref = load %child*, %child** %self, align 8\n  %__parent = getelementptr inbounds %child, %child* %deref, i32 0, i32 0\n  call void @__init_parent(%parent* %__parent)\n  ret void\n}\n\ndefine void @__user_init_Complex_Type(%Complex_Type* %0) {\nentry:\n  %self = alloca %Complex_Type*, align 8\n  store %Complex_Type* %0, %Complex_Type** %self, align 8\n  ret void\n}\n\ndefine void @__user_init_child(%child* %0) {\nentry:\n  %self = alloca %child*, align 8\n  store %child* %0, %child** %self, align 8\n  %deref = load %child*, %child** %self, align 8\n  %__parent = getelementptr inbounds %child, %child* %deref, i32 0, i32 0\n  call void @__user_init_parent(%parent* %__parent)\n  ret void\n}\n\ndefine void @__user_init_parent(%parent* %0) {\nentry:\n  %self = alloca %parent*, align 8\n  store %parent* %0, %parent** %self, align 8\n  %deref = load %parent*, %parent** %self, align 8\n  %data = getelementptr inbounds %parent, %parent* %deref, i32 0, i32 0\n  call void @__user_init_Complex_Type(%Complex_Type* %data)\n  ret void\n}\n\ndefine void @__init___Test() {\nentry:\n  ret void\n}\n\nattributes #0 = { argmemonly nofree nounwind willreturn }"},"old":{"module_name":"rusty__codegen__tests__oop_tests__super_tests","metadata":{},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%Complex_Type = type { i16, i16, float }\n%parent = type { %Complex_Type, [2 x %Complex_Type] }\n%child = type { %parent }\n\n@__parent.data__init = unnamed_addr constant %Complex_Type { i16 10, i16 20, float 3.050000e+01 }\n@__parent.arr_data__init = unnamed_addr constant [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }]\n@__Complex_Type__init = constant %Complex_Type zeroinitializer\n@__parent__init = constant %parent { %Complex_Type { i16 10, i16 20, float 3.050000e+01 }, [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }] }\n@__child__init = constant %child { %parent { %Complex_Type { i16 10, i16 20, float 3.050000e+01 }, [2 x %Complex_Type] [%Complex_Type { i16 1, i16 2, float 3.500000e+00 }, %Complex_Type { i16 4, i16 5, float 6.500000e+00 }] } }\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___Test, i8* null }]\n\ndefine void @parent(%parent* %0) {\nentry:\n  %this = alloca %parent*, align 8\n  store %parent* %0, %parent** %this, align 8\n  %data = getelementptr inbounds %parent, %parent* %0, i32 0, i32 0\n  %arr_data = getelementptr inbounds %parent, %parent* %0, i32 0, i32 1\n  ret void\n}\n\ndefine void @child(%child* %0) {\nentry:\n  %this = alloca %child*, align 8\n  store %child* %0, %child** %this, align 8\n  %__parent = getelementptr inbounds %child, %child* %0, i32 0, i32 0\n  ret void\n}\n\ndefine void @child_test(%child* %0) {\nentry:\n  %this = alloca %child*, align 8\n  store %child* %0, %child** %this, align 8\n  %__parent = getelementptr inbounds %child, %child* %0, i32 0, i32 0\n  %local_data = alloca %Complex_Type, align 8\n  %1 = bitcast %Complex_Type* %local_data to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 bitcast (%Complex_Type* @__Complex_Type__init to i8*), i64 ptrtoint (%Complex_Type* getelementptr (%Complex_Type, %Complex_Type* null, i32 1) to i64), i1 false)\n  call void @__init_complex_type(%Complex_Type* %local_data)\n  call void @__user_init_Complex_Type(%Complex_Type* %local_data)\n  %x = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 0\n  %data = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %x1 = getelementptr inbounds %Complex_Type, %Complex_Type* %data, i32 0, i32 0\n  %load_x = load i16, i16* %x1, align 2\n  store i16 %load_x, i16* %x, align 2\n  %y = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 1\n  %data2 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %y3 = getelementptr inbounds %Complex_Type, %Complex_Type* %data2, i32 0, i32 1\n  %load_y = load i16, i16* %y3, align 2\n  store i16 %load_y, i16* %y, align 2\n  %z = getelementptr inbounds %Complex_Type, %Complex_Type* %local_data, i32 0, i32 2\n  %data4 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %z5 = getelementptr inbounds %Complex_Type, %Complex_Type* %data4, i32 0, i32 2\n  %load_z = load float, float* %z5, align 4\n  store float %load_z, float* %z, align 4\n  %arr_data = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data, i32 0, i32 0\n  %x6 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar, i32 0, i32 0\n  %arr_data7 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar8 = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data7, i32 0, i32 1\n  %x9 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar8, i32 0, i32 0\n  %load_x10 = load i16, i16* %x9, align 2\n  store i16 %load_x10, i16* %x6, align 2\n  %arr_data11 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 1\n  %tmpVar12 = getelementptr inbounds [2 x %Complex_Type], [2 x %Complex_Type]* %arr_data11, i32 0, i32 0\n  %z13 = getelementptr inbounds %Complex_Type, %Complex_Type* %tmpVar12, i32 0, i32 2\n  %data14 = getelementptr inbounds %parent, %parent* %__parent, i32 0, i32 0\n  %z15 = getelementptr inbounds %Complex_Type, %Complex_Type* %data14, i32 0, i32 2\n  %load_z16 = load float, float* %z15, align 4\n  store float %load_z16, float* %z13, align 4\n  ret void\n}\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\ndefine void @__init_complex_type(%Complex_Type* %0) {\nentry:\n  %self = alloca %Complex_Type*, align 8\n  store %Complex_Type* %0, %Complex_Type** %self, align 8\n  ret void\n}\n\ndefine void @__init_parent(%parent* %0) {\nentry:\n  %self = alloca %parent*, align 8\n  store %parent* %0, %parent** %self, align 8\n  %deref = load %parent*, %parent** %self, align 8\n  %data = getelementptr inbounds %parent, %parent* %deref, i32 0, i32 0\n  call void @__init_complex_type(%Complex_Type* %data)\n  %deref1 = load %parent*, %parent** %self, align 8\n  %data2 = getelementptr inbounds %parent, %parent* %deref1, i32 0, i32 0\n  %load_x = getelementptr inbounds %Complex_Type, %Complex_Type* %data2, i32 0, i32 0\n  store i16 10, i16* %load_x, align 2\n  %deref3 = load %parent*, %parent** %self, align 8\n  %data4 = getelementptr inbounds %parent, %parent* %deref3, i32 0, i32 0\n  %load_y = getelementptr inbounds %Complex_Type, %Complex_Type* %data4, i32 0, i32 1\n  store i16 20, i16* %load_y, align 2\n  %deref5 = load %parent*, %parent** %self, align 8\n  %data6 = getelementptr inbounds %parent, %parent* %deref5, i32 0, i32 0\n  %load_z = getelementptr inbounds %Complex_Type, %Complex_Type* %data6, i32 0, i32 2\n  store float 3.050000e+01, float* %load_z, align 4\n  ret void\n}\n\ndefine void @__init_child(%child* %0) {\nentry:\n  %self = alloca %child*, align 8\n  store %child* %0, %child** %self, align 8\n  %deref = load %child*, %child** %self, align 8\n  %__parent = getelementptr inbounds %child, %child* %deref, i32 0, i32 0\n  call void @__init_parent(%parent* %__parent)\n  ret void\n}\n\ndefine void @__user_init_Complex_Type(%Complex_Type* %0) {\nentry:\n  %self = alloca %Complex_Type*, align 8\n  store %Complex_Type* %0, %Complex_Type** %self, align 8\n  ret void\n}\n\ndefine void @__user_init_child(%child* %0) {\nentry:\n  %self = alloca %child*, align 8\n  store %child* %0, %child** %self, align 8\n  %deref = load %child*, %child** %self, align 8\n  %__parent = getelementptr inbounds %child, %child* %deref, i32 0, i32 0\n  call void @__user_init_parent(%parent* %__parent)\n  ret void\n}\n\ndefine void @__user_init_parent(%parent* %0) {\nentry:\n  %self = alloca %parent*, align 8\n  store %parent* %0, %parent** %self, align 8\n  %deref = load %parent*, %parent** %self, align 8\n  %data = getelementptr inbounds %parent, %parent* %deref, i32 0, i32 0\n  call void @__user_init_Complex_Type(%Complex_Type* %data)\n  ret void\n}\n\ndefine void @__init___Test() {\nentry:\n  ret void\n}\n\nattributes #0 = { argmemonly nofree nounwind willreturn }"}}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1983,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":338,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":204,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1368,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":824,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":550,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1067,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":19,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":437,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":963,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1587,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1201,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":108,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":715,"new":null,"old":null}
{"run_id":"c0c02e06-d7da-4b4c-9d46-17e287d17d88","line":1806,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1983,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1368,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":338,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1067,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":824,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":19,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":550,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":963,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":204,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":437,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1587,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":715,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1201,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":108,"new":null,"old":null}
{"run_id":"390fe870-eae2-4b4c-83c0-d4a6306aae31","line":1806,"new":null,"old":null}
