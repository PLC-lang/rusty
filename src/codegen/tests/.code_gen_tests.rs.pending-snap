{"run_id":"1737017381-988137738","line":1108,"new":{"module_name":"rusty__codegen__tests__code_gen_tests","snapshot_name":"fb_method_called_locally","metadata":{"source":"src/codegen/tests/code_gen_tests.rs","assertion_line":1108,"expression":"result"},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n\n@__foo__init = unnamed_addr constant %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %call = call i32 @foo.addToBar(%foo* %0, i16 42)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, i16 %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar = alloca i32, align 4\n  %in = alloca i16, align 2\n  store i16 %1, i16* %in, align 2\n  store i32 0, i32* %foo.addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar, align 4\n  %load_bar1 = load i32, i32* %bar, align 4\n  store i32 %load_bar1, i32* %foo.addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %foo.addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %fb = alloca %foo, align 8\n  %x = alloca i32, align 4\n  %0 = bitcast %foo* %fb to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 bitcast (%foo* @__foo__init to i8*), i64 ptrtoint (%foo* getelementptr (%foo, %foo* null, i32 1) to i64), i1 false)\n  store i32 0, i32* %x, align 4\n  call void @__init_foo(%foo* %fb)\n  %call = call i32 @foo.addToBar(%foo* %fb, i16 3)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\nattributes #0 = { argmemonly nofree nounwind willreturn }\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@__foo__init = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  ret void\n}"},"old":{"module_name":"rusty__codegen__tests__code_gen_tests","metadata":{},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n%foo.addToBar = type { i16 }\n\n@__foo__init = unnamed_addr constant %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 42, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %0, %foo.addToBar* %foo.addToBar_instance)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, %foo.addToBar* %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %in = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 0\n  %addToBar = alloca i32, align 4\n  store i32 0, i32* %addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar, align 4\n  %load_bar1 = load i32, i32* %bar, align 4\n  store i32 %load_bar1, i32* %addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %fb = alloca %foo, align 8\n  %x = alloca i32, align 4\n  %0 = bitcast %foo* %fb to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 bitcast (%foo* @__foo__init to i8*), i64 ptrtoint (%foo* getelementptr (%foo, %foo* null, i32 1) to i64), i1 false)\n  store i32 0, i32* %x, align 4\n  call void @__init_foo(%foo* %fb)\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 3, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %fb, %foo.addToBar* %foo.addToBar_instance)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\nattributes #0 = { argmemonly nofree nounwind willreturn }\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@__foo__init = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  ret void\n}"}}
{"run_id":"1737017381-988137738","line":1224,"new":{"module_name":"rusty__codegen__tests__code_gen_tests","snapshot_name":"fb_local_method_var_shadows_parent_var","metadata":{"source":"src/codegen/tests/code_gen_tests.rs","assertion_line":1224,"expression":"result"},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n\n@__foo__init = unnamed_addr constant %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %call = call i32 @foo.addToBar(%foo* %0, i16 42)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, i16 %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar = alloca i32, align 4\n  %in = alloca i16, align 2\n  store i16 %1, i16* %in, align 2\n  %bar1 = alloca i32, align 4\n  store i32 69, i32* %bar1, align 4\n  store i32 0, i32* %foo.addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar1, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar1, align 4\n  %load_bar2 = load i32, i32* %bar1, align 4\n  store i32 %load_bar2, i32* %foo.addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %foo.addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %fb = alloca %foo, align 8\n  %x = alloca i32, align 4\n  %0 = bitcast %foo* %fb to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 bitcast (%foo* @__foo__init to i8*), i64 ptrtoint (%foo* getelementptr (%foo, %foo* null, i32 1) to i64), i1 false)\n  store i32 0, i32* %x, align 4\n  call void @__init_foo(%foo* %fb)\n  %call = call i32 @foo.addToBar(%foo* %fb, i16 3)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\nattributes #0 = { argmemonly nofree nounwind willreturn }\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@__foo__init = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  ret void\n}"},"old":{"module_name":"rusty__codegen__tests__code_gen_tests","metadata":{},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n%foo.addToBar = type { i16, i32 }\n\n@__foo__init = unnamed_addr constant %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 42, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %0, %foo.addToBar* %foo.addToBar_instance)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, %foo.addToBar* %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %in = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 0\n  %bar1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 1\n  %addToBar = alloca i32, align 4\n  store i32 69, i32* %bar1, align 4\n  store i32 0, i32* %addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar1, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar1, align 4\n  %load_bar2 = load i32, i32* %bar1, align 4\n  store i32 %load_bar2, i32* %addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %fb = alloca %foo, align 8\n  %x = alloca i32, align 4\n  %0 = bitcast %foo* %fb to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 bitcast (%foo* @__foo__init to i8*), i64 ptrtoint (%foo* getelementptr (%foo, %foo* null, i32 1) to i64), i1 false)\n  store i32 0, i32* %x, align 4\n  call void @__init_foo(%foo* %fb)\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 3, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %fb, %foo.addToBar* %foo.addToBar_instance)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\n; Function Attrs: argmemonly nofree nounwind willreturn\ndeclare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #0\n\nattributes #0 = { argmemonly nofree nounwind willreturn }\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@__foo__init = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  ret void\n}"}}
{"run_id":"1737017381-988137738","line":4136,"new":null,"old":null}
{"run_id":"1737017381-988137738","line":1451,"new":{"module_name":"rusty__codegen__tests__code_gen_tests","snapshot_name":"prog_local_method_var_shadows_parent_var","metadata":{"source":"src/codegen/tests/code_gen_tests.rs","assertion_line":1451,"expression":"result"},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n\n@foo_instance = global %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %call = call i32 @foo.addToBar(%foo* %0, i16 42)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, i16 %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar = alloca i32, align 4\n  %in = alloca i16, align 2\n  store i16 %1, i16* %in, align 2\n  %bar1 = alloca i32, align 4\n  store i32 69, i32* %bar1, align 4\n  store i32 0, i32* %foo.addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar1, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar1, align 4\n  %load_bar2 = load i32, i32* %bar1, align 4\n  store i32 %load_bar2, i32* %foo.addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %foo.addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %x = alloca i32, align 4\n  store i32 0, i32* %x, align 4\n  %call = call i32 @foo.addToBar(%foo* @foo_instance, i16 3)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  call void @__init_foo(%foo* @foo_instance)\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\ndeclare void @foo(%foo*)"},"old":{"module_name":"rusty__codegen__tests__code_gen_tests","metadata":{},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n%foo.addToBar = type { i16, i32 }\n\n@foo_instance = global %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 42, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %0, %foo.addToBar* %foo.addToBar_instance)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, %foo.addToBar* %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %in = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 0\n  %bar1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 1\n  %addToBar = alloca i32, align 4\n  store i32 69, i32* %bar1, align 4\n  store i32 0, i32* %addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar1, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar1, align 4\n  %load_bar2 = load i32, i32* %bar1, align 4\n  store i32 %load_bar2, i32* %addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %x = alloca i32, align 4\n  store i32 0, i32* %x, align 4\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %0 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 3, i16* %0, align 2\n  %call = call i32 @foo.addToBar(%foo* @foo_instance, %foo.addToBar* %foo.addToBar_instance)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  call void @__init_foo(%foo* @foo_instance)\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\ndeclare void @foo(%foo*)"}}
{"run_id":"1737017381-988137738","line":1339,"new":{"module_name":"rusty__codegen__tests__code_gen_tests","snapshot_name":"prog_method_called_locally","metadata":{"source":"src/codegen/tests/code_gen_tests.rs","assertion_line":1339,"expression":"result"},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n\n@foo_instance = global %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %call = call i32 @foo.addToBar(%foo* %0, i16 42)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, i16 %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar = alloca i32, align 4\n  %in = alloca i16, align 2\n  store i16 %1, i16* %in, align 2\n  store i32 0, i32* %foo.addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar, align 4\n  %load_bar1 = load i32, i32* %bar, align 4\n  store i32 %load_bar1, i32* %foo.addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %foo.addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %x = alloca i32, align 4\n  store i32 0, i32* %x, align 4\n  %call = call i32 @foo.addToBar(%foo* @foo_instance, i16 3)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  call void @__init_foo(%foo* @foo_instance)\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\ndeclare void @foo(%foo*)"},"old":{"module_name":"rusty__codegen__tests__code_gen_tests","metadata":{},"snapshot":"; ModuleID = '<internal>'\nsource_filename = \"<internal>\"\n\n%foo = type { i32 }\n%foo.addToBar = type { i16 }\n\n@foo_instance = global %foo { i32 42 }\n\ndefine void @foo(%foo* %0) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %1 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 42, i16* %1, align 2\n  %call = call i32 @foo.addToBar(%foo* %0, %foo.addToBar* %foo.addToBar_instance)\n  ret void\n}\n\ndefine i32 @foo.addToBar(%foo* %0, %foo.addToBar* %1) {\nentry:\n  %bar = getelementptr inbounds %foo, %foo* %0, i32 0, i32 0\n  %in = getelementptr inbounds %foo.addToBar, %foo.addToBar* %1, i32 0, i32 0\n  %addToBar = alloca i32, align 4\n  store i32 0, i32* %addToBar, align 4\n  %load_in = load i16, i16* %in, align 2\n  %2 = sext i16 %load_in to i32\n  %load_bar = load i32, i32* %bar, align 4\n  %tmpVar = add i32 %2, %load_bar\n  store i32 %tmpVar, i32* %bar, align 4\n  %load_bar1 = load i32, i32* %bar, align 4\n  store i32 %load_bar1, i32* %addToBar, align 4\n  %foo.addToBar_ret = load i32, i32* %addToBar, align 4\n  ret i32 %foo.addToBar_ret\n}\n\ndefine void @main() {\nentry:\n  %x = alloca i32, align 4\n  store i32 0, i32* %x, align 4\n  %foo.addToBar_instance = alloca %foo.addToBar, align 8\n  %0 = getelementptr inbounds %foo.addToBar, %foo.addToBar* %foo.addToBar_instance, i32 0, i32 0\n  store i16 3, i16* %0, align 2\n  %call = call i32 @foo.addToBar(%foo* @foo_instance, %foo.addToBar* %foo.addToBar_instance)\n  store i32 %call, i32* %x, align 4\n  ret void\n}\n; ModuleID = '__initializers'\nsource_filename = \"__initializers\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n\ndefine void @__init_foo(%foo* %0) {\nentry:\n  %self = alloca %foo*, align 8\n  store %foo* %0, %foo** %self, align 8\n  ret void\n}\n\ndeclare void @foo(%foo*)\n; ModuleID = '__init___testproject'\nsource_filename = \"__init___testproject\"\n\n%foo = type { i32 }\n\n@foo_instance = external global %foo\n@llvm.global_ctors = appending global [1 x { i32, void ()*, i8* }] [{ i32, void ()*, i8* } { i32 0, void ()* @__init___testproject, i8* null }]\n\ndefine void @__init___testproject() {\nentry:\n  call void @__init_foo(%foo* @foo_instance)\n  ret void\n}\n\ndeclare void @__init_foo(%foo*)\n\ndeclare void @foo(%foo*)"}}
