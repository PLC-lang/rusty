use std::{
    fmt::{Debug, Formatter},
    ops::Range,
};

pub struct SourceRangeFactory {
    file: Option<&'static str>,
}

impl SourceRangeFactory {
    /// constructs a SourceRangeFactory used for internally generated code (e.g. builtins)
    pub fn internal() -> Self {
        SourceRangeFactory { file: None }
    }

    /// constructs a SourceRangeFactory used to construct SourceRanes that point into the given file_name
    pub fn for_file(file_name: &'static str) -> Self {
        SourceRangeFactory { file: Some(file_name) }
    }

    /// creates a new SourceRange using the factory's file_name
    pub fn create_range(&self, range: core::ops::Range<usize>) -> SourceRange {
        SourceRange { range, file: self.file }
    }
}

#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SourceRange {
    /// the start and end offset in the source-file
    range: core::ops::Range<usize>,
    /// the name of the file if available. if there is no file available
    /// the source is probably internally generated by the compiler. (e.g.
    /// a automatically generated data_type)
    file: Option<&'static str>,
}

impl Debug for SourceRange {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("SourceRange");
        f.field("range", &self.range);
        if self.file.is_some() {
            f.field("file", &self.file);
        }
        f.finish()
    }
}

impl SourceRange {
    /// Constructs a new SourceRange with the given range and filename
    pub fn in_file(range: core::ops::Range<usize>, file_name: &'static str) -> SourceRange {
        SourceRange { range, file: Some(file_name) }
    }

    /// Constructs a new SourceRange without the file_name attribute
    pub fn without_file(range: core::ops::Range<usize>) -> SourceRange {
        SourceRange { range, file: None }
    }

    /// Constructs an undefined SourceRange with a 0..0 range and no filename
    pub fn undefined() -> SourceRange {
        SourceRange { range: 0..0, file: None }
    }

    /// returns the start-offset of this source-range
    pub fn get_start(&self) -> usize {
        self.range.start
    }

    /// returns the end-offset of this source-range
    pub fn get_end(&self) -> usize {
        self.range.end
    }

    /// returns a new SourceRange that spans `this` and the `other` range.
    /// In other words this results in `self.start .. other.end`
    pub fn span(&self, other: &SourceRange) -> SourceRange {
        SourceRange { range: self.get_start()..other.get_end(), file: self.get_file_name() }
    }

    /// converts this SourceRange into a Range
    pub fn to_range(&self) -> Range<usize> {
        self.range.clone()
    }

    pub fn get_file_name(&self) -> Option<&'static str> {
        self.file
    }

    /// returns true if this SourceRange points to an undefined location.
    /// see `SourceRange::undefined()`
    pub fn is_undefined(&self) -> bool {
        self.range == (0..0) && self.file.is_none()
    }
}

impl From<std::ops::Range<usize>> for SourceRange {
    fn from(range: std::ops::Range<usize>) -> SourceRange {
        SourceRange::without_file(range)
    }
}
/*
/// Represents the location of a code element in a source code
pub enum ElementLocation {
    IdLocation(usize),
    TextLocation(Range<usize>),
}

pub struct SourceLocation {
    element_location: ElementLocation,
    source_path: Option<&'static str>,
}
*/
