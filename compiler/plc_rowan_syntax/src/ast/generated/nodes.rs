//! Generated by `cargo xtask codegen`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
use std::{fmt, hash};
pub struct Assignment {
    pub(crate) syntax: SyntaxNode,
}
impl Assignment {
    #[inline]
    pub fn target(&self) -> Option<Name> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}
pub struct Body {
    pub(crate) syntax: SyntaxNode,
}
impl Body {
    #[inline]
    pub fn expression_stmts(&self) -> AstChildren<ExpressionStmt> { support::children(&self.syntax) }
}
pub struct CompilationUnit {
    pub(crate) syntax: SyntaxNode,
}
impl CompilationUnit {
    #[inline]
    pub fn pous(&self) -> AstChildren<Pou> { support::children(&self.syntax) }
}
pub struct ConditionThenBlock {
    pub(crate) syntax: SyntaxNode,
}
impl ConditionThenBlock {
    #[inline]
    pub fn body(&self) -> Option<Body> { support::child(&self.syntax) }
    #[inline]
    pub fn condition_expr(&self) -> Option<ExpressionStmt> { support::child(&self.syntax) }
    #[inline]
    pub fn THEN_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![THEN]) }
}
pub struct ElseArm {
    pub(crate) syntax: SyntaxNode,
}
impl ElseArm {
    #[inline]
    pub fn expression_stmt(&self) -> Option<ExpressionStmt> { support::child(&self.syntax) }
    #[inline]
    pub fn ELSE_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ELSE]) }
}
pub struct ElseIfArm {
    pub(crate) syntax: SyntaxNode,
}
impl ElseIfArm {
    #[inline]
    pub fn ELSIF_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ELSIF]) }
}
pub struct ExpressionStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExpressionStmt {
    #[inline]
    pub fn expression(&self) -> Option<Expression> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
pub struct ForStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ForStatement {
    #[inline]
    pub fn counter(&self) -> Option<Assignment> { support::child(&self.syntax) }
    #[inline]
    pub fn step(&self) -> Option<ExpressionStmt> { support::child(&self.syntax) }
    #[inline]
    pub fn BY_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![BY]) }
    #[inline]
    pub fn DO_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![DO]) }
    #[inline]
    pub fn END_FOR_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![END_FOR]) }
    #[inline]
    pub fn FOR_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![FOR]) }
    #[inline]
    pub fn TO_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![TO]) }
}
pub struct IdentifierList {
    pub(crate) syntax: SyntaxNode,
}
impl IdentifierList {
    #[inline]
    pub fn names(&self) -> AstChildren<Name> { support::children(&self.syntax) }
}
pub struct IfStatement {
    pub(crate) syntax: SyntaxNode,
}
impl IfStatement {
    #[inline]
    pub fn else_arm(&self) -> Option<ElseArm> { support::child(&self.syntax) }
    #[inline]
    pub fn else_if_arms(&self) -> AstChildren<ElseIfArm> { support::children(&self.syntax) }
    #[inline]
    pub fn if_condition(&self) -> Option<ConditionThenBlock> { support::child(&self.syntax) }
    #[inline]
    pub fn END_IF_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![END_IF]) }
    #[inline]
    pub fn IF_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![IF]) }
}
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}
pub struct Location {
    pub(crate) syntax: SyntaxNode,
}
impl Location {
    #[inline]
    pub fn AT_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![AT]) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}
pub struct Pou {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Pou {}
impl Pou {
    #[inline]
    pub fn body(&self) -> Option<Body> { support::child(&self.syntax) }
    #[inline]
    pub fn type_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn var_declaration_blocks(&self) -> Option<VarDeclarationBlocks> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn PouEndKeyword_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![PouEndKeyword])
    }
    #[inline]
    pub fn PouStartKeyword_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![PouStartKeyword])
    }
}
pub struct VarDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl VarDeclaration {
    #[inline]
    pub fn identifier_list(&self) -> Option<IdentifierList> { support::child(&self.syntax) }
    #[inline]
    pub fn init_value(&self) -> Option<ExpressionStmt> { support::child(&self.syntax) }
    #[inline]
    pub fn location(&self) -> Option<Location> { support::child(&self.syntax) }
    #[inline]
    pub fn type_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}
pub struct VarDeclarationBlock {
    pub(crate) syntax: SyntaxNode,
}
impl VarDeclarationBlock {
    #[inline]
    pub fn var_declarations(&self) -> AstChildren<VarDeclaration> { support::children(&self.syntax) }
    #[inline]
    pub fn END_VAR_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![END_VAR]) }
    #[inline]
    pub fn VarDeclarationType_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![VarDeclarationType])
    }
}
pub struct VarDeclarationBlocks {
    pub(crate) syntax: SyntaxNode,
}
impl VarDeclarationBlocks {
    #[inline]
    pub fn var_declaration_blocks(&self) -> AstChildren<VarDeclarationBlock> {
        support::children(&self.syntax)
    }
}
pub struct WhileStatement {
    pub(crate) syntax: SyntaxNode,
}
impl WhileStatement {
    #[inline]
    pub fn DO_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![DO]) }
    #[inline]
    pub fn END_WHILE_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![END_WHILE]) }
    #[inline]
    pub fn WHILE_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![WHILE]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expression {
    Assignment(Assignment),
    ForStatement(ForStatement),
    IfStatement(IfStatement),
    Literal(Literal),
    NameRef(NameRef),
    WhileStatement(WhileStatement),
}
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName { AnyHasName { syntax: node.syntax().clone() } }
}
impl AstNode for Assignment {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ASSIGNMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSIGNMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Assignment {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Assignment {}
impl PartialEq for Assignment {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Assignment {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Assignment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Assignment").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Body {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BODY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BODY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Body {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Body {}
impl PartialEq for Body {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Body {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Body {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Body").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for CompilationUnit {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        COMPILATION_UNIT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == COMPILATION_UNIT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for CompilationUnit {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for CompilationUnit {}
impl PartialEq for CompilationUnit {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for CompilationUnit {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for CompilationUnit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("CompilationUnit").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ConditionThenBlock {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONDITION_THEN_BLOCK
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION_THEN_BLOCK }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for ConditionThenBlock {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for ConditionThenBlock {}
impl PartialEq for ConditionThenBlock {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for ConditionThenBlock {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for ConditionThenBlock {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ConditionThenBlock").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseArm {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ELSE_ARM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ELSE_ARM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for ElseArm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for ElseArm {}
impl PartialEq for ElseArm {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for ElseArm {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for ElseArm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseArm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ElseIfArm {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ELSE_IF_ARM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ELSE_IF_ARM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for ElseIfArm {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for ElseIfArm {}
impl PartialEq for ElseIfArm {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for ElseIfArm {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for ElseIfArm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ElseIfArm").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ExpressionStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        EXPRESSION_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPRESSION_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for ExpressionStmt {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for ExpressionStmt {}
impl PartialEq for ExpressionStmt {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for ExpressionStmt {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for ExpressionStmt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExpressionStmt").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for ForStatement {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FOR_STATEMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_STATEMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for ForStatement {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for ForStatement {}
impl PartialEq for ForStatement {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for ForStatement {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for ForStatement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ForStatement").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for IdentifierList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IDENTIFIER_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENTIFIER_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for IdentifierList {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for IdentifierList {}
impl PartialEq for IdentifierList {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for IdentifierList {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for IdentifierList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IdentifierList").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for IfStatement {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IF_STATEMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_STATEMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for IfStatement {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for IfStatement {}
impl PartialEq for IfStatement {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for IfStatement {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for IfStatement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IfStatement").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Literal {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LITERAL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Literal {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Literal {}
impl PartialEq for Literal {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Literal {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Literal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Literal").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Location {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LOCATION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LOCATION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Location {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Location {}
impl PartialEq for Location {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Location {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Location {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Location").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Name {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Name {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Name {}
impl PartialEq for Name {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Name {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Name {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Name").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for NameRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for NameRef {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for NameRef {}
impl PartialEq for NameRef {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for NameRef {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for NameRef {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NameRef").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for Pou {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        POU
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == POU }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for Pou {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for Pou {}
impl PartialEq for Pou {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for Pou {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for Pou {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Pou").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for VarDeclaration {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VAR_DECLARATION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VAR_DECLARATION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for VarDeclaration {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for VarDeclaration {}
impl PartialEq for VarDeclaration {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for VarDeclaration {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for VarDeclaration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VarDeclaration").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for VarDeclarationBlock {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VAR_DECLARATION_BLOCK
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VAR_DECLARATION_BLOCK }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for VarDeclarationBlock {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for VarDeclarationBlock {}
impl PartialEq for VarDeclarationBlock {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for VarDeclarationBlock {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for VarDeclarationBlock {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VarDeclarationBlock").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for VarDeclarationBlocks {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VAR_DECLARATION_BLOCKS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VAR_DECLARATION_BLOCKS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for VarDeclarationBlocks {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for VarDeclarationBlocks {}
impl PartialEq for VarDeclarationBlocks {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for VarDeclarationBlocks {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for VarDeclarationBlocks {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VarDeclarationBlocks").field("syntax", &self.syntax).finish()
    }
}
impl AstNode for WhileStatement {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        WHILE_STATEMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_STATEMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for WhileStatement {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for WhileStatement {}
impl PartialEq for WhileStatement {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for WhileStatement {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for WhileStatement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WhileStatement").field("syntax", &self.syntax).finish()
    }
}
impl From<Assignment> for Expression {
    #[inline]
    fn from(node: Assignment) -> Expression { Expression::Assignment(node) }
}
impl From<ForStatement> for Expression {
    #[inline]
    fn from(node: ForStatement) -> Expression { Expression::ForStatement(node) }
}
impl From<IfStatement> for Expression {
    #[inline]
    fn from(node: IfStatement) -> Expression { Expression::IfStatement(node) }
}
impl From<Literal> for Expression {
    #[inline]
    fn from(node: Literal) -> Expression { Expression::Literal(node) }
}
impl From<NameRef> for Expression {
    #[inline]
    fn from(node: NameRef) -> Expression { Expression::NameRef(node) }
}
impl From<WhileStatement> for Expression {
    #[inline]
    fn from(node: WhileStatement) -> Expression { Expression::WhileStatement(node) }
}
impl AstNode for Expression {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ASSIGNMENT | FOR_STATEMENT | IF_STATEMENT | LITERAL | NAME_REF | WHILE_STATEMENT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ASSIGNMENT => Expression::Assignment(Assignment { syntax }),
            FOR_STATEMENT => Expression::ForStatement(ForStatement { syntax }),
            IF_STATEMENT => Expression::IfStatement(IfStatement { syntax }),
            LITERAL => Expression::Literal(Literal { syntax }),
            NAME_REF => Expression::NameRef(NameRef { syntax }),
            WHILE_STATEMENT => Expression::WhileStatement(WhileStatement { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expression::Assignment(it) => &it.syntax,
            Expression::ForStatement(it) => &it.syntax,
            Expression::IfStatement(it) => &it.syntax,
            Expression::Literal(it) => &it.syntax,
            Expression::NameRef(it) => &it.syntax,
            Expression::WhileStatement(it) => &it.syntax,
        }
    }
}
impl ast::HasName for AnyHasName {}
impl AstNode for AnyHasName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, POU) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl hash::Hash for AnyHasName {
    fn hash<H: hash::Hasher>(&self, state: &mut H) { self.syntax.hash(state); }
}
impl Eq for AnyHasName {}
impl PartialEq for AnyHasName {
    fn eq(&self, other: &Self) -> bool { self.syntax == other.syntax }
}
impl Clone for AnyHasName {
    fn clone(&self) -> Self { Self { syntax: self.syntax.clone() } }
}
impl fmt::Debug for AnyHasName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AnyHasName").field("syntax", &self.syntax).finish()
    }
}
impl From<Pou> for AnyHasName {
    #[inline]
    fn from(node: Pou) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl std::fmt::Display for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Assignment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Body {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompilationUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConditionThenBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseIfArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExpressionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentifierList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pou {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarDeclarationBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarDeclarationBlocks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
