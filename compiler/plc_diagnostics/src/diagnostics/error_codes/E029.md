# E029: Recursive data structure

This error occurs when data structures contain themselves directly or indirectly, creating infinite recursion during type resolution.

## Example

```st
TYPE MyStruct : STRUCT
    value : INT;
    nested : MyStruct;  (* This creates infinite recursion *)
END_STRUCT; END_TYPE
```

In this example, `MyStruct` contains a field of type `MyStruct`, which would require infinite memory to represent.

## Another example - indirect recursion

```st
TYPE StructA : STRUCT
    data : INT;
    ref_b : StructB;
END_STRUCT; END_TYPE

TYPE StructB : STRUCT
    info : STRING;
    ref_a : StructA;  (* Creates a cycle: StructA -> StructB -> StructA *)
END_STRUCT; END_TYPE
```

This shows two structures that reference each other, creating a circular dependency.

## Valid self-referential structures with pointers

Self-referential data structures are allowed when using references or pointers, as these have fixed size:

```st
(* Tree node structure *)
TYPE TreeNode : STRUCT
    value : INT;
    left : REF_TO TreeNode;   (* Pointer to left child *)
    right : REF_TO TreeNode;  (* Pointer to right child *)
END_STRUCT; END_TYPE

(* Linked list node *)
TYPE ListNode : STRUCT
    data : STRING;
    next : REF_TO ListNode;   (* Pointer to next node *)
END_STRUCT; END_TYPE
```

## How to fix

**Use references or pointers for self-referential structures**

Break the infinite recursion by using `REF_TO` for recursive references:

```st
TYPE Node : STRUCT
    value : INT;
    child : REF_TO Node;  (* Use REF_TO instead of direct inclusion *)
END_STRUCT; END_TYPE
```

**Restructure circular dependencies**

For mutually recursive structures, consider using references or redesigning the data structure:

```st
TYPE PersonID : DINT; END_TYPE

TYPE Person : STRUCT
    name : STRING;
    manager_id : PersonID;    (* Reference by ID instead of direct inclusion *)
    reports : ARRAY[0..9] OF PersonID;
END_STRUCT; END_TYPE
```
