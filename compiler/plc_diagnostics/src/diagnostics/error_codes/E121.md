# E121: Recursive type alias

This error occurs when type aliases reference each other in a cycle, creating an infinite recursion.

## Example

```st
TYPE type1 : type2; END_TYPE
TYPE type2 : type1; END_TYPE
```

In this example, `type1` is defined as `type2`, which is in turn defined as `type1`, creating a circular dependency.

## Another example

```st
TYPE self_type : self_type; END_TYPE
```

This shows a type alias that directly references itself.

## How to fix

**Option 1: Break the chain by resolving to concrete types**

Break the circular dependency by ensuring that type aliases eventually resolve to concrete types:

```st
TYPE type1 : DINT; END_TYPE      (* Points to concrete type *)
TYPE type2 : type1; END_TYPE     (* Points to another alias, but ultimately resolves to DINT *)
```

**Option 2: Use references to maintain relationships**

If you need to keep the relationship between types, use a reference instead of direct aliasing:

```st
```st
TYPE type1 : DINT; END_TYPE                  (* Base type *)
TYPE type2 : REFERENCE TO type1; END_TYPE   (* Reference to type1, avoiding recursion *)
```
