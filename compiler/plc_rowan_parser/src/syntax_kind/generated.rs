//! Generated by `cargo xtask codegen`, do not edit by hand.

#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    DOLLAR,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    AT,
    POUND,
    TILDE,
    QUESTION,
    AMP,
    PIPE,
    PLUS,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    UNDERSCORE,
    DOT,
    DOT2,
    DOT3,
    DOT2EQ,
    COLON,
    COLON2,
    ASSIGN,
    EQ,
    EQ2,
    FAT_ARROW,
    BANG,
    NEQ,
    MINUS,
    THIN_ARROW,
    LTEQ,
    GTEQ,
    PLUSEQ,
    MINUSEQ,
    PIPEEQ,
    AMPEQ,
    CARETEQ,
    SLASHEQ,
    STAREQ,
    PERCENTEQ,
    AMP2,
    PIPE2,
    SHL,
    SHR,
    SHLEQ,
    SHREQ,
    DO_KW,
    ELSE_KW,
    ELSIF_KW,
    END_IF_KW,
    END_VAR_KW,
    END_WHILE_KW,
    IF_KW,
    THEN_KW,
    WHILE_KW,
    X_X_X__VAR_DECLARATION_TYPE_KW,
    ____POU_END_KW,
    ____POU_TYPE_KW,
    AT_KW,
    CONSTANT_KW,
    NON_RETAIN_KW,
    RETAIN_KW,
    BOOL_LITERAL,
    INT_NUMBER,
    REAL_NUMBER,
    STRING_LITERAL,
    COMMENT,
    ERROR,
    IDENT,
    NEWLINE,
    WHITESPACE,
    ASSIGNMENT,
    BODY,
    COMPILATION_UNIT,
    CONDITION_THEN_BLOCK,
    ELSE_ARM,
    ELSE_IF_ARM,
    EXPRESSION,
    IDENTIFIER_LIST,
    IF_STATEMENT,
    LITERAL,
    LOCATION,
    NAME,
    NAME_REF,
    POU,
    POU_END_KEYWORD,
    POU_TYPE,
    VAR_DECLARATION,
    VAR_DECLARATION_BLOCK,
    VAR_DECLARATION_BLOCKS,
    VAR_DECLARATION_TYPE,
    WHILE_STATEMENT,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    #[allow(unreachable_patterns)]
    pub const fn text(self) -> &'static str {
        match self {
            TOMBSTONE
            | EOF
            | __LAST
            | BOOL_LITERAL
            | INT_NUMBER
            | REAL_NUMBER
            | STRING_LITERAL
            | ASSIGNMENT
            | BODY
            | COMPILATION_UNIT
            | CONDITION_THEN_BLOCK
            | ELSE_ARM
            | ELSE_IF_ARM
            | EXPRESSION
            | IDENTIFIER_LIST
            | IF_STATEMENT
            | LITERAL
            | LOCATION
            | NAME
            | NAME_REF
            | POU
            | POU_END_KEYWORD
            | POU_TYPE
            | VAR_DECLARATION
            | VAR_DECLARATION_BLOCK
            | VAR_DECLARATION_BLOCKS
            | VAR_DECLARATION_TYPE
            | WHILE_STATEMENT
            | COMMENT
            | ERROR
            | IDENT
            | NEWLINE
            | WHITESPACE => panic!("no text for these `SyntaxKind`s"),
            DOLLAR => "$",
            SEMICOLON => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            AT => "@",
            POUND => "#",
            TILDE => "~",
            QUESTION => "?",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            UNDERSCORE => "_",
            DOT => ".",
            DOT2 => "..",
            DOT3 => "...",
            DOT2EQ => "..=",
            COLON => ":",
            COLON2 => "::",
            ASSIGN => ":=",
            EQ => "=",
            EQ2 => "==",
            FAT_ARROW => "=>",
            BANG => "!",
            NEQ => "!=",
            MINUS => "-",
            THIN_ARROW => "->",
            LTEQ => "<=",
            GTEQ => ">=",
            PLUSEQ => "+=",
            MINUSEQ => "-=",
            PIPEEQ => "|=",
            AMPEQ => "&=",
            CARETEQ => "^=",
            SLASHEQ => "/=",
            STAREQ => "*=",
            PERCENTEQ => "%=",
            AMP2 => "&&",
            PIPE2 => "||",
            SHL => "<<",
            SHR => ">>",
            SHLEQ => "<<=",
            SHREQ => ">>=",
            DO_KW => "DO",
            ELSE_KW => "ELSE",
            ELSIF_KW => "ELSIF",
            END_IF_KW => "END_IF",
            END_VAR_KW => "END_VAR",
            END_WHILE_KW => "END_WHILE",
            IF_KW => "IF",
            THEN_KW => "THEN",
            WHILE_KW => "WHILE",
            X_X_X__VAR_DECLARATION_TYPE_KW => "XXX_VarDeclarationType",
            ____POU_END_KW => "___PouEnd",
            ____POU_TYPE_KW => "___PouType",
            AT_KW => "AT",
            CONSTANT_KW => "CONSTANT",
            NON_RETAIN_KW => "NON_RETAIN",
            RETAIN_KW => "RETAIN",
        }
    }
    #[doc = r" Checks whether this syntax kind is a strict keyword for the given edition."]
    #[doc = r" Strict keywords are identifiers that are always considered keywords."]
    pub fn is_strict_keyword(self) -> bool {
        matches!(
            self,
            DO_KW
                | ELSE_KW
                | ELSIF_KW
                | END_IF_KW
                | END_VAR_KW
                | END_WHILE_KW
                | IF_KW
                | THEN_KW
                | WHILE_KW
                | X_X_X__VAR_DECLARATION_TYPE_KW
                | ____POU_END_KW
                | ____POU_TYPE_KW
        ) || match self {
            _ => false,
        }
    }
    #[doc = r" Checks whether this syntax kind is a weak keyword for the given edition."]
    #[doc = r" Weak keywords are identifiers that are considered keywords only in certain contexts."]
    pub fn is_contextual_keyword(self) -> bool {
        match self {
            AT_KW => true,
            CONSTANT_KW => true,
            NON_RETAIN_KW => true,
            RETAIN_KW => true,
            _ => false,
        }
    }
    #[doc = r" Checks whether this syntax kind is a strict or weak keyword for the given edition."]
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            DO_KW
                | ELSE_KW
                | ELSIF_KW
                | END_IF_KW
                | END_VAR_KW
                | END_WHILE_KW
                | IF_KW
                | THEN_KW
                | WHILE_KW
                | X_X_X__VAR_DECLARATION_TYPE_KW
                | ____POU_END_KW
                | ____POU_TYPE_KW
        ) || match self {
            AT_KW => true,
            CONSTANT_KW => true,
            NON_RETAIN_KW => true,
            RETAIN_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            DOLLAR
                | SEMICOLON
                | COMMA
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACK
                | R_BRACK
                | L_ANGLE
                | R_ANGLE
                | AT
                | POUND
                | TILDE
                | QUESTION
                | AMP
                | PIPE
                | PLUS
                | STAR
                | SLASH
                | CARET
                | PERCENT
                | UNDERSCORE
                | DOT
                | DOT2
                | DOT3
                | DOT2EQ
                | COLON
                | COLON2
                | ASSIGN
                | EQ
                | EQ2
                | FAT_ARROW
                | BANG
                | NEQ
                | MINUS
                | THIN_ARROW
                | LTEQ
                | GTEQ
                | PLUSEQ
                | MINUSEQ
                | PIPEEQ
                | AMPEQ
                | CARETEQ
                | SLASHEQ
                | STAREQ
                | PERCENTEQ
                | AMP2
                | PIPE2
                | SHL
                | SHR
                | SHLEQ
                | SHREQ
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(self, BOOL_LITERAL | INT_NUMBER | REAL_NUMBER | STRING_LITERAL)
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "DO" => DO_KW,
            "ELSE" => ELSE_KW,
            "ELSIF" => ELSIF_KW,
            "END_IF" => END_IF_KW,
            "END_VAR" => END_VAR_KW,
            "END_WHILE" => END_WHILE_KW,
            "IF" => IF_KW,
            "THEN" => THEN_KW,
            "WHILE" => WHILE_KW,
            "XXX_VarDeclarationType" => X_X_X__VAR_DECLARATION_TYPE_KW,
            "___PouEnd" => ____POU_END_KW,
            "___PouType" => ____POU_TYPE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "AT" => AT_KW,
            "CONSTANT" => CONSTANT_KW,
            "NON_RETAIN" => NON_RETAIN_KW,
            "RETAIN" => RETAIN_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '$' => DOLLAR,
            ';' => SEMICOLON,
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '<' => L_ANGLE,
            '>' => R_ANGLE,
            '@' => AT,
            '#' => POUND,
            '~' => TILDE,
            '?' => QUESTION,
            '&' => AMP,
            '|' => PIPE,
            '+' => PLUS,
            '*' => STAR,
            '/' => SLASH,
            '^' => CARET,
            '%' => PERCENT,
            '_' => UNDERSCORE,
            '.' => DOT,
            ':' => COLON,
            '=' => EQ,
            '!' => BANG,
            '-' => MINUS,
            _ => return None,
        };
        Some(tok)
    }
}
#[doc = r" `T![]`"]
#[macro_export]
macro_rules ! T_ {
    [$] => { $ crate :: SyntaxKind :: DOLLAR };
    [;] => { $ crate :: SyntaxKind :: SEMICOLON };
    [,] => { $ crate :: SyntaxKind :: COMMA };
    ['('] => { $ crate :: SyntaxKind :: L_PAREN };
    [')'] => { $ crate :: SyntaxKind :: R_PAREN };
    ['{'] => { $ crate :: SyntaxKind :: L_CURLY };
    ['}'] => { $ crate :: SyntaxKind :: R_CURLY };
    ['['] => { $ crate :: SyntaxKind :: L_BRACK };
    [']'] => { $ crate :: SyntaxKind :: R_BRACK };
    [<] => { $ crate :: SyntaxKind :: L_ANGLE };
    [>] => { $ crate :: SyntaxKind :: R_ANGLE };
    [@] => { $ crate :: SyntaxKind :: AT };
    [#] => { $ crate :: SyntaxKind :: POUND };
    [~] => { $ crate :: SyntaxKind :: TILDE };
    [?] => { $ crate :: SyntaxKind :: QUESTION };
    [&] => { $ crate :: SyntaxKind :: AMP };
    [|] => { $ crate :: SyntaxKind :: PIPE };
    [+] => { $ crate :: SyntaxKind :: PLUS };
    [*] => { $ crate :: SyntaxKind :: STAR };
    [/] => { $ crate :: SyntaxKind :: SLASH };
    [^] => { $ crate :: SyntaxKind :: CARET };
    [%] => { $ crate :: SyntaxKind :: PERCENT };
    [_] => { $ crate :: SyntaxKind :: UNDERSCORE };
    [.] => { $ crate :: SyntaxKind :: DOT };
    [..] => { $ crate :: SyntaxKind :: DOT2 };
    [...] => { $ crate :: SyntaxKind :: DOT3 };
    [..=] => { $ crate :: SyntaxKind :: DOT2EQ };
    [:] => { $ crate :: SyntaxKind :: COLON };
    [::] => { $ crate :: SyntaxKind :: COLON2 };
    [:=] => { $ crate :: SyntaxKind :: ASSIGN };
    [=] => { $ crate :: SyntaxKind :: EQ };
    [==] => { $ crate :: SyntaxKind :: EQ2 };
    [=>] => { $ crate :: SyntaxKind :: FAT_ARROW };
    [!] => { $ crate :: SyntaxKind :: BANG };
    [!=] => { $ crate :: SyntaxKind :: NEQ };
    [-] => { $ crate :: SyntaxKind :: MINUS };
    [->] => { $ crate :: SyntaxKind :: THIN_ARROW };
    [<=] => { $ crate :: SyntaxKind :: LTEQ };
    [>=] => { $ crate :: SyntaxKind :: GTEQ };
    [+=] => { $ crate :: SyntaxKind :: PLUSEQ };
    [-=] => { $ crate :: SyntaxKind :: MINUSEQ };
    [|=] => { $ crate :: SyntaxKind :: PIPEEQ };
    [&=] => { $ crate :: SyntaxKind :: AMPEQ };
    [^=] => { $ crate :: SyntaxKind :: CARETEQ };
    [/=] => { $ crate :: SyntaxKind :: SLASHEQ };
    [*=] => { $ crate :: SyntaxKind :: STAREQ };
    [%=] => { $ crate :: SyntaxKind :: PERCENTEQ };
    [&&] => { $ crate :: SyntaxKind :: AMP2 };
    [||] => { $ crate :: SyntaxKind :: PIPE2 };
    [<<] => { $ crate :: SyntaxKind :: SHL };
    [>>] => { $ crate :: SyntaxKind :: SHR };
    [<<=] => { $ crate :: SyntaxKind :: SHLEQ };
    [>>=] => { $ crate :: SyntaxKind :: SHREQ };
    [DO] => { $ crate :: SyntaxKind :: DO_KW };
    [ELSE] => { $ crate :: SyntaxKind :: ELSE_KW };
    [ELSIF] => { $ crate :: SyntaxKind :: ELSIF_KW };
    [END_IF] => { $ crate :: SyntaxKind :: END_IF_KW };
    [END_VAR] => { $ crate :: SyntaxKind :: END_VAR_KW };
    [END_WHILE] => { $ crate :: SyntaxKind :: END_WHILE_KW };
    [IF] => { $ crate :: SyntaxKind :: IF_KW };
    [THEN] => { $ crate :: SyntaxKind :: THEN_KW };
    [WHILE] => { $ crate :: SyntaxKind :: WHILE_KW };
    [XXX_VarDeclarationType] => { $ crate :: SyntaxKind :: X_X_X__VAR_DECLARATION_TYPE_KW };
    [___PouEnd] => { $ crate :: SyntaxKind :: ____POU_END_KW };
    [___PouType] => { $ crate :: SyntaxKind :: ____POU_TYPE_KW };
    [AT] => { $ crate :: SyntaxKind :: AT_KW };
    [CONSTANT] => { $ crate :: SyntaxKind :: CONSTANT_KW };
    [NON_RETAIN] => { $ crate :: SyntaxKind :: NON_RETAIN_KW };
    [RETAIN] => { $ crate :: SyntaxKind :: RETAIN_KW };
    [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT };
    [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER };
    [ident] => { $ crate :: SyntaxKind :: IDENT };
    [string] => { $ crate :: SyntaxKind :: STRING };
    [shebang] => { $ crate :: SyntaxKind :: SHEBANG };
    [frontmatter] => { $ crate :: SyntaxKind :: FRONTMATTER };
}

impl ::core::marker::Copy for SyntaxKind {}
impl ::core::clone::Clone for SyntaxKind {
    #[inline]
    fn clone(&self) -> Self { *self }
}
impl ::core::cmp::PartialEq for SyntaxKind {
    #[inline]
    fn eq(&self, other: &Self) -> bool { (*self as u16) == (*other as u16) }
}
impl ::core::cmp::Eq for SyntaxKind {}
impl ::core::cmp::PartialOrd for SyntaxKind {
    #[inline]
    fn partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering> { Some(self.cmp(other)) }
}
impl ::core::cmp::Ord for SyntaxKind {
    #[inline]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering { (*self as u16).cmp(&(*other as u16)) }
}
impl ::core::hash::Hash for SyntaxKind {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) { ::core::mem::discriminant(self).hash(state); }
}
