<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A manager for running optimization and simplification passes. Much of the documenation for specific passes is directly from the LLVM documentation."><title>PassManager in inkwell::passes - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="inkwell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../inkwell/index.html">inkwell</a><span class="version">0.2.0</span></h2></div><h2 class="location"><a href="#">PassManager</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_aggressive_dce_pass">add_aggressive_dce_pass</a></li><li><a href="#method.add_aggressive_inst_combiner_pass">add_aggressive_inst_combiner_pass</a></li><li><a href="#method.add_alignment_from_assumptions_pass">add_alignment_from_assumptions_pass</a></li><li><a href="#method.add_always_inliner_pass">add_always_inliner_pass</a></li><li><a href="#method.add_argument_promotion_pass">add_argument_promotion_pass</a></li><li><a href="#method.add_basic_alias_analysis_pass">add_basic_alias_analysis_pass</a></li><li><a href="#method.add_bit_tracking_dce_pass">add_bit_tracking_dce_pass</a></li><li><a href="#method.add_cfg_simplification_pass">add_cfg_simplification_pass</a></li><li><a href="#method.add_constant_merge_pass">add_constant_merge_pass</a></li><li><a href="#method.add_coroutine_cleanup_pass">add_coroutine_cleanup_pass</a></li><li><a href="#method.add_coroutine_early_pass">add_coroutine_early_pass</a></li><li><a href="#method.add_coroutine_elide_pass">add_coroutine_elide_pass</a></li><li><a href="#method.add_coroutine_split_pass">add_coroutine_split_pass</a></li><li><a href="#method.add_correlated_value_propagation_pass">add_correlated_value_propagation_pass</a></li><li><a href="#method.add_dead_arg_elimination_pass">add_dead_arg_elimination_pass</a></li><li><a href="#method.add_dead_store_elimination_pass">add_dead_store_elimination_pass</a></li><li><a href="#method.add_demote_memory_to_register_pass">add_demote_memory_to_register_pass</a></li><li><a href="#method.add_early_cse_mem_ssa_pass">add_early_cse_mem_ssa_pass</a></li><li><a href="#method.add_early_cse_pass">add_early_cse_pass</a></li><li><a href="#method.add_function_attrs_pass">add_function_attrs_pass</a></li><li><a href="#method.add_function_inlining_pass">add_function_inlining_pass</a></li><li><a href="#method.add_global_dce_pass">add_global_dce_pass</a></li><li><a href="#method.add_global_optimizer_pass">add_global_optimizer_pass</a></li><li><a href="#method.add_gvn_pass">add_gvn_pass</a></li><li><a href="#method.add_ind_var_simplify_pass">add_ind_var_simplify_pass</a></li><li><a href="#method.add_instruction_combining_pass">add_instruction_combining_pass</a></li><li><a href="#method.add_instruction_simplify_pass">add_instruction_simplify_pass</a></li><li><a href="#method.add_internalize_pass">add_internalize_pass</a></li><li><a href="#method.add_ipsccp_pass">add_ipsccp_pass</a></li><li><a href="#method.add_jump_threading_pass">add_jump_threading_pass</a></li><li><a href="#method.add_licm_pass">add_licm_pass</a></li><li><a href="#method.add_loop_deletion_pass">add_loop_deletion_pass</a></li><li><a href="#method.add_loop_idiom_pass">add_loop_idiom_pass</a></li><li><a href="#method.add_loop_reroll_pass">add_loop_reroll_pass</a></li><li><a href="#method.add_loop_rotate_pass">add_loop_rotate_pass</a></li><li><a href="#method.add_loop_unroll_and_jam_pass">add_loop_unroll_and_jam_pass</a></li><li><a href="#method.add_loop_unroll_pass">add_loop_unroll_pass</a></li><li><a href="#method.add_loop_unswitch_pass">add_loop_unswitch_pass</a></li><li><a href="#method.add_loop_vectorize_pass">add_loop_vectorize_pass</a></li><li><a href="#method.add_lower_expect_intrinsic_pass">add_lower_expect_intrinsic_pass</a></li><li><a href="#method.add_lower_switch_pass">add_lower_switch_pass</a></li><li><a href="#method.add_memcpy_optimize_pass">add_memcpy_optimize_pass</a></li><li><a href="#method.add_merge_functions_pass">add_merge_functions_pass</a></li><li><a href="#method.add_merged_load_store_motion_pass">add_merged_load_store_motion_pass</a></li><li><a href="#method.add_new_gvn_pass">add_new_gvn_pass</a></li><li><a href="#method.add_partially_inline_lib_calls_pass">add_partially_inline_lib_calls_pass</a></li><li><a href="#method.add_promote_memory_to_register_pass">add_promote_memory_to_register_pass</a></li><li><a href="#method.add_prune_eh_pass">add_prune_eh_pass</a></li><li><a href="#method.add_reassociate_pass">add_reassociate_pass</a></li><li><a href="#method.add_scalar_repl_aggregates_pass">add_scalar_repl_aggregates_pass</a></li><li><a href="#method.add_scalar_repl_aggregates_pass_ssa">add_scalar_repl_aggregates_pass_ssa</a></li><li><a href="#method.add_scalar_repl_aggregates_pass_with_threshold">add_scalar_repl_aggregates_pass_with_threshold</a></li><li><a href="#method.add_scalarizer_pass">add_scalarizer_pass</a></li><li><a href="#method.add_sccp_pass">add_sccp_pass</a></li><li><a href="#method.add_scoped_no_alias_aa_pass">add_scoped_no_alias_aa_pass</a></li><li><a href="#method.add_simplify_lib_calls_pass">add_simplify_lib_calls_pass</a></li><li><a href="#method.add_slp_vectorize_pass">add_slp_vectorize_pass</a></li><li><a href="#method.add_strip_dead_prototypes_pass">add_strip_dead_prototypes_pass</a></li><li><a href="#method.add_strip_symbol_pass">add_strip_symbol_pass</a></li><li><a href="#method.add_tail_call_elimination_pass">add_tail_call_elimination_pass</a></li><li><a href="#method.add_type_based_alias_analysis_pass">add_type_based_alias_analysis_pass</a></li><li><a href="#method.add_verifier_pass">add_verifier_pass</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.create">create</a></li><li><a href="#method.finalize">finalize</a></li><li><a href="#method.initialize">initialize</a></li><li><a href="#method.new">new</a></li><li><a href="#method.run_on">run_on</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-PassManager%3CT%3E">Debug</a></li><li><a href="#impl-Drop-for-PassManager%3CT%3E">Drop</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Send-for-PassManager%3CT%3E">!Send</a></li><li><a href="#impl-Sync-for-PassManager%3CT%3E">!Sync</a></li><li><a href="#impl-Freeze-for-PassManager%3CT%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-PassManager%3CT%3E">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-PassManager%3CT%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PassManager%3CT%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-IntoEither-for-T">IntoEither</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In inkwell::passes</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">inkwell</a>::<wbr><a href="index.html">passes</a>::<wbr><a class="struct" href="#">PassManager</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/inkwell/passes.rs.html#254-257">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct PassManager&lt;T&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A manager for running optimization and simplification passes. Much of the
documenation for specific passes is directly from the <a href="https://llvm.org/docs/Passes.html">LLVM
documentation</a>.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-PassManager%3CFunctionValue%3C'_%3E%3E" class="impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#259-273">source</a><a href="#impl-PassManager%3CFunctionValue%3C'_%3E%3E" class="anchor">Â§</a><h3 class="code-header">impl <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;<a class="struct" href="../values/struct.FunctionValue.html" title="struct inkwell::values::FunctionValue">FunctionValue</a>&lt;'_&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#261-263">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;self) -&gt; <a class="type" href="../../llvm_sys/prelude/type.LLVMPassManagerRef.html" title="type llvm_sys::prelude::LLVMPassManagerRef">LLVMPassManagerRef</a></h4></section></summary><div class="docblock"><p>Acquires the underlying raw pointer belonging to this <code>PassManager&lt;T&gt;</code> type.</p>
</div></details><section id="method.initialize" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#266-268">source</a><h4 class="code-header">pub fn <a href="#method.initialize" class="fn">initialize</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section><section id="method.finalize" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#270-272">source</a><h4 class="code-header">pub fn <a href="#method.finalize" class="fn">finalize</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PassManager%3CT%3E" class="impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#275-1057">source</a><a href="#impl-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.PassManagerSubType.html" title="trait inkwell::passes::PassManagerSubType">PassManagerSubType</a>&gt; <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><section id="method.new" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#276-283">source</a><h4 class="code-header">pub unsafe fn <a href="#method.new" class="fn">new</a>(pass_manager: <a class="type" href="../../llvm_sys/prelude/type.LLVMPassManagerRef.html" title="type llvm_sys::prelude::LLVMPassManagerRef">LLVMPassManagerRef</a>) -&gt; Self</h4></section><section id="method.create" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#285-289">source</a><h4 class="code-header">pub fn <a href="#method.create" class="fn">create</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T::<a class="associatedtype" href="trait.PassManagerSubType.html#associatedtype.Input" title="type inkwell::passes::PassManagerSubType::Input">Input</a>&gt;&gt;(input: I) -&gt; <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.run_on" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#293-295">source</a><h4 class="code-header">pub fn <a href="#method.run_on" class="fn">run_on</a>(&amp;self, input: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>This method returns true if any of the passes modified the function or module
and false otherwise.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_argument_promotion_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#316-320">source</a><h4 class="code-header">pub fn <a href="#method.add_argument_promotion_pass" class="fn">add_argument_promotion_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass promotes âby referenceâ arguments to be âby valueâ arguments.
In practice, this means looking for internal functions that have pointer
arguments. If it can prove, through the use of alias analysis, that an
argument is only loaded, then it can pass the value into the function
instead of the address of the value. This can cause recursive simplification
of code and lead to the elimination of allocas (especially in C++ template
code like the STL).</p>
<p>This pass also handles aggregate arguments that are passed into a function,
scalarizing them if the elements of the aggregate are only loaded. Note that
it refuses to scalarize aggregates which would require passing in more than
three operands to the function, because passing thousands of operands for a
large array or structure is unprofitable!</p>
<p>Note that this transformation could also be done for arguments that are
only stored to (returning the value instead), but does not currently.
This case would be best handled when and if LLVM starts supporting multiple
return values from functions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_constant_merge_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#326-328">source</a><h4 class="code-header">pub fn <a href="#method.add_constant_merge_pass" class="fn">add_constant_merge_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Merges duplicate global constants together into a single constant that is
shared. This is useful because some passes (i.e., TraceValues) insert a lot
of string constants into the program, regardless of whether or not an existing
string is available.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_merge_functions_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#332-334">source</a><h4 class="code-header">pub fn <a href="#method.add_merge_functions_pass" class="fn">add_merge_functions_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Discovers identical functions and collapses them.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_dead_arg_elimination_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#343-345">source</a><h4 class="code-header">pub fn <a href="#method.add_dead_arg_elimination_pass" class="fn">add_dead_arg_elimination_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass deletes dead arguments from internal functions. Dead argument
elimination removes arguments which are directly dead, as well as arguments
only passed into function calls as dead arguments of other functions. This
pass also deletes dead arguments in a similar way.</p>
<p>This pass is often useful as a cleanup pass to run after aggressive
interprocedural passes, which add possibly-dead arguments.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_function_attrs_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#355-357">source</a><h4 class="code-header">pub fn <a href="#method.add_function_attrs_pass" class="fn">add_function_attrs_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>A simple interprocedural pass which walks the call-graph, looking for
functions which do not access or only read non-local memory, and marking
them readnone/readonly. In addition, it marks function arguments (of
pointer type) ânocaptureâ if a call to the function does not create
any copies of the pointer value that outlive the call. This more or
less means that the pointer is only dereferenced, and not returned
from the function or stored in a global. This pass is implemented
as a bottom-up traversal of the call-graph.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_function_inlining_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#360-362">source</a><h4 class="code-header">pub fn <a href="#method.add_function_inlining_pass" class="fn">add_function_inlining_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Bottom-up inlining of functions into callees.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_always_inliner_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#365-367">source</a><h4 class="code-header">pub fn <a href="#method.add_always_inliner_pass" class="fn">add_always_inliner_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>A custom inliner that handles only functions that are marked as âalways inlineâ.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_global_dce_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#375-377">source</a><h4 class="code-header">pub fn <a href="#method.add_global_dce_pass" class="fn">add_global_dce_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This transform is designed to eliminate unreachable internal
globals from the program. It uses an aggressive algorithm,
searching out globals that are known to be alive. After it
finds all of the globals which are needed, it deletes
whatever is left over. This allows it to delete recursive
chunks of the program which are unreachable.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_global_optimizer_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#382-384">source</a><h4 class="code-header">pub fn <a href="#method.add_global_optimizer_pass" class="fn">add_global_optimizer_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass transforms simple global variables that never have
their address taken. If obviously true, it marks read/write
globals as constant, deletes variables only stored to, etc.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_prune_eh_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#406-408">source</a><h4 class="code-header">pub fn <a href="#method.add_prune_eh_pass" class="fn">add_prune_eh_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This file implements a simple interprocedural pass which
walks the call-graph, turning invoke instructions into
call instructions if and only if the callee cannot throw
an exception. It implements this as a bottom-up traversal
of the call-graph.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_ipsccp_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#412-414">source</a><h4 class="code-header">pub fn <a href="#method.add_ipsccp_pass" class="fn">add_ipsccp_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>An interprocedural variant of <a href="https://llvm.org/docs/Passes.html#passes-sccp">Sparse Conditional Constant
Propagation</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_internalize_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#420-422">source</a><h4 class="code-header">pub fn <a href="#method.add_internalize_pass" class="fn">add_internalize_pass</a>(&amp;self, all_but_main: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>This pass loops over all of the functions in the input module,
looking for a main function. If a main function is found, all
other functions and all global variables with initializers are
marked as internal.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_strip_dead_prototypes_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#428-430">source</a><h4 class="code-header">pub fn <a href="#method.add_strip_dead_prototypes_pass" class="fn">add_strip_dead_prototypes_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass loops over all of the functions in the input module,
looking for dead declarations and removes them. Dead declarations
are declarations of functions for which no implementation is available
(i.e., declarations for unused library functions).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_strip_symbol_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#442-444">source</a><h4 class="code-header">pub fn <a href="#method.add_strip_symbol_pass" class="fn">add_strip_symbol_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Performs code stripping. This transformation can delete:</p>
<ul>
<li>Names for virtual registers</li>
<li>Symbols for internal globals and functions</li>
<li>Debug information</li>
</ul>
<p>Note that this transformation makes code much less readable,
so it should only be used in situations where the strip utility
would be used, such as reducing code size or making it harder
to reverse engineer code.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_vectorize_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#467-469">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_vectorize_pass" class="fn">add_loop_vectorize_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_slp_vectorize_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#472-474">source</a><h4 class="code-header">pub fn <a href="#method.add_slp_vectorize_pass" class="fn">add_slp_vectorize_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_aggressive_dce_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#481-483">source</a><h4 class="code-header">pub fn <a href="#method.add_aggressive_dce_pass" class="fn">add_aggressive_dce_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>ADCE aggressively tries to eliminate code. This pass is similar
to <a href="https://llvm.org/docs/Passes.html#passes-dce">DCE</a> but it
assumes that values are dead until proven otherwise. This is
similar to <a href="https://llvm.org/docs/Passes.html#passes-sccp">SCCP</a>,
except applied to the liveness of values.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_bit_tracking_dce_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#486-488">source</a><h4 class="code-header">pub fn <a href="#method.add_bit_tracking_dce_pass" class="fn">add_bit_tracking_dce_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_alignment_from_assumptions_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#491-493">source</a><h4 class="code-header">pub fn <a href="#method.add_alignment_from_assumptions_pass" class="fn">add_alignment_from_assumptions_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_cfg_simplification_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#501-503">source</a><h4 class="code-header">pub fn <a href="#method.add_cfg_simplification_pass" class="fn">add_cfg_simplification_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Performs dead code elimination and basic block merging. Specifically:</p>
<ul>
<li>Removes basic blocks with no predecessors.</li>
<li>Merges a basic block into its predecessor if there is only one and the predecessor only has one successor.</li>
<li>Eliminates PHI nodes for basic blocks with a single predecessor.</li>
<li>Eliminates a basic block that only contains an unconditional branch.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_dead_store_elimination_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#506-508">source</a><h4 class="code-header">pub fn <a href="#method.add_dead_store_elimination_pass" class="fn">add_dead_store_elimination_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>A trivial dead store elimination that only considers basic-block local redundant stores.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_scalarizer_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#511-513">source</a><h4 class="code-header">pub fn <a href="#method.add_scalarizer_pass" class="fn">add_scalarizer_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_merged_load_store_motion_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#516-518">source</a><h4 class="code-header">pub fn <a href="#method.add_merged_load_store_motion_pass" class="fn">add_merged_load_store_motion_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_gvn_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#523-525">source</a><h4 class="code-header">pub fn <a href="#method.add_gvn_pass" class="fn">add_gvn_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass performs global value numbering to eliminate
fully and partially redundant instructions. It also
performs redundant load elimination.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_new_gvn_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#533-537">source</a><h4 class="code-header">pub fn <a href="#method.add_new_gvn_pass" class="fn">add_new_gvn_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass performs global value numbering to eliminate
fully and partially redundant instructions. It also
performs redundant load elimination.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_ind_var_simplify_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#578-580">source</a><h4 class="code-header">pub fn <a href="#method.add_ind_var_simplify_pass" class="fn">add_ind_var_simplify_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This transformation analyzes and transforms the induction variables (and
computations derived from them) into simpler forms suitable for subsequent
analysis and transformation.</p>
<p>This transformation makes the following changes to each loop with an
identifiable induction variable:</p>
<ul>
<li>
<p>All loops are transformed to have a single canonical induction variable
which starts at zero and steps by one.</p>
</li>
<li>
<p>The canonical induction variable is guaranteed to be the first PHI node
in the loop header block.</p>
</li>
<li>
<p>Any pointer arithmetic recurrences are raised to use array subscripts.</p>
</li>
</ul>
<p>If the trip count of a loop is computable, this pass also makes the
following changes:</p>
<ul>
<li>The exit condition for the loop is canonicalized to compare the induction
value against the exit value. This turns loops like:</li>
</ul>
<div class="example-wrap"><pre class="language-c"><code>for (i = 7; i*i &lt; 1000; ++i)
</code></pre></div>
<p>into</p>
<div class="example-wrap"><pre class="language-c"><code>for (i = 0; i != 25; ++i)
</code></pre></div>
<ul>
<li>Any use outside of the loop of an expression derived from the indvar is
changed to compute the derived value outside of the loop, eliminating the
dependence on the exit value of the induction variable. If the only purpose
of the loop is to compute the exit value of some derived expression, this
transformation will make the loop dead.</li>
</ul>
<p>This transformation should be followed by strength reduction after all of
the desired loop transformations have been performed. Additionally, on
targets where it is profitable, the loop could be transformed to count
down to zero (the âdo loopâ optimization).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_instruction_combining_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#622-624">source</a><h4 class="code-header">pub fn <a href="#method.add_instruction_combining_pass" class="fn">add_instruction_combining_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Combine instructions to form fewer, simple instructions. This pass
does not modify the CFG. This pass is where algebraic simplification happens.</p>
<p>This pass combines things like:</p>
<div class="example-wrap"><pre class="language-c"><code>%Y = add i32 %X, 1
%Z = add i32 %Y, 1
</code></pre></div>
<p>into:</p>
<div class="example-wrap"><pre class="language-c"><code>%Z = add i32 %X, 2
</code></pre></div>
<p>This is a simple worklist driven algorithm.</p>
<p>This pass guarantees that the following canonicalizations are performed
on the program:</p>
<ol>
<li>
<p>If a binary operator has a constant operand, it is moved to the
right-hand side.</p>
</li>
<li>
<p>Bitwise operators with constant operands are always grouped so that
shifts are performed first, then ors, then ands, then xors.</p>
</li>
<li>
<p>Compare instructions are converted from &lt;, &gt;, â¤, or â¥ to = or â  if possible.</p>
</li>
<li>
<p>All cmp instructions on boolean values are replaced with logical operations.</p>
</li>
<li>
<p>add X, X is represented as mul X, 2 â shl X, 1</p>
</li>
<li>
<p>Multiplies with a constant power-of-two argument are transformed into shifts.</p>
</li>
<li>
<p>â¦ etc.</p>
</li>
</ol>
<p>This pass can also simplify calls to specific well-known function calls
(e.g. runtime library functions). For example, a call exit(3) that occurs within
the main() function can be transformed into simply return 3. Whether or not library
calls are simplified is controlled by the <a href="https://llvm.org/docs/Passes.html#passes-functionattrs">-functionattrs</a>
pass and LLVMâs knowledge of library calls on different targets.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_jump_threading_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#645-647">source</a><h4 class="code-header">pub fn <a href="#method.add_jump_threading_pass" class="fn">add_jump_threading_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Jump threading tries to find distinct threads of control flow
running through a basic block. This pass looks at blocks that
have multiple predecessors and multiple successors. If one or
more of the predecessors of the block can be proven to always
cause a jump to one of the successors, we forward the edge from
the predecessor to the successor by duplicating the contents of
this block.</p>
<p>An example of when this can occur is code like this:</p>
<div class="example-wrap"><pre class="language-c"><code>if () { ...
  X = 4;
}
if (X &lt; 3) {
</code></pre></div>
<p>In this case, the unconditional branch at the end of the first
if can be revectored to the false side of the second if.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_licm_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#681-683">source</a><h4 class="code-header">pub fn <a href="#method.add_licm_pass" class="fn">add_licm_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass performs loop invariant code motion,
attempting to remove as much code from the body of
a loop as possible. It does this by either hoisting
code into the preheader block, or by sinking code to
the exit blocks if it is safe. This pass also promotes
must-aliased memory locations in the loop to live in
registers, thus hoisting and sinking âinvariantâ loads
and stores.</p>
<p>This pass uses alias analysis for two purposes:</p>
<ol>
<li>
<p>Moving loop invariant loads and calls out of loops.
If we can determine that a load or call inside of a
loop never aliases anything stored to, we can hoist
it or sink it like any other instruction.</p>
</li>
<li>
<p>Scalar Promotion of Memory. If there is a store
instruction inside of the loop, we try to move the
store to happen AFTER the loop instead of inside of
the loop. This can only happen if a few conditions
are true:</p>
<ol>
<li>
<p>The pointer stored through is loop invariant.</p>
</li>
<li>
<p>There are no stores or loads in the loop
which may alias the pointer. There are no calls in
the loop which mod/ref the pointer.</p>
</li>
</ol>
</li>
</ol>
<p>If these conditions are true, we can promote the loads
and stores in the loop of the pointer to use a temporary
allocaâd variable. We then use the mem2reg functionality
to construct the appropriate SSA form for the variable.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_deletion_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#690-692">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_deletion_pass" class="fn">add_loop_deletion_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This file implements the Dead Loop Deletion Pass.
This pass is responsible for eliminating loops with
non-infinite computable trip counts that have no side
effects or volatile instructions, and do not contribute
to the computation of the functionâs return value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_idiom_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#695-697">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_idiom_pass" class="fn">add_loop_idiom_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_rotate_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#700-702">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_rotate_pass" class="fn">add_loop_rotate_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>A simple loop rotation transformation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_reroll_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#705-707">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_reroll_pass" class="fn">add_loop_reroll_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_unroll_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#714-716">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_unroll_pass" class="fn">add_loop_unroll_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass implements a simple loop unroller.
It works best when loops have been canonicalized
by the <a href="https://llvm.org/docs/Passes.html#passes-indvars">indvars</a>
pass, allowing it to determine the trip counts
of loops easily.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_loop_unswitch_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#741-745">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_unswitch_pass" class="fn">add_loop_unswitch_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass transforms loops that contain branches on
loop-invariant conditions to have multiple loops.
For example, it turns the left into the right code:</p>
<div class="example-wrap"><pre class="language-c"><code>for (...)                  if (lic)
    A                          for (...)
    if (lic)                       A; B; C
        B                  else
    C                          for (...)
                                   A; C
</code></pre></div>
<p>This can increase the size of the code exponentially
(doubling it every time a loop is unswitched) so we
only unswitch if the resultant code will be smaller
than a threshold.</p>
<p>This pass expects <a href="https://llvm.org/docs/Passes.html#passes-licm">LICM</a>
to be run before it to hoist invariant conditions
out of the loop, to make the unswitching opportunity
obvious.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_memcpy_optimize_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#750-752">source</a><h4 class="code-header">pub fn <a href="#method.add_memcpy_optimize_pass" class="fn">add_memcpy_optimize_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass performs various transformations related
to eliminating memcpy calls, or transforming sets
of stores into memsets.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_partially_inline_lib_calls_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#756-758">source</a><h4 class="code-header">pub fn <a href="#method.add_partially_inline_lib_calls_pass" class="fn">add_partially_inline_lib_calls_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass performs partial inlining, typically by inlining
an if statement that surrounds the body of the function.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_lower_switch_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#763-770">source</a><h4 class="code-header">pub fn <a href="#method.add_lower_switch_pass" class="fn">add_lower_switch_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Rewrites switch instructions with a sequence of branches,
which allows targets to get away with not implementing the
switch instruction until it is convenient.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_promote_memory_to_register_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#778-785">source</a><h4 class="code-header">pub fn <a href="#method.add_promote_memory_to_register_pass" class="fn">add_promote_memory_to_register_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This file promotes memory references to be register references.
It promotes alloca instructions which only have loads and stores
as uses. An alloca is transformed by using dominator frontiers
to place phi nodes, then traversing the function in depth-first
order to rewrite loads and stores as appropriate. This is just
the standard SSA construction algorithm to construct âprunedâ SSA form.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_reassociate_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#797-799">source</a><h4 class="code-header">pub fn <a href="#method.add_reassociate_pass" class="fn">add_reassociate_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass reassociates commutative expressions in an order that is designed
to promote better constant propagation, GCSE, LICM, PRE, etc.</p>
<p>For example: 4 + (x + 5) â x + (4 + 5)</p>
<p>In the implementation of this algorithm, constants are assigned rank = 0,
function arguments are rank = 1, and other values are assigned ranks
corresponding to the reverse post order traversal of current function
(starting at 2), which effectively gives values in deep loops higher
rank than values not in loops.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_sccp_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#811-813">source</a><h4 class="code-header">pub fn <a href="#method.add_sccp_pass" class="fn">add_sccp_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Sparse conditional constant propagation and merging, which can
be summarized as:</p>
<ul>
<li>Assumes values are constant unless proven otherwise</li>
<li>Assumes BasicBlocks are dead unless proven otherwise</li>
<li>Proves values to be constant, and replaces them with constants</li>
<li>Proves conditional branches to be unconditional</li>
</ul>
<p>Note that this pass has a habit of making definitions be dead.
It is a good idea to run a DCE pass sometime after running this pass.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_scalar_repl_aggregates_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#816-818">source</a><h4 class="code-header">pub fn <a href="#method.add_scalar_repl_aggregates_pass" class="fn">add_scalar_repl_aggregates_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_scalar_repl_aggregates_pass_ssa" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#825-827">source</a><h4 class="code-header">pub fn <a href="#method.add_scalar_repl_aggregates_pass_ssa" class="fn">add_scalar_repl_aggregates_pass_ssa</a>(&amp;self)</h4></section></summary><div class="docblock"><p>The well-known scalar replacement of aggregates transformation.
This transform breaks up alloca instructions of aggregate type
(structure or array) into individual alloca instructions for each
member if possible. Then, if possible, it transforms the individual
alloca instructions into nice clean scalar SSA form.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_scalar_repl_aggregates_pass_with_threshold" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#830-832">source</a><h4 class="code-header">pub fn <a href="#method.add_scalar_repl_aggregates_pass_with_threshold" class="fn">add_scalar_repl_aggregates_pass_with_threshold</a>(&amp;self, threshold: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.i32.html">i32</a>)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_simplify_lib_calls_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#835-837">source</a><h4 class="code-header">pub fn <a href="#method.add_simplify_lib_calls_pass" class="fn">add_simplify_lib_calls_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_tail_call_elimination_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#859-861">source</a><h4 class="code-header">pub fn <a href="#method.add_tail_call_elimination_pass" class="fn">add_tail_call_elimination_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This file transforms calls of the current function (self recursion) followed
by a return instruction with a branch to the entry of the function, creating
a loop. This pass also implements the following extensions to the basic algorithm:</p>
<ol>
<li>
<p>Trivial instructions between the call and return do not prevent the
transformation from taking place, though currently the analysis cannot support
moving any really useful instructions (only dead ones).</p>
</li>
<li>
<p>This pass transforms functions that are prevented from being tail
recursive by an associative expression to use an accumulator variable, thus
compiling the typical naive factorial or fib implementation into efficient code.</p>
</li>
<li>
<p>TRE is performed if the function returns void, if the return returns
the result returned by the call, or if the function returns a run-time constant
on all exits from the function. It is possible, though unlikely, that the return
returns something else (like constant 0), and can still be TREâd. It can be
TREâd if all other return instructions in the function return the exact same value.</p>
</li>
<li>
<p>If it can prove that callees do not access theier caller stack frame,
they are marked as eligible for tail call elimination (by the code generator).</p>
</li>
</ol>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_instruction_simplify_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#904-906">source</a><h4 class="code-header">pub fn <a href="#method.add_instruction_simplify_pass" class="fn">add_instruction_simplify_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This pass implements constant propagation and merging. It looks for instructions
involving only constant operands and replaces them with a constant value instead
of an instruction. For example:</p>
<div class="example-wrap"><pre class="language-ir"><code>add i32 1, 2
</code></pre></div>
<p>becomes</p>
<div class="example-wrap"><pre class="language-ir"><code>i32 3
</code></pre></div>
<p>NOTE: this pass has a habit of making definitions be dead. It is a good idea to
run a Dead Instruction Elimination pass sometime after running this pass.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_demote_memory_to_register_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#914-916">source</a><h4 class="code-header">pub fn <a href="#method.add_demote_memory_to_register_pass" class="fn">add_demote_memory_to_register_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>This file promotes memory references to be register references.
It promotes alloca instructions which only have loads and stores
as uses. An alloca is transformed by using dominator frontiers to
place phi nodes, then traversing the function in depth-first order to
rewrite loads and stores as appropriate. This is just the standard SSA
construction algorithm to construct âprunedâ SSA form.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_verifier_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#969-971">source</a><h4 class="code-header">pub fn <a href="#method.add_verifier_pass" class="fn">add_verifier_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Verifies an LLVM IR code. This is useful to run after an optimization
which is undergoing testing. Note that llvm-as verifies its input before
emitting bitcode, and also that malformed bitcode is likely to make
LLVM crash. All language front-ends are therefore encouraged to verify
their output before performing optimizing transformations.</p>
<ol>
<li>
<p>Both of a binary operatorâs parameters are of the same type.</p>
</li>
<li>
<p>Verify that the indices of mem access instructions match other operands.</p>
</li>
<li>
<p>Verify that arithmetic and other things are only performed on
first-class types. Verify that shifts and logicals only happen on
integrals f.e.</p>
</li>
<li>
<p>All of the constants in a switch statement are of the correct type.</p>
</li>
<li>
<p>The code is in valid SSA form.</p>
</li>
<li>
<p>It is illegal to put a label into any other type (like a structure)
or to return one.</p>
</li>
<li>
<p>Only phi nodes can be self referential: %x = add i32 %x, %x is invalid.</p>
</li>
<li>
<p>PHI nodes must have an entry for each predecessor, with no extras.</p>
</li>
<li>
<p>PHI nodes must be the first thing in a basic block, all grouped together.</p>
</li>
<li>
<p>PHI nodes must have at least one entry.</p>
</li>
<li>
<p>All basic blocks should only end with terminator insts, not contain them.</p>
</li>
<li>
<p>The entry node to a function must not have predecessors.</p>
</li>
<li>
<p>All Instructions must be embedded into a basic block.</p>
</li>
<li>
<p>Functions cannot take a void-typed parameter.</p>
</li>
<li>
<p>Verify that a functionâs argument list agrees with its declared type.</p>
</li>
<li>
<p>It is illegal to specify a name for a void value.</p>
</li>
<li>
<p>It is illegal to have an internal global value with no initializer.</p>
</li>
<li>
<p>It is illegal to have a ret instruction that returns a value that does
not agree with the function return value type.</p>
</li>
<li>
<p>Function call argument types match the function prototype.</p>
</li>
<li>
<p>All other things that are tested by asserts spread about the code.</p>
</li>
</ol>
<p>Note that this does not provide full security verification (like Java), but instead just tries to ensure that code is well-formed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_correlated_value_propagation_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#974-976">source</a><h4 class="code-header">pub fn <a href="#method.add_correlated_value_propagation_pass" class="fn">add_correlated_value_propagation_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_early_cse_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#979-981">source</a><h4 class="code-header">pub fn <a href="#method.add_early_cse_pass" class="fn">add_early_cse_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_early_cse_mem_ssa_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#985-989">source</a><h4 class="code-header">pub fn <a href="#method.add_early_cse_mem_ssa_pass" class="fn">add_early_cse_mem_ssa_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_lower_expect_intrinsic_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#992-994">source</a><h4 class="code-header">pub fn <a href="#method.add_lower_expect_intrinsic_pass" class="fn">add_lower_expect_intrinsic_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_type_based_alias_analysis_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#997-999">source</a><h4 class="code-header">pub fn <a href="#method.add_type_based_alias_analysis_pass" class="fn">add_type_based_alias_analysis_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_scoped_no_alias_aa_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1002-1004">source</a><h4 class="code-header">pub fn <a href="#method.add_scoped_no_alias_aa_pass" class="fn">add_scoped_no_alias_aa_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>No LLVM documentation is available at this time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_basic_alias_analysis_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1009-1011">source</a><h4 class="code-header">pub fn <a href="#method.add_basic_alias_analysis_pass" class="fn">add_basic_alias_analysis_pass</a>(&amp;self)</h4></section></summary><div class="docblock"><p>A basic alias analysis pass that implements identities
(two different globals cannot alias, etc), but does no
stateful analysis.</p>
</div></details><section id="method.add_aggressive_inst_combiner_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1014-1021">source</a><h4 class="code-header">pub fn <a href="#method.add_aggressive_inst_combiner_pass" class="fn">add_aggressive_inst_combiner_pass</a>(&amp;self)</h4></section><section id="method.add_loop_unroll_and_jam_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1024-1028">source</a><h4 class="code-header">pub fn <a href="#method.add_loop_unroll_and_jam_pass" class="fn">add_loop_unroll_and_jam_pass</a>(&amp;self)</h4></section><section id="method.add_coroutine_early_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1031-1035">source</a><h4 class="code-header">pub fn <a href="#method.add_coroutine_early_pass" class="fn">add_coroutine_early_pass</a>(&amp;self)</h4></section><section id="method.add_coroutine_split_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1038-1042">source</a><h4 class="code-header">pub fn <a href="#method.add_coroutine_split_pass" class="fn">add_coroutine_split_pass</a>(&amp;self)</h4></section><section id="method.add_coroutine_elide_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1045-1049">source</a><h4 class="code-header">pub fn <a href="#method.add_coroutine_elide_pass" class="fn">add_coroutine_elide_pass</a>(&amp;self)</h4></section><section id="method.add_coroutine_cleanup_pass" class="method"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1052-1056">source</a><h4 class="code-header">pub fn <a href="#method.add_coroutine_cleanup_pass" class="fn">add_coroutine_cleanup_pass</a>(&amp;self)</h4></section></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-PassManager%3CT%3E" class="impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#253">source</a><a href="#impl-Debug-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#253">source</a><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-PassManager%3CT%3E" class="impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1059-1063">source</a><a href="#impl-Drop-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../src/inkwell/passes.rs.html#1060-1062">source</a><a href="#method.drop" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.80.1/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-PassManager%3CT%3E" class="impl"><a href="#impl-Freeze-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section><section id="impl-RefUnwindSafe-for-PassManager%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-PassManager%3CT%3E" class="impl"><a href="#impl-Send-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section><section id="impl-Sync-for-PassManager%3CT%3E" class="impl"><a href="#impl-Sync-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;</h3></section><section id="impl-Unpin-for-PassManager%3CT%3E" class="impl"><a href="#impl-Unpin-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-PassManager%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-PassManager%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PassManager.html" title="struct inkwell::passes::PassManager">PassManager</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="../../src/either/into_either.rs.html#64">source</a><a href="#impl-IntoEither-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="../../src/either/into_either.rs.html#29">source</a><a href="#method.into_either" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="../../either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="../../either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="../../src/either/into_either.rs.html#55-57">source</a><a href="#method.into_either_with" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="../../either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="../../either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="../../either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="../../either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>