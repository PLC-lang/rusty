<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Extension methods for `BufRead`."><title>BufReadExt in async_std::io::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="async_std" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../async_std/index.html"><img src="https://async.rs/images/logo--hero.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../async_std/index.html"><img src="https://async.rs/images/logo--hero.svg" alt="logo"></a><h2><a href="../../../async_std/index.html">async_<wbr>std</a><span class="version">1.13.0</span></h2></div><h2 class="location"><a href="#">BufRead<wbr>Ext</a></h2><div class="sidebar-elems"><section><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.lines">lines</a></li><li><a href="#method.read_line">read_line</a></li><li><a href="#method.read_until">read_until</a></li><li><a href="#method.split">split</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In async_<wbr>std::<wbr>io::<wbr>prelude</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">async_std</a>::<wbr><a href="../index.html">io</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="trait" href="#">BufReadExt</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/async_std/io/buf_read/mod.rs.html#25-238">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait BufReadExt: <a class="trait" href="../trait.BufRead.html" title="trait async_std::io::BufRead">BufRead</a> {
    // Provided methods
    fn <a href="#method.read_until" class="fn">read_until</a>&lt;'a&gt;(
        &amp;'a mut self,
        byte: <a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>,
        buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.82.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>&gt;,
    ) -&gt; ReadUntilFuture&lt;'a, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.read_line" class="fn">read_line</a>&lt;'a&gt;(
        &amp;'a mut self,
        buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.82.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    ) -&gt; ReadLineFuture&lt;'a, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.lines" class="fn">lines</a>(self) -&gt; <a class="struct" href="../struct.Lines.html" title="struct async_std::io::Lines">Lines</a>&lt;Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.split" class="fn">split</a>(self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../struct.Split.html" title="struct async_std::io::Split">Split</a>&lt;Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Extension methods for <a href="../trait.BufRead.html"><code>BufRead</code></a>.</p>
</div></details><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.read_until" class="method"><a class="src rightside" href="../../../src/async_std/io/buf_read/mod.rs.html#76-90">source</a><h4 class="code-header">fn <a href="#method.read_until" class="fn">read_until</a>&lt;'a&gt;(
    &amp;'a mut self,
    byte: <a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>,
    buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.82.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>&gt;,
) -&gt; ReadUntilFuture&lt;'a, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Reads all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached.</p>
<p>This function will read bytes from the underlying stream until the delimiter or EOF
is found. Once found, all bytes up to, and including, the delimiter (if found) will
be appended to <code>buf</code>.</p>
<p>If successful, this function will return the total number of bytes read.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::fs::File;
<span class="kw">use </span>async_std::io::BufReader;
<span class="kw">use </span>async_std::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = BufReader::new(File::open(<span class="string">"a.txt"</span>).<span class="kw">await</span><span class="question-mark">?</span>);

<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::with_capacity(<span class="number">1024</span>);
<span class="kw">let </span>n = file.read_until(<span class="string">b'\n'</span>, <span class="kw-2">&amp;mut </span>buf).<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Multiple successful calls to <code>read_until</code> append all bytes up to and including to
<code>buf</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::io::BufReader;
<span class="kw">use </span>async_std::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>from: <span class="kw-2">&amp;</span>[u8] = <span class="string">b"append\nexample\n"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = BufReader::new(from);
<span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[];

<span class="kw">let </span><span class="kw-2">mut </span>size = reader.read_until(<span class="string">b'\n'</span>, <span class="kw-2">&amp;mut </span>buf).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(size, <span class="number">7</span>);
<span class="macro">assert_eq!</span>(buf, <span class="string">b"append\n"</span>);

size += reader.read_until(<span class="string">b'\n'</span>, <span class="kw-2">&amp;mut </span>buf).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(size, from.len());

<span class="macro">assert_eq!</span>(buf, from);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_line" class="method"><a class="src rightside" href="../../../src/async_std/io/buf_read/mod.rs.html#130-143">source</a><h4 class="code-header">fn <a href="#method.read_line" class="fn">read_line</a>&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut <a class="struct" href="https://doc.rust-lang.org/1.82.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; ReadLineFuture&lt;'a, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h4></section></summary><div class="docblock"><p>Reads all bytes and appends them into <code>buf</code> until a newline (the 0xA byte) is
reached.</p>
<p>This function will read bytes from the underlying stream until the newline
delimiter (the 0xA byte) or EOF is found. Once found, all bytes up to, and
including, the delimiter (if found) will be appended to <code>buf</code>.</p>
<p>If successful, this function will return the total number of bytes read.</p>
<p>If this function returns <code>Ok(0)</code>, the stream has reached EOF.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This function has the same error semantics as <a href="#method.read_until"><code>read_until</code></a> and will also return
an error if the read bytes are not valid UTF-8. If an I/O error is encountered then
<code>buf</code> may contain some bytes already read in the event that all data read so far
was valid UTF-8.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::fs::File;
<span class="kw">use </span>async_std::io::BufReader;
<span class="kw">use </span>async_std::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = BufReader::new(File::open(<span class="string">"a.txt"</span>).<span class="kw">await</span><span class="question-mark">?</span>);

<span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
file.read_line(<span class="kw-2">&amp;mut </span>buf).<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><a class="src rightside" href="../../../src/async_std/io/buf_read/mod.rs.html#176-186">source</a><h4 class="code-header">fn <a href="#method.lines" class="fn">lines</a>(self) -&gt; <a class="struct" href="../struct.Lines.html" title="struct async_std::io::Lines">Lines</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> + <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns a stream over the lines of this byte stream.</p>
<p>The stream returned from this function will yield instances of
<a href="type.Result.html"><code>io::Result</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><code>&gt;</code>. Each string returned will <em>not</em> have a newline byte
(the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::fs::File;
<span class="kw">use </span>async_std::io::BufReader;
<span class="kw">use </span>async_std::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>file = File::open(<span class="string">"a.txt"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = BufReader::new(file).lines();
<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;

<span class="kw">while let </span><span class="prelude-val">Some</span>(line) = lines.next().<span class="kw">await </span>{
    line<span class="question-mark">?</span>;
    count += <span class="number">1</span>;
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><a class="src rightside" href="../../../src/async_std/io/buf_read/mod.rs.html#227-237">source</a><h4 class="code-header">fn <a href="#method.split" class="fn">split</a>(self, byte: <a class="primitive" href="https://doc.rust-lang.org/1.82.0/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../struct.Split.html" title="struct async_std::io::Split">Split</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns a stream over the contents of this reader split on the byte <code>byte</code>.</p>
<p>The stream returned from this function will return instances of
<a href="type.Result.html"><code>io::Result</code></a><code>&lt;</code><a href="../vec/struct.Vec.html"><code>Vec&lt;u8&gt;</code></a><code>&gt;</code>. Each vector returned will <em>not</em> have
the delimiter byte at the end.</p>
<p>This function will yield errors whenever <a href="#method.read_until"><code>read_until</code></a> would have
also yielded an error.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<p><a href="struct.Cursor.html"><code>std::io::Cursor</code></a> is a type that implements <code>BufRead</code>. In
this example, we use <a href="struct.Cursor.html"><code>Cursor</code></a> to iterate over all hyphen delimited
segments in a byte slice</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>async_std::io;

<span class="kw">let </span>cursor = io::Cursor::new(<span class="string">b"lorem-ipsum-dolor"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>split_iter = cursor.split(<span class="string">b'-'</span>).map(|l| l.unwrap());
<span class="macro">assert_eq!</span>(split_iter.next().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="string">b"lorem"</span>.to_vec()));
<span class="macro">assert_eq!</span>(split_iter.next().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="string">b"ipsum"</span>.to_vec()));
<span class="macro">assert_eq!</span>(split_iter.next().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="string">b"dolor"</span>.to_vec()));
<span class="macro">assert_eq!</span>(split_iter.next().<span class="kw">await</span>, <span class="prelude-val">None</span>);</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.82.0/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-BufReadExt-for-T" class="impl"><a class="src rightside" href="../../../src/async_std/io/buf_read/mod.rs.html#240">source</a><a href="#impl-BufReadExt-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../trait.BufRead.html" title="trait async_std::io::BufRead">BufRead</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.82.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.BufReadExt.html" title="trait async_std::io::prelude::BufReadExt">BufReadExt</a> for T</h3></section></div><script src="../../../trait.impl/async_std/io/buf_read/trait.BufReadExt.js" async></script></section></div></main></body></html>