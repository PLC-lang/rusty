<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A guard that keeps the current thread pinned."><title>Guard in crossbeam_epoch - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="crossbeam_epoch" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../crossbeam_epoch/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../crossbeam_epoch/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Guard</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.collector">collector</a></li><li><a href="#method.defer">defer</a></li><li><a href="#method.defer_destroy">defer_destroy</a></li><li><a href="#method.defer_unchecked">defer_unchecked</a></li><li><a href="#method.flush">flush</a></li><li><a href="#method.repin">repin</a></li><li><a href="#method.repin_after">repin_after</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-Guard">Debug</a></li><li><a href="#impl-Drop-for-Guard">Drop</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Guard">!RefUnwindSafe</a></li><li><a href="#impl-Send-for-Guard">!Send</a></li><li><a href="#impl-Sync-for-Guard">!Sync</a></li><li><a href="#impl-UnwindSafe-for-Guard">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Guard">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Guard">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Guard">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Guard">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Guard">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Guard">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Guard">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Guard">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crossbeam_epoch</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">crossbeam_epoch</a>::<wbr><a class="struct" href="#">Guard</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/crossbeam_epoch/guard.rs.html#71-73">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Guard { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A guard that keeps the current thread pinned.</p>
<h2 id="pinning"><a href="#pinning">Pinning</a></h2>
<p>The current thread is pinned by calling <a href="fn.pin.html" title="fn crossbeam_epoch::pin"><code>pin</code></a>, which returns a new guard:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch <span class="kw">as </span>epoch;

<span class="comment">// It is often convenient to prefix a call to `pin` with a `&amp;` in order to create a reference.
// This is not really necessary, but makes passing references to the guard a bit easier.
</span><span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();</code></pre></div>
<p>When a guard gets dropped, the current thread is automatically unpinned.</p>
<h2 id="pointers-on-the-stack"><a href="#pointers-on-the-stack">Pointers on the stack</a></h2>
<p>Having a guard allows us to create pointers on the stack to heap-allocated objects.
For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch::{<span class="self">self </span><span class="kw">as </span>epoch, Atomic};
<span class="kw">use </span>std::sync::atomic::Ordering::SeqCst;

<span class="comment">// Create a heap-allocated number.
</span><span class="kw">let </span>a = Atomic::new(<span class="number">777</span>);

<span class="comment">// Pin the current thread.
</span><span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();

<span class="comment">// Load the heap-allocated object and create pointer `p` on the stack.
</span><span class="kw">let </span>p = a.load(SeqCst, guard);

<span class="comment">// Dereference the pointer and print the value:
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(num) = <span class="kw">unsafe </span>{ p.as_ref() } {
    <span class="macro">println!</span>(<span class="string">&quot;The number is {}.&quot;</span>, num);
}</code></pre></div>
<h2 id="multiple-guards"><a href="#multiple-guards">Multiple guards</a></h2>
<p>Pinning is reentrant and it is perfectly legal to create multiple guards. In that case, the
thread will actually be pinned only when the first guard is created and unpinned when the last
one is dropped:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch <span class="kw">as </span>epoch;

<span class="kw">let </span>guard1 = epoch::pin();
<span class="kw">let </span>guard2 = epoch::pin();
<span class="macro">assert!</span>(epoch::is_pinned());
drop(guard1);
<span class="macro">assert!</span>(epoch::is_pinned());
drop(guard2);
<span class="macro">assert!</span>(!epoch::is_pinned());</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Guard" class="impl"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#75-406">source</a><a href="#impl-Guard" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.defer" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#91-99">source</a><h4 class="code-header">pub fn <a href="#method.defer" class="fn">defer</a>&lt;F, R&gt;(&amp;self, f: F)<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; R + <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + 'static,</span></h4></section></summary><div class="docblock"><p>Stores a function so that it can be executed at some point after all currently pinned
threads get unpinned.</p>
<p>This method first stores <code>f</code> into the thread-local (or handle-local) cache. If this cache
becomes full, some functions are moved into the global cache. At the same time, some
functions from both local and global caches may get executed in order to incrementally
clean up the caches as they fill up.</p>
<p>There is no guarantee when exactly <code>f</code> will be executed. The only guarantee is that it
won’t be executed until all currently pinned threads get unpinned. In theory, <code>f</code> might
never run, but the epoch-based garbage collection will make an effort to execute it
reasonably soon.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, the function will simply be
executed immediately.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.defer_unchecked" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#190-199">source</a><h4 class="code-header">pub unsafe fn <a href="#method.defer_unchecked" class="fn">defer_unchecked</a>&lt;F, R&gt;(&amp;self, f: F)<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; R,</span></h4></section></summary><div class="docblock"><p>Stores a function so that it can be executed at some point after all currently pinned
threads get unpinned.</p>
<p>This method first stores <code>f</code> into the thread-local (or handle-local) cache. If this cache
becomes full, some functions are moved into the global cache. At the same time, some
functions from both local and global caches may get executed in order to incrementally
clean up the caches as they fill up.</p>
<p>There is no guarantee when exactly <code>f</code> will be executed. The only guarantee is that it
won’t be executed until all currently pinned threads get unpinned. In theory, <code>f</code> might
never run, but the epoch-based garbage collection will make an effort to execute it
reasonably soon.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, the function will simply be
executed immediately.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>The given function must not hold reference onto the stack. It is highly recommended that
the passed function is <strong>always</strong> marked with <code>move</code> in order to prevent accidental
borrows.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch <span class="kw">as </span>epoch;

<span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();
<span class="kw">let </span>message = <span class="string">&quot;Hello!&quot;</span>;
<span class="kw">unsafe </span>{
    <span class="comment">// ALWAYS use `move` when sending a closure into `defer_unchecked`.
    </span>guard.defer_unchecked(<span class="kw">move </span>|| {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, message);
    });
}</code></pre></div>
<p>Apart from that, keep in mind that another thread may execute <code>f</code>, so anything accessed by
the closure must be <code>Send</code>.</p>
<p>We intentionally didn’t require <code>F: Send</code>, because Rust’s type systems usually cannot prove
<code>F: Send</code> for typical use cases. For example, consider the following code snippet, which
exemplifies the typical use case of deferring the deallocation of a shared reference:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>shared = Owned::new(<span class="number">7i32</span>).into_shared(guard);
guard.defer_unchecked(<span class="kw">move </span>|| shared.into_owned()); <span class="comment">// `Shared` is not `Send`!</span></code></pre></div>
<p>While <code>Shared</code> is not <code>Send</code>, it’s safe for another thread to call the deferred function,
because it’s called only after the grace period and <code>shared</code> is no longer shared with other
threads. But we don’t expect type systems to prove this.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>When a heap-allocated object in a data structure becomes unreachable, it has to be
deallocated. However, the current thread and other threads may be still holding references
on the stack to that same object. Therefore it cannot be deallocated before those references
get dropped. This method can defer deallocation until all those threads get unpinned and
consequently drop all their references on the stack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch::{<span class="self">self </span><span class="kw">as </span>epoch, Atomic, Owned};
<span class="kw">use </span>std::sync::atomic::Ordering::SeqCst;

<span class="kw">let </span>a = Atomic::new(<span class="string">&quot;foo&quot;</span>);

<span class="comment">// Now suppose that `a` is shared among multiple threads and concurrently
// accessed and modified...

// Pin the current thread.
</span><span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();

<span class="comment">// Steal the object currently stored in `a` and swap it with another one.
</span><span class="kw">let </span>p = a.swap(Owned::new(<span class="string">&quot;bar&quot;</span>).into_shared(guard), SeqCst, guard);

<span class="kw">if </span>!p.is_null() {
    <span class="comment">// The object `p` is pointing to is now unreachable.
    // Defer its deallocation until all currently pinned threads get unpinned.
    </span><span class="kw">unsafe </span>{
        <span class="comment">// ALWAYS use `move` when sending a closure into `defer_unchecked`.
        </span>guard.defer_unchecked(<span class="kw">move </span>|| {
            <span class="macro">println!</span>(<span class="string">&quot;{} is now being deallocated.&quot;</span>, p.deref());
            <span class="comment">// Now we have unique access to the object pointed to by `p` and can turn it
            // into an `Owned`. Dropping the `Owned` will deallocate the object.
            </span>drop(p.into_owned());
        });
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.defer_destroy" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#270-272">source</a><h4 class="code-header">pub unsafe fn <a href="#method.defer_destroy" class="fn">defer_destroy</a>&lt;T&gt;(&amp;self, ptr: <a class="struct" href="struct.Shared.html" title="struct crossbeam_epoch::Shared">Shared</a>&lt;'_, T&gt;)</h4></section></summary><div class="docblock"><p>Stores a destructor for an object so that it can be deallocated and dropped at some point
after all currently pinned threads get unpinned.</p>
<p>This method first stores the destructor into the thread-local (or handle-local) cache. If
this cache becomes full, some destructors are moved into the global cache. At the same
time, some destructors from both local and global caches may get executed in order to
incrementally clean up the caches as they fill up.</p>
<p>There is no guarantee when exactly the destructor will be executed. The only guarantee is
that it won’t be executed until all currently pinned threads get unpinned. In theory, the
destructor might never run, but the epoch-based garbage collection will make an effort to
execute it reasonably soon.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, the destructor will simply be
executed immediately.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>The object must not be reachable by other threads anymore, otherwise it might be still in
use when the destructor runs.</p>
<p>Apart from that, keep in mind that another thread may execute the destructor, so the object
must be sendable to other threads.</p>
<p>We intentionally didn’t require <code>T: Send</code>, because Rust’s type systems usually cannot prove
<code>T: Send</code> for typical use cases. For example, consider the following code snippet, which
exemplifies the typical use case of deferring the deallocation of a shared reference:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>shared = Owned::new(<span class="number">7i32</span>).into_shared(guard);
guard.defer_destroy(shared); <span class="comment">// `Shared` is not `Send`!</span></code></pre></div>
<p>While <code>Shared</code> is not <code>Send</code>, it’s safe for another thread to call the destructor, because
it’s called only after the grace period and <code>shared</code> is no longer shared with other
threads. But we don’t expect type systems to prove this.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>When a heap-allocated object in a data structure becomes unreachable, it has to be
deallocated. However, the current thread and other threads may be still holding references
on the stack to that same object. Therefore it cannot be deallocated before those references
get dropped. This method can defer deallocation until all those threads get unpinned and
consequently drop all their references on the stack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch::{<span class="self">self </span><span class="kw">as </span>epoch, Atomic, Owned};
<span class="kw">use </span>std::sync::atomic::Ordering::SeqCst;

<span class="kw">let </span>a = Atomic::new(<span class="string">&quot;foo&quot;</span>);

<span class="comment">// Now suppose that `a` is shared among multiple threads and concurrently
// accessed and modified...

// Pin the current thread.
</span><span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();

<span class="comment">// Steal the object currently stored in `a` and swap it with another one.
</span><span class="kw">let </span>p = a.swap(Owned::new(<span class="string">&quot;bar&quot;</span>).into_shared(guard), SeqCst, guard);

<span class="kw">if </span>!p.is_null() {
    <span class="comment">// The object `p` is pointing to is now unreachable.
    // Defer its deallocation until all currently pinned threads get unpinned.
    </span><span class="kw">unsafe </span>{
        guard.defer_destroy(p);
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#294-298">source</a><h4 class="code-header">pub fn <a href="#method.flush" class="fn">flush</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Clears up the thread-local cache of deferred functions by executing them or moving into the
global cache.</p>
<p>Call this method after deferring execution of a function if you want to get it executed as
soon as possible. Flushing will make sure it is residing in in the global cache, so that
any thread has a chance of taking the function and executing it.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, it is a no-op (nothing happens).</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch <span class="kw">as </span>epoch;

<span class="kw">let </span>guard = <span class="kw-2">&amp;</span>epoch::pin();
guard.defer(<span class="kw">move </span>|| {
    <span class="macro">println!</span>(<span class="string">&quot;This better be printed as soon as possible!&quot;</span>);
});
guard.flush();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repin" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#328-332">source</a><h4 class="code-header">pub fn <a href="#method.repin" class="fn">repin</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Unpins and then immediately re-pins the thread.</p>
<p>This method is useful when you don’t want delay the advancement of the global epoch by
holding an old epoch. For safety, you should not maintain any guard-based reference across
the call (the latter is enforced by <code>&amp;mut self</code>). The thread will only be repinned if this
is the only active guard for the current thread.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, then the call will be just no-op.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch::{<span class="self">self </span><span class="kw">as </span>epoch, Atomic};
<span class="kw">use </span>std::sync::atomic::Ordering::SeqCst;

<span class="kw">let </span>a = Atomic::new(<span class="number">777</span>);
<span class="kw">let </span><span class="kw-2">mut </span>guard = epoch::pin();
{
    <span class="kw">let </span>p = a.load(SeqCst, <span class="kw-2">&amp;</span>guard);
    <span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ p.as_ref() }, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">777</span>));
}
guard.repin();
{
    <span class="kw">let </span>p = a.load(SeqCst, <span class="kw-2">&amp;</span>guard);
    <span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ p.as_ref() }, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">777</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repin_after" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#365-385">source</a><h4 class="code-header">pub fn <a href="#method.repin_after" class="fn">repin_after</a>&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; R,</span></h4></section></summary><div class="docblock"><p>Temporarily unpins the thread, executes the given function and then re-pins the thread.</p>
<p>This method is useful when you need to perform a long-running operation (e.g. sleeping)
and don’t need to maintain any guard-based reference across the call (the latter is enforced
by <code>&amp;mut self</code>). The thread will only be unpinned if this is the only active guard for the
current thread.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, then the passed function is called
directly without unpinning the thread.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch::{<span class="self">self </span><span class="kw">as </span>epoch, Atomic};
<span class="kw">use </span>std::sync::atomic::Ordering::SeqCst;
<span class="kw">use </span>std::thread;
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span>a = Atomic::new(<span class="number">777</span>);
<span class="kw">let </span><span class="kw-2">mut </span>guard = epoch::pin();
{
    <span class="kw">let </span>p = a.load(SeqCst, <span class="kw-2">&amp;</span>guard);
    <span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ p.as_ref() }, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">777</span>));
}
guard.repin_after(|| thread::sleep(Duration::from_millis(<span class="number">50</span>)));
{
    <span class="kw">let </span>p = a.load(SeqCst, <span class="kw-2">&amp;</span>guard);
    <span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ p.as_ref() }, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">777</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.collector" class="method"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#403-405">source</a><h4 class="code-header">pub fn <a href="#method.collector" class="fn">collector</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.Collector.html" title="struct crossbeam_epoch::Collector">Collector</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>Collector</code> associated with this guard.</p>
<p>This method is useful when you need to ensure that all guards used with
a data structure come from the same collector.</p>
<p>If this method is called from an <a href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected"><code>unprotected</code></a> guard, then <code>None</code> is returned.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crossbeam_epoch <span class="kw">as </span>epoch;

<span class="kw">let </span>guard1 = epoch::pin();
<span class="kw">let </span>guard2 = epoch::pin();
<span class="macro">assert!</span>(guard1.collector() == guard2.collector());</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Guard" class="impl"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#417-421">source</a><a href="#impl-Debug-for-Guard" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#418-420">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.70.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.70.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-Guard" class="impl"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#408-415">source</a><a href="#impl-Drop-for-Guard" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="srclink rightside" href="../src/crossbeam_epoch/guard.rs.html#410-414">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.70.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Guard" class="impl"><a href="#impl-RefUnwindSafe-for-Guard" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section><section id="impl-Send-for-Guard" class="impl"><a href="#impl-Send-for-Guard" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section><section id="impl-Sync-for-Guard" class="impl"><a href="#impl-Sync-for-Guard" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section><section id="impl-Unpin-for-Guard" class="impl"><a href="#impl-Unpin-for-Guard" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section><section id="impl-UnwindSafe-for-Guard" class="impl"><a href="#impl-UnwindSafe-for-Guard" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.70.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#734">source</a><a href="#impl-From%3CT%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#737">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#726">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#777">source</a><a href="#impl-TryFrom%3CU%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#784">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Guard" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#761">source</a><a href="#impl-TryInto%3CU%3E-for-Guard" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#768">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>