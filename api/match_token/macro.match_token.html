<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implements the `match_token!()` macro for use by the HTML tree builder in `src/tree_builder/rules.rs`."><title>match_token in match_token - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="match_token" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../match_token/index.html">match_<wbr>token</a><span class="version">0.35.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">match_<wbr>token</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li><li><a href="#syntax" title="Syntax">Syntax</a></li><li><a href="#semantics" title="Semantics">Semantics</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate match_<wbr>token</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">match_token</a></div><h1>Macro <span class="macro">match_token</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/match_token/lib.rs.html#72-79">Source</a> </span></div><pre class="rust item-decl"><code>match_token!() { <span class="comment">/* proc-macro */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implements the <code>match_token!()</code> macro for use by the HTML tree builder
in <code>src/tree_builder/rules.rs</code>.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">match_token!</span>(token {
    CommentToken(text) =&gt; <span class="number">1</span>,
    tag @ &lt;base&gt; &lt;link&gt; &lt;meta&gt; =&gt; <span class="number">2</span>,
    &lt;/head&gt; =&gt; <span class="number">3</span>,
    &lt;/body&gt; &lt;/html&gt; &lt;/br&gt; =&gt; <span class="kw">else</span>,
    tag @ &lt;/<span class="kw">_</span>&gt; =&gt; <span class="number">4</span>,
    token =&gt; <span class="number">5</span>,
})</code></pre></div>
<h3 id="syntax"><a class="doc-anchor" href="#syntax">§</a>Syntax</h3>
<p>Because of the simplistic parser, the macro invocation must
start with exactly <code>match_token!(token {</code> (with whitespace as specified)
and end with exactly <code>})</code>.
The left-hand side of each match arm is an optional <code>name @</code> binding, followed by</p>
<ul>
<li>an ordinary Rust pattern that starts with an identifier or an underscore, or</li>
<li>a sequence of HTML tag names as identifiers, each inside “&lt;…&gt;” or “&lt;/…&gt;”
to match an open or close tag respectively, or</li>
<li>a “wildcard tag” “&lt;<em>&gt;” or “&lt;/</em>&gt;” to match all open tags or all close tags
respectively.</li>
</ul>
<p>The right-hand side is either an expression or the keyword <code>else</code>.
Note that this syntax does not support guards or pattern alternation like
<code>Foo | Bar</code>.  This is not a fundamental limitation; it’s done for implementation
simplicity.</p>
<h3 id="semantics"><a class="doc-anchor" href="#semantics">§</a>Semantics</h3>
<p>Ordinary Rust patterns match as usual.  If present, the <code>name @</code> binding has
the usual meaning.
A sequence of named tags matches any of those tags.  A single sequence can
contain both open and close tags.  If present, the <code>name @</code> binding binds (by
move) the <code>Tag</code> struct, not the outer <code>Token</code>.  That is, a match arm like</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>tag @ &lt;html&gt; &lt;head&gt; =&gt; ...</code></pre></div>
<p>expands to something like</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>TagToken(tag @ Tag { name: <span class="macro">local_name!</span>(<span class="string">"html"</span>), kind: StartTag })
| TagToken(tag @ Tag { name: <span class="macro">local_name!</span>(<span class="string">"head"</span>), kind: StartTag }) =&gt; ...</code></pre></div>
<p>A wildcard tag matches any tag of the appropriate kind, <em>unless</em> it was
previously matched with an <code>else</code> right-hand side (more on this below).
The expansion of this macro reorders code somewhat, to satisfy various
restrictions arising from moves.  However it provides the semantics of in-order
matching, by enforcing the following restrictions on its input:</p>
<ul>
<li>The last pattern must be a variable or the wildcard “_”.  In other words
it must match everything.</li>
<li>Otherwise, ordinary Rust patterns and specific-tag patterns cannot appear
after wildcard tag patterns.</li>
<li>No tag name may appear more than once.</li>
<li>A wildcard tag pattern may not occur in the same arm as any other tag.
“&lt;<em>&gt; <html> =&gt; …” and “&lt;</em>&gt; &lt;/_&gt; =&gt; …” are both forbidden.</li>
<li>The right-hand side “else” may only appear with specific-tag patterns.
It means that these specific tags should be handled by the last,
catch-all case arm, rather than by any wildcard tag arm.  This situation
is common in the HTML5 syntax.</li>
</ul>
</div></details></section></div></main></body></html>