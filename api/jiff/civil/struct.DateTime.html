<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A representation of a civil datetime in the Gregorian calendar."><title>DateTime in jiff::civil - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Date<wbr>Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#civil-datetimes" title="Civil datetimes">Civil datetimes</a></li><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#default-value" title="Default value">Default value</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding" title="Rounding">Rounding</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.ZERO" title="ZERO">ZERO</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.constant" title="constant">constant</a></li><li><a href="#method.date" title="date">date</a></li><li><a href="#method.day" title="day">day</a></li><li><a href="#method.day_of_year" title="day_of_year">day_of_year</a></li><li><a href="#method.day_of_year_no_leap" title="day_of_year_no_leap">day_of_year_no_leap</a></li><li><a href="#method.days_in_month" title="days_in_month">days_in_month</a></li><li><a href="#method.days_in_year" title="days_in_year">days_in_year</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.end_of_day" title="end_of_day">end_of_day</a></li><li><a href="#method.era_year" title="era_year">era_year</a></li><li><a href="#method.first_of_month" title="first_of_month">first_of_month</a></li><li><a href="#method.first_of_year" title="first_of_year">first_of_year</a></li><li><a href="#method.from_parts" title="from_parts">from_parts</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.in_leap_year" title="in_leap_year">in_leap_year</a></li><li><a href="#method.in_tz" title="in_tz">in_tz</a></li><li><a href="#method.iso_week_date" title="iso_week_date">iso_week_date</a></li><li><a href="#method.last_of_month" title="last_of_month">last_of_month</a></li><li><a href="#method.last_of_year" title="last_of_year">last_of_year</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.month" title="month">month</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.nth_weekday" title="nth_weekday">nth_weekday</a></li><li><a href="#method.nth_weekday_of_month" title="nth_weekday_of_month">nth_weekday_of_month</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.series" title="series">series</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.start_of_day" title="start_of_day">start_of_day</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.time" title="time">time</a></li><li><a href="#method.to_zoned" title="to_zoned">to_zoned</a></li><li><a href="#method.tomorrow" title="tomorrow">tomorrow</a></li><li><a href="#method.until" title="until">until</a></li><li><a href="#method.weekday" title="weekday">weekday</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.year" title="year">year</a></li><li><a href="#method.yesterday" title="yesterday">yesterday</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-DateTime" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-DateTime" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-DateTime" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-DateTime" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-DateTime" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-DateTime" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-DateTime" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-DateTime" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-DateTime" title="Debug">Debug</a></li><li><a href="#impl-Default-for-DateTime" title="Default">Default</a></li><li><a href="#impl-Display-for-DateTime" title="Display">Display</a></li><li><a href="#impl-Eq-for-DateTime" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-DateTime" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDate%3E-for-DateTime" title="From&#60;Date&#62;">From&#60;Date&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Date" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-DateDifference" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-DateTimeDifference" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-ISOWeekDate" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Pieces%3C'static%3E" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-SpanRelativeTo%3C'static%3E" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Time" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-TimeDifference" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-DateTime" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromStr-for-DateTime" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-DateTime" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-DateTime" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-DateTime" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-DateTime" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-DateTime" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sub-for-DateTime" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-DateTime" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-DateTime" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-DateTime" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-DateTime" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-DateTime" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-DateTime" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-DateTime" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-DateTime" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-DateTime" title="Send">Send</a></li><li><a href="#impl-Sync-for-DateTime" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-DateTime" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-DateTime" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>civil</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">jiff</a>::<wbr><a href="index.html">civil</a></div><h1>Struct <span class="struct">DateTime</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/jiff/civil/datetime.rs.html#220-223">Source</a> </span></div><pre class="rust item-decl"><code>pub struct DateTime { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A representation of a civil datetime in the Gregorian calendar.</p>
<p>A <code>DateTime</code> value corresponds to a pair of a <a href="struct.Date.html" title="struct jiff::civil::Date"><code>Date</code></a> and a <a href="struct.Time.html" title="struct jiff::civil::Time"><code>Time</code></a>.
That is, a datetime contains a year, month, day, hour, minute, second and
the fractional number of nanoseconds.</p>
<p>A <code>DateTime</code> value is guaranteed to contain a valid date and time. For
example, neither <code>2023-02-29T00:00:00</code> nor <code>2015-06-30T23:59:60</code> are
valid <code>DateTime</code> values.</p>
<h2 id="civil-datetimes"><a class="doc-anchor" href="#civil-datetimes">§</a>Civil datetimes</h2>
<p>A <code>DateTime</code> value behaves without regard to daylight saving time or time
zones in general. When doing arithmetic on datetimes with spans defined in
units of time (such as with <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>), days are considered
to always be precisely <code>86,400</code> seconds long.</p>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>DateTime</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>dt: DateTime = <span class="string">"2024-06-19 15:22:45"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt.to_string(), <span class="string">"2024-06-19T15:22:45"</span>);
</code></pre></div>
<p>A civil <code>DateTime</code> can also be parsed from something that <em>contains</em> a
datetime, but with perhaps other data (such as an offset or time zone):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>dt: DateTime = <span class="string">"2024-06-19T15:22:45-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt.to_string(), <span class="string">"2024-06-19T15:22:45"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="../fmt/temporal/index.html" title="mod jiff::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="default-value"><a class="doc-anchor" href="#default-value">§</a>Default value</h2>
<p>For convenience, this type implements the <code>Default</code> trait. Its default
value corresponds to <code>0000-01-01T00:00:00.000000000</code>. That is, it is
the datetime corresponding to <code>DateTime::from_parts(Date::default(), Time::default())</code>. One can also access this value via the <code>DateTime::ZERO</code>
constant.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a datetime with a second component
of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date};

<span class="kw">let </span>dt: DateTime = <span class="string">"2016-12-31 23:59:60"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt, date(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>));
</code></pre></div>
<h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>DateTime</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations to
facilitate easy comparisons. When a datetime <code>dt1</code> occurs before a datetime
<code>dt2</code>, then <code>dt1 &lt; dt2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">1</span>, <span class="number">25</span>, <span class="number">15</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(dt1 &lt; dt2);</code></pre></div>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>DateTime</code> values.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a> or <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a> for checked
arithmetic.</li>
<li><a href="struct.DateTime.html#method.saturating_add" title="method jiff::civil::DateTime::saturating_add"><code>DateTime::saturating_add</code></a> or <a href="struct.DateTime.html#method.saturating_sub" title="method jiff::civil::DateTime::saturating_sub"><code>DateTime::saturating_sub</code></a> for
saturating arithmetic.</li>
</ul>
<p>Additionally, checked arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations. When the result overflows, a panic occurs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>start = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">15</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>one_week_later = start + <span class="number">1</span>.weeks();
<span class="macro">assert_eq!</span>(one_week_later, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">15</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
<p>One can compute the span of time between two datetimes using either
<a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a> or <a href="struct.DateTime.html#method.since" title="method jiff::civil::DateTime::since"><code>DateTime::since</code></a>. It’s also possible to subtract
two <code>DateTime</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>datetime1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>datetime2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    datetime1 - datetime2,
    <span class="number">68</span>.days().hours(<span class="number">16</span>).minutes(<span class="number">30</span>).fieldwise(),
);</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is days
(as exemplified above), but we can ask for bigger units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>datetime1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>datetime2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    datetime1.since((Unit::Year, datetime2))<span class="question-mark">?</span>,
    <span class="number">2</span>.months().days(<span class="number">7</span>).hours(<span class="number">16</span>).minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<p>Or even round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTimeDifference, date}, RoundMode, ToSpan, Unit};

<span class="kw">let </span>datetime1 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>datetime2 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    datetime1.since(
        DateTimeDifference::new(datetime2)
            .smallest(Unit::Day)
            .largest(Unit::Year),
    )<span class="question-mark">?</span>,
    <span class="number">2</span>.months().days(<span class="number">7</span>).fieldwise(),
);
<span class="comment">// `DateTimeDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    datetime1.since(
        DateTimeDifference::new(datetime2)
            .smallest(Unit::Day)
            .largest(Unit::Year)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 8 days.
    </span><span class="number">2</span>.months().days(<span class="number">8</span>).fieldwise(),
);
</code></pre></div>
<h2 id="rounding"><a class="doc-anchor" href="#rounding">§</a>Rounding</h2>
<p>A <code>DateTime</code> can be rounded based on a <a href="struct.DateTimeRound.html" title="struct jiff::civil::DateTimeRound"><code>DateTimeRound</code></a> configuration of
smallest units, rounding increment and rounding mode. Here’s an example
showing how to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTimeRound, date}, Unit};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">16</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    dt.round(DateTimeRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for DateTimeRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(
    dt.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
</code></pre></div>
<p>See <a href="struct.DateTime.html#method.round" title="method jiff::civil::DateTime::round"><code>DateTime::round</code></a> for more details.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#225-2413">Source</a><a href="#impl-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#231">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>The minimum representable Gregorian datetime.</p>
<p>The minimum is chosen such that any <a href="../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>
combined with any valid time zone offset can be infallibly converted to
this type.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#238">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>The maximum representable Gregorian datetime.</p>
<p>The maximum is chosen such that any <a href="../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>
combined with any valid time zone offset can be infallibly converted to
this type.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.ZERO" class="associatedconstant"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#251">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.ZERO" class="constant">ZERO</a>: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>The first day of the zeroth year.</p>
<p>This is guaranteed to be equivalent to <code>DateTime::default()</code>.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="macro">assert_eq!</span>(DateTime::ZERO, DateTime::default());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#304-316">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    year: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>,
    month: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>DateTime</code> value from its component year, month, day,
hour, minute, second and fractional subsecond (up to nanosecond
precision) values.</p>
<p>To create a new datetime from another with a particular component, use
the methods on <a href="struct.DateTimeWith.html" title="struct jiff::civil::DateTimeWith"><code>DateTimeWith</code></a> via <a href="struct.DateTime.html#method.with" title="method jiff::civil::DateTime::with"><code>DateTime::with</code></a>.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when the given components do not correspond to a
valid datetime. Namely, all of the following must be true:</p>
<ul>
<li>The year must be in the range <code>-9999..=9999</code>.</li>
<li>The month must be in the range <code>1..=12</code>.</li>
<li>The day must be at least <code>1</code> and must be at most the number of days
in the corresponding month. So for example, <code>2024-02-29</code> is valid but
<code>2023-02-29</code> is not.</li>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This shows an example of a valid datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>d = DateTime::new(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>).unwrap();
<span class="macro">assert_eq!</span>(d.year(), <span class="number">2024</span>);
<span class="macro">assert_eq!</span>(d.month(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(d.day(), <span class="number">29</span>);
<span class="macro">assert_eq!</span>(d.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(d.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(d.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(d.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(d.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(d.nanosecond(), <span class="number">789</span>);</code></pre></div>
<p>This shows some examples of invalid datetimes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="macro">assert!</span>(DateTime::new(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">0</span>).is_err());
<span class="macro">assert!</span>(DateTime::new(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">0</span>).is_err());
<span class="macro">assert!</span>(DateTime::new(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">58</span>, <span class="number">0</span>, <span class="number">1_000_000_000</span>).is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.constant" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#377-389">Source</a><h4 class="code-header">pub const fn <a href="#method.constant" class="fn">constant</a>(
    year: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>,
    month: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Creates a new <code>DateTime</code> value in a <code>const</code> context.</p>
<p>Note that an alternative syntax that is terser and perhaps easier to
read for the same operation is to combine
<a href="fn.date.html" title="fn jiff::civil::date"><code>civil::date</code></a> with <a href="struct.Date.html#method.at" title="method jiff::civil::Date::at"><code>Date::at</code></a>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This routine panics when <a href="struct.DateTime.html#method.new" title="associated function jiff::civil::DateTime::new"><code>DateTime::new</code></a> would return an error. That
is, when the given components do not correspond to a valid datetime.
Namely, all of the following must be true:</p>
<ul>
<li>The year must be in the range <code>-9999..=9999</code>.</li>
<li>The month must be in the range <code>1..=12</code>.</li>
<li>The day must be at least <code>1</code> and must be at most the number of days
in the corresponding month. So for example, <code>2024-02-29</code> is valid but
<code>2023-02-29</code> is not.</li>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<p>Similarly, when used in a const context, invalid parameters will
prevent your Rust program from compiling.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>dt = DateTime::constant(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.year(), <span class="number">2024</span>);
<span class="macro">assert_eq!</span>(dt.month(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(dt.day(), <span class="number">29</span>);
<span class="macro">assert_eq!</span>(dt.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(dt.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(dt.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(dt.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(dt.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(dt.nanosecond(), <span class="number">789</span>);</code></pre></div>
<p>Or alternatively:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.year(), <span class="number">2024</span>);
<span class="macro">assert_eq!</span>(dt.month(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(dt.day(), <span class="number">29</span>);
<span class="macro">assert_eq!</span>(dt.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(dt.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(dt.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(dt.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(dt.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(dt.nanosecond(), <span class="number">789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_parts" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#407-409">Source</a><h4 class="code-header">pub const fn <a href="#method.from_parts" class="fn">from_parts</a>(date: <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a>, time: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Creates a <code>DateTime</code> from its constituent parts.</p>
<p>Any combination of a valid <code>Date</code> and a valid <code>Time</code> results in a valid
<code>DateTime</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This example shows how to build a datetime from its parts:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date, time};

<span class="kw">let </span>dt = DateTime::from_parts(date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">6</span>), time(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(dt, date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">6</span>).at(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#443-445">Source</a><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>(self) -&gt; <a class="struct" href="struct.DateTimeWith.html" title="struct jiff::civil::DateTimeWith">DateTimeWith</a></h4></section></summary><div class="docblock"><p>Create a builder for constructing a new <code>DateTime</code> from the fields of
this datetime.</p>
<p>See the methods on <a href="struct.DateTimeWith.html" title="struct jiff::civil::DateTimeWith"><code>DateTimeWith</code></a> for the different ways one can set
the fields of a new <code>DateTime</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>The builder ensures one can chain together the individual components of
a datetime without it failing at an intermediate step. For example, if
you had a date of <code>2024-10-31T00:00:00</code> and wanted to change both the
day and the month, and each setting was validated independent of the
other, you would need to be careful to set the day first and then the
month. In some cases, you would need to set the month first and then
the day!</p>
<p>But with the builder, you can set values in any order:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = dt1.with().month(<span class="number">11</span>).day(<span class="number">30</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt2, date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = dt1.with().day(<span class="number">31</span>).month(<span class="number">7</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt2, date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#466-468">Source</a><h4 class="code-header">pub fn <a href="#method.year" class="fn">year</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the year for this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>-9999..=9999</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt1.year(), <span class="number">2024</span>);

<span class="kw">let </span>dt2 = date(-<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt2.year(), -<span class="number">2024</span>);

<span class="kw">let </span>dt3 = date(<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt3.year(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.era_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#507-509">Source</a><h4 class="code-header">pub fn <a href="#method.era_year" class="fn">era_year</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>, <a class="enum" href="enum.Era.html" title="enum jiff::civil::Era">Era</a>)</h4></section></summary><div class="docblock"><p>Returns the year and its era.</p>
<p>This crate specifically allows years to be negative or <code>0</code>, where as
years written for the Gregorian calendar are always positive and
greater than <code>0</code>. In the Gregorian calendar, the era labels <code>BCE</code> and
<code>CE</code> are used to disambiguate between years less than or equal to <code>0</code>
and years greater than <code>0</code>, respectively.</p>
<p>The crate is designed this way so that years in the latest era (that
is, <code>CE</code>) are aligned with years in this crate.</p>
<p>The year returned is guaranteed to be in the range <code>1..=10000</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">2024</span>, Era::CE));

<span class="kw">let </span>dt = date(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">1</span>, Era::CE));

<span class="kw">let </span>dt = date(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">1</span>, Era::BCE));

<span class="kw">let </span>dt = date(-<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">2</span>, Era::BCE));

<span class="kw">let </span>dt = date(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">11</span>, Era::BCE));

<span class="kw">let </span>dt = date(-<span class="number">9_999</span>, <span class="number">10</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.era_year(), (<span class="number">10_000</span>, Era::BCE));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#524-526">Source</a><h4 class="code-header">pub fn <a href="#method.month" class="fn">month</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the month for this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>1..=12</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt1.month(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#541-543">Source</a><h4 class="code-header">pub fn <a href="#method.day" class="fn">day</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the day for this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>1..=31</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt1.day(), <span class="number">29</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#558-560">Source</a><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “hour” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=23</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.hour(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#575-577">Source</a><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “minute” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.minute(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#592-594">Source</a><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “second” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.second(), <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#609-611">Source</a><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “millisecond” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.millisecond(), <span class="number">123</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#626-628">Source</a><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “microsecond” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.microsecond(), <span class="number">456</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#643-645">Source</a><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “nanosecond” component of this datetime.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.nanosecond(), <span class="number">789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#697-699">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional nanosecond for this <code>DateTime</code> value.</p>
<p>If you want to set this value on <code>DateTime</code>, then use
<a href="struct.DateTimeWith.html#method.subsec_nanosecond" title="method jiff::civil::DateTimeWith::subsec_nanosecond"><code>DateTimeWith::subsec_nanosecond</code></a> via <a href="struct.DateTime.html#method.with" title="method jiff::civil::DateTime::with"><code>DateTime::with</code></a>.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999_999_999</code>.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>DateTime</code> value
with routines like <code>with().millisecond()</code> and accessing the entire
fractional part as a nanosecond:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">2</span>).at(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt1.subsec_nanosecond(), <span class="number">123_456_789</span>);
<span class="kw">let </span>dt2 = dt1.with().millisecond(<span class="number">333</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt2.subsec_nanosecond(), <span class="number">333_456_789</span>);
</code></pre></div>
<h5 id="example-nanoseconds-from-a-timestamp"><a class="doc-anchor" href="#example-nanoseconds-from-a-timestamp">§</a>Example: nanoseconds from a timestamp</h5>
<p>This shows how the fractional nanosecond part of a <code>DateTime</code> value
manifests from a specific timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, Timestamp};

<span class="comment">// 1,234 nanoseconds after the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, <span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>dt = zdt.datetime();
<span class="macro">assert_eq!</span>(dt.subsec_nanosecond(), <span class="number">1_234</span>);

<span class="comment">// 1,234 nanoseconds before the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, -<span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>dt = zdt.datetime();
<span class="comment">// The nanosecond is equal to `1_000_000_000 - 1_234`.
</span><span class="macro">assert_eq!</span>(dt.subsec_nanosecond(), <span class="number">999998766</span>);
<span class="comment">// Looking at the other components of the time value might help.
</span><span class="macro">assert_eq!</span>(dt.hour(), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(dt.minute(), <span class="number">59</span>);
<span class="macro">assert_eq!</span>(dt.second(), <span class="number">59</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weekday" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#718-720">Source</a><h4 class="code-header">pub fn <a href="#method.weekday" class="fn">weekday</a>(self) -&gt; <a class="enum" href="enum.Weekday.html" title="enum jiff::civil::Weekday">Weekday</a></h4></section></summary><div class="docblock"><p>Returns the weekday corresponding to this datetime.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// The Unix epoch was on a Thursday.
</span><span class="kw">let </span>dt = date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Thursday);
<span class="comment">// One can also get the weekday as an offset in a variety of schemes.
</span><span class="macro">assert_eq!</span>(dt.weekday().to_monday_zero_offset(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(dt.weekday().to_monday_one_offset(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(dt.weekday().to_sunday_zero_offset(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(dt.weekday().to_sunday_one_offset(), <span class="number">5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#742-744">Source</a><h4 class="code-header">pub fn <a href="#method.day_of_year" class="fn">day_of_year</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the ordinal day of the year that this datetime resides in.</p>
<p>For leap years, this always returns a value in the range <code>1..=366</code>.
Otherwise, the value is in the range <code>1..=365</code>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year(), <span class="number">236</span>);

<span class="kw">let </span>dt = date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year(), <span class="number">365</span>);

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year(), <span class="number">366</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year_no_leap" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#774-776">Source</a><h4 class="code-header">pub fn <a href="#method.day_of_year_no_leap" class="fn">day_of_year_no_leap</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the ordinal day of the year that this datetime resides in, but
ignores leap years.</p>
<p>That is, the range of possible values returned by this routine is
<code>1..=365</code>, even if this date resides in a leap year. If this date is
February 29, then this routine returns <code>None</code>.</p>
<p>The value <code>365</code> always corresponds to the last day in the year,
December 31, even for leap years.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">236</span>));

<span class="kw">let </span>dt = date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">365</span>));

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year_no_leap(), <span class="prelude-val">Some</span>(<span class="number">365</span>));

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.day_of_year_no_leap(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.start_of_day" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#792-794">Source</a><h4 class="code-header">pub fn <a href="#method.start_of_day" class="fn">start_of_day</a>(&amp;self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the beginning of the day that this datetime resides in.</p>
<p>That is, the datetime returned always keeps the same date, but its
time is always <code>00:00:00</code> (midnight).</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(dt.start_of_day(), date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.end_of_day" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#813-815">Source</a><h4 class="code-header">pub fn <a href="#method.end_of_day" class="fn">end_of_day</a>(&amp;self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the end of the day that this datetime resides in.</p>
<p>That is, the datetime returned always keeps the same date, but its
time is always <code>23:59:59.999999999</code>.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(
    dt.end_of_day(),
    date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">3</span>).at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first_of_month" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#830-832">Source</a><h4 class="code-header">pub fn <a href="#method.first_of_month" class="fn">first_of_month</a>(self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the first date of the month that this datetime resides in.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.first_of_month(), date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_of_month" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#847-849">Source</a><h4 class="code-header">pub fn <a href="#method.last_of_month" class="fn">last_of_month</a>(self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the last date of the month that this datetime resides in.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">5</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.last_of_month(), date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.days_in_month" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#872-874">Source</a><h4 class="code-header">pub fn <a href="#method.days_in_month" class="fn">days_in_month</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the total number of days in the the month in which this
datetime resides.</p>
<p>This is guaranteed to always return one of the following values,
depending on the year and the month: 28, 29, 30 or 31.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.days_in_month(), <span class="number">29</span>);

<span class="kw">let </span>dt = date(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.days_in_month(), <span class="number">28</span>);

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.days_in_month(), <span class="number">31</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first_of_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#889-891">Source</a><h4 class="code-header">pub fn <a href="#method.first_of_year" class="fn">first_of_year</a>(self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the first date of the year that this datetime resides in.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.first_of_year(), date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_of_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#906-908">Source</a><h4 class="code-header">pub fn <a href="#method.last_of_year" class="fn">last_of_year</a>(self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the last date of the year that this datetime resides in.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">5</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.last_of_year(), date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.days_in_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#927-929">Source</a><h4 class="code-header">pub fn <a href="#method.days_in_year" class="fn">days_in_year</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the total number of days in the the year in which this datetime
resides.</p>
<p>This is guaranteed to always return either <code>365</code> or <code>366</code>.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.days_in_year(), <span class="number">366</span>);

<span class="kw">let </span>dt = date(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.days_in_year(), <span class="number">365</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.in_leap_year" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#943-945">Source</a><h4 class="code-header">pub fn <a href="#method.in_leap_year" class="fn">in_leap_year</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the year in which this datetime resides is
a leap year.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="macro">assert!</span>(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_leap_year());
<span class="macro">assert!</span>(!date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_leap_year());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.tomorrow" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#969-971">Source</a><h4 class="code-header">pub fn <a href="#method.tomorrow" class="fn">tomorrow</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the datetime with a date immediately following this one.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when this datetime’s date is the maximum value.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">28</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.tomorrow()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// The max doesn't have a tomorrow.
</span><span class="macro">assert!</span>(DateTime::MAX.tomorrow().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.yesterday" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#995-997">Source</a><h4 class="code-header">pub fn <a href="#method.yesterday" class="fn">yesterday</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the datetime with a date immediately preceding this one.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when this datetime’s date is the minimum value.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.yesterday()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// The min doesn't have a yesterday.
</span><span class="macro">assert!</span>(DateTime::MIN.yesterday().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nth_weekday_of_month" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1064-1071">Source</a><h4 class="code-header">pub fn <a href="#method.nth_weekday_of_month" class="fn">nth_weekday_of_month</a>(
    self,
    nth: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    weekday: <a class="enum" href="enum.Weekday.html" title="enum jiff::civil::Weekday">Weekday</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the “nth” weekday from the beginning or end of the month in
which this datetime resides.</p>
<p>The <code>nth</code> parameter can be positive or negative. A positive value
computes the “nth” weekday from the beginning of the month. A negative
value computes the “nth” weekday from the end of the month. So for
example, use <code>-1</code> to “find the last weekday” in this date’s month.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when <code>nth</code> is <code>0</code>, or if it is <code>5</code> or <code>-5</code> and
there is no 5th weekday from the beginning or end of the month.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<p>This shows how to get the nth weekday in a month, starting from the
beginning of the month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>dt = date(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>second_friday = dt.nth_weekday_of_month(<span class="number">2</span>, Weekday::Friday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(second_friday, date(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>This shows how to do the reverse of the above. That is, the nth <em>last</em>
weekday in a month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>last_thursday = dt.nth_weekday_of_month(-<span class="number">1</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(last_thursday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">28</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="kw">let </span>second_last_thursday = dt.nth_weekday_of_month(
    -<span class="number">2</span>,
    Weekday::Thursday,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(second_last_thursday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">21</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>This routine can return an error if there isn’t an <code>nth</code> weekday
for this month. For example, March 2024 only has 4 Mondays:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>fourth_monday = dt.nth_weekday_of_month(<span class="number">4</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(fourth_monday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">25</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// There is no 5th Monday.
</span><span class="macro">assert!</span>(dt.nth_weekday_of_month(<span class="number">5</span>, Weekday::Monday).is_err());
<span class="comment">// Same goes for counting backwards.
</span><span class="macro">assert!</span>(dt.nth_weekday_of_month(-<span class="number">5</span>, Weekday::Monday).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nth_weekday" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1222-1229">Source</a><h4 class="code-header">pub fn <a href="#method.nth_weekday" class="fn">nth_weekday</a>(self, nth: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>, weekday: <a class="enum" href="enum.Weekday.html" title="enum jiff::civil::Weekday">Weekday</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the “nth” weekday from this datetime, not including itself.</p>
<p>The <code>nth</code> parameter can be positive or negative. A positive value
computes the “nth” weekday starting at the day after this date and
going forwards in time. A negative value computes the “nth” weekday
starting at the day before this date and going backwards in time.</p>
<p>For example, if this datetime’s weekday is a Sunday and the first
Sunday is asked for (that is, <code>dt.nth_weekday(1, Weekday::Sunday)</code>),
then the result is a week from this datetime corresponding to the
following Sunday.</p>
<p>The time in the datetime returned remains unchanged.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when <code>nth</code> is <code>0</code>, or if it would otherwise
result in a date that overflows the minimum/maximum values of
<code>DateTime</code>.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<p>This example shows how to find the “nth” weekday going forwards in
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// Use a Sunday in March as our start date.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Sunday);

<span class="comment">// The first next Monday is tomorrow!
</span><span class="kw">let </span>next_monday = dt.nth_weekday(<span class="number">1</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(next_monday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// But the next Sunday is a week away, because this doesn't
// include the current weekday.
</span><span class="kw">let </span>next_sunday = dt.nth_weekday(<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(next_sunday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">17</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// "not this Thursday, but next Thursday"
</span><span class="kw">let </span>next_next_thursday = dt.nth_weekday(<span class="number">2</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(next_next_thursday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">21</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>This example shows how to find the “nth” weekday going backwards in
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="comment">// Use a Sunday in March as our start date.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Sunday);

<span class="comment">// "last Saturday" was yesterday!
</span><span class="kw">let </span>last_saturday = dt.nth_weekday(-<span class="number">1</span>, Weekday::Saturday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(last_saturday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// "last Sunday" was a week ago.
</span><span class="kw">let </span>last_sunday = dt.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(last_sunday, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// "not last Thursday, but the one before"
</span><span class="kw">let </span>prev_prev_thursday = dt.nth_weekday(-<span class="number">2</span>, Weekday::Thursday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(prev_prev_thursday, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>This example shows that overflow results in an error in either
direction:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, Weekday};

<span class="kw">let </span>dt = DateTime::MAX;
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Friday);
<span class="macro">assert!</span>(dt.nth_weekday(<span class="number">1</span>, Weekday::Saturday).is_err());

<span class="kw">let </span>dt = DateTime::MIN;
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Monday);
<span class="macro">assert!</span>(dt.nth_weekday(-<span class="number">1</span>, Weekday::Sunday).is_err());</code></pre></div>
<h5 id="example-the-start-of-israeli-summer-time"><a class="doc-anchor" href="#example-the-start-of-israeli-summer-time">§</a>Example: the start of Israeli summer time</h5>
<p>Israeli law says (at present, as of 2024-03-11) that DST or
“summer time” starts on the Friday before the last Sunday in
March. We can find that date using both <code>nth_weekday</code> and
<a href="struct.DateTime.html#method.nth_weekday_of_month" title="method jiff::civil::DateTime::nth_weekday_of_month"><code>DateTime::nth_weekday_of_month</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>march = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>last_sunday = march.nth_weekday_of_month(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="kw">let </span>dst_starts_on = last_sunday.nth_weekday(-<span class="number">1</span>, Weekday::Friday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dst_starts_on, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">29</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-getting-the-start-of-the-week"><a class="doc-anchor" href="#example-getting-the-start-of-the-week">§</a>Example: getting the start of the week</h5>
<p>Given a date, one can use <code>nth_weekday</code> to determine the start of the
week in which the date resides in. This might vary based on whether
the weeks start on Sunday or Monday. This example shows how to handle
both.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Weekday, date};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="comment">// For weeks starting with Sunday.
</span><span class="kw">let </span>start_of_week = dt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(start_of_week, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// For weeks starting with Monday.
</span><span class="kw">let </span>start_of_week = dt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Monday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(start_of_week, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">11</span>).at(<span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>In the above example, we first get the date after the current one
because <code>nth_weekday</code> does not consider itself when counting. This
works as expected even at the boundaries of a week:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Time, Weekday, date};

<span class="comment">// The start of the week.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>start_of_week = dt.tomorrow()<span class="question-mark">?</span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(start_of_week, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// The end of the week.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">16</span>).at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="kw">let </span>start_of_week = dt
    .tomorrow()<span class="question-mark">?
    </span>.nth_weekday(-<span class="number">1</span>, Weekday::Sunday)<span class="question-mark">?
    </span>.with().time(Time::midnight()).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(start_of_week, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.date" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1242-1244">Source</a><h4 class="code-header">pub fn <a href="#method.date" class="fn">date</a>(self) -&gt; <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class="docblock"><p>Returns the date component of this datetime.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.date(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.time" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1257-1259">Source</a><h4 class="code-header">pub fn <a href="#method.time" class="fn">time</a>(self) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Returns the time component of this datetime.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{date, time};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.time(), time(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week_date" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1317-1319">Source</a><h4 class="code-header">pub fn <a href="#method.iso_week_date" class="fn">iso_week_date</a>(self) -&gt; <a class="struct" href="struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate">ISOWeekDate</a></h4></section></summary><div class="docblock"><p>Construct an <a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO 8601 week date</a> from this datetime.</p>
<p>The <a href="struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate"><code>ISOWeekDate</code></a> type describes itself in more detail, but in
brief, the ISO week date calendar system eschews months in favor of
weeks.</p>
<p>This routine is equivalent to
<a href="struct.ISOWeekDate.html#method.from_date" title="associated function jiff::civil::ISOWeekDate::from_date"><code>ISOWeekDate::from_date(dt.date())</code></a>.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<p>This shows a number of examples demonstrating the conversion from a
Gregorian date to an ISO 8601 week date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Date, Time, Weekday, date};

<span class="kw">let </span>dt = date(<span class="number">1995</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">1994</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">52</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Sunday);

<span class="kw">let </span>dt = date(<span class="number">1996</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">1997</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Tuesday);

<span class="kw">let </span>dt = date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">30</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">2020</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Monday);

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">18</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">2024</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Saturday);

<span class="kw">let </span>dt = Date::MIN.to_datetime(Time::MIN);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), -<span class="number">9999</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Monday);

<span class="kw">let </span>dt = Date::MAX.to_datetime(Time::MAX);
<span class="kw">let </span>weekdate = dt.iso_week_date();
<span class="macro">assert_eq!</span>(weekdate.year(), <span class="number">9999</span>);
<span class="macro">assert_eq!</span>(weekdate.week(), <span class="number">52</span>);
<span class="macro">assert_eq!</span>(weekdate.weekday(), Weekday::Friday);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.in_tz" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1448-1451">Source</a><h4 class="code-header">pub fn <a href="#method.in_tz" class="fn">in_tz</a>(self, time_zone_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a civil datetime to a <a href="../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> datetime by adding the given
time zone.</p>
<p>The name given is resolved to a <a href="../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a> by using the default
<a href="../tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase"><code>TimeZoneDatabase</code></a> created by
<a href="../tz/fn.db.html" title="fn jiff::tz::db"><code>tz::db</code></a>. Indeed, this is a convenience function for
<a href="struct.DateTime.html#method.to_zoned" title="method jiff::civil::DateTime::to_zoned"><code>DateTime::to_zoned</code></a> where the time zone database lookup is done
automatically.</p>
<p>In some cases, a civil datetime may be ambiguous in a
particular time zone. This routine automatically utilizes the
<a href="../tz/enum.Disambiguation.html" title="enum jiff::tz::Disambiguation"><code>Disambiguation::Compatible</code></a> strategy
for resolving ambiguities. That is, if a civil datetime occurs in a
backward transition (called a fold), then the earlier time is selected.
Or if a civil datetime occurs in a forward transition (called a gap),
then the later time is selected.</p>
<p>To convert a datetime to a <code>Zoned</code> using a different disambiguation
strategy, use <a href="../tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method jiff::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a>.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error when the given time zone name could not be found
in the default time zone database.</p>
<p>This also returns an error if this datetime could not be represented as
an instant. This can occur in some cases near the minimum and maximum
boundaries of a <code>DateTime</code>.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<p>This is a simple example of converting a civil datetime (a “wall” or
“local” or “naive” datetime) to a datetime that is aware of its time
zone:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>dt: DateTime = <span class="string">"2024-06-20 15:06"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = dt.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-06-20T15:06:00-04:00[America/New_York]"</span>);
</code></pre></div>
<h5 id="example-dealing-with-ambiguity"><a class="doc-anchor" href="#example-dealing-with-ambiguity">§</a>Example: dealing with ambiguity</h5>
<p>In the <code>America/New_York</code> time zone, there was a forward transition
at <code>2024-03-10 02:00:00</code> civil time, and a backward transition at
<code>2024-11-03 01:00:00</code> civil time. In the former case, a gap was
created such that the 2 o’clock hour never appeared on clocks for folks
in the <code>America/New_York</code> time zone. In the latter case, a fold was
created such that the 1 o’clock hour was repeated. Thus, March 10, 2024
in New York was 23 hours long, while November 3, 2024 in New York was
25 hours long.</p>
<p>This example shows how datetimes in these gaps and folds are resolved
by default:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="comment">// This is the gap, where by default we select the later time.
</span><span class="kw">let </span>dt: DateTime = <span class="string">"2024-03-10 02:30"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = dt.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-03-10T03:30:00-04:00[America/New_York]"</span>);

<span class="comment">// This is the fold, where by default we select the earlier time.
</span><span class="kw">let </span>dt: DateTime = <span class="string">"2024-11-03 01:30"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = dt.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// Since this is a fold, the wall clock time is repeated. It might be
// hard to see that this is the earlier time, but notice the offset:
// it is the offset for DST time in New York. The later time, or the
// repetition of the 1 o'clock hour, would occur in standard time,
// which is an offset of -05 for New York.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-11-03T01:30:00-04:00[America/New_York]"</span>);
</code></pre></div>
<h5 id="example-errors"><a class="doc-anchor" href="#example-errors">§</a>Example: errors</h5>
<p>This routine can return an error when the time zone is unrecognized:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">15</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(dt.in_tz(<span class="string">"does not exist"</span>).is_err());</code></pre></div>
<p>Note that even if a time zone exists in, say, the IANA database, there
may have been a problem reading it from your system’s installation of
that database. To see what wrong, enable Jiff’s <code>logging</code> crate feature
and install a logger. If there was a failure, then a <code>WARN</code> level log
message should be emitted.</p>
<p>This routine can also fail if this datetime cannot be represented
within the allowable timestamp limits:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::DateTime, tz::{Offset, TimeZone}};

<span class="kw">let </span>dt = DateTime::MAX;
<span class="comment">// All errors because the combination of the offset and the datetime
// isn't enough to fit into timestamp limits.
</span><span class="macro">assert!</span>(dt.in_tz(<span class="string">"UTC"</span>).is_err());
<span class="macro">assert!</span>(dt.in_tz(<span class="string">"America/New_York"</span>).is_err());
<span class="macro">assert!</span>(dt.in_tz(<span class="string">"Australia/Tasmania"</span>).is_err());
<span class="comment">// In fact, the only valid offset one can use to turn the maximum civil
// datetime into a Zoned value is the maximum offset:
</span><span class="kw">let </span>tz = Offset::from_seconds(<span class="number">93_599</span>).unwrap().to_time_zone();
<span class="macro">assert!</span>(dt.to_zoned(tz).is_ok());
<span class="comment">// One second less than the maximum offset results in a failure at the
// maximum datetime boundary.
</span><span class="kw">let </span>tz = Offset::from_seconds(<span class="number">93_598</span>).unwrap().to_time_zone();
<span class="macro">assert!</span>(dt.to_zoned(tz).is_err());</code></pre></div>
<p>This behavior exists because it guarantees that every possible <code>Zoned</code>
value can be converted into a civil datetime, but not every possible
combination of civil datetime and offset can be converted into a
<code>Zoned</code> value. There isn’t a way to make every possible roundtrip
lossless in both directions, so Jiff chooses to ensure that there is
always a way to convert a <code>Zoned</code> instant to a human readable wall
clock time.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1516-1573">Source</a><h4 class="code-header">pub fn <a href="#method.to_zoned" class="fn">to_zoned</a>(self, tz: <a class="struct" href="../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone">TimeZone</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a civil datetime to a <a href="../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> datetime by adding the given
<a href="../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a>.</p>
<p>In some cases, a civil datetime may be ambiguous in a
particular time zone. This routine automatically utilizes the
<a href="../tz/enum.Disambiguation.html" title="enum jiff::tz::Disambiguation"><code>Disambiguation::Compatible</code></a> strategy
for resolving ambiguities. That is, if a civil datetime occurs in a
backward transition (called a fold), then the earlier time is selected.
Or if a civil datetime occurs in a forward transition (called a gap),
then the later time is selected.</p>
<p>To convert a datetime to a <code>Zoned</code> using a different disambiguation
strategy, use <a href="../tz/struct.TimeZone.html#method.to_ambiguous_zoned" title="method jiff::tz::TimeZone::to_ambiguous_zoned"><code>TimeZone::to_ambiguous_zoned</code></a>.</p>
<p>In the common case of a time zone being represented as a name string,
like <code>Australia/Tasmania</code>, consider using <a href="struct.DateTime.html#method.in_tz" title="method jiff::civil::DateTime::in_tz"><code>DateTime::in_tz</code></a>
instead.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error if this datetime could not be represented as an
instant. This can occur in some cases near the minimum and maximum
boundaries of a <code>DateTime</code>.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<p>This example shows how to create a zoned value with a fixed time zone
offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{<span class="self">self</span>, TimeZone}};

<span class="kw">let </span>tz = TimeZone::fixed(tz::offset(-<span class="number">4</span>));
<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">17</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz)<span class="question-mark">?</span>;
<span class="comment">// A time zone annotation is still included in the printable version
// of the Zoned value, but it is fixed to a particular offset.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-06-20T17:03:00-04:00[-04:00]"</span>);
</code></pre></div>
<h5 id="example-posix-time-zone-strings"><a class="doc-anchor" href="#example-posix-time-zone-strings">§</a>Example: POSIX time zone strings</h5>
<p>And this example shows how to create a time zone from a POSIX time
zone string that describes the transition to and from daylight saving
time for <code>America/St_Johns</code>. In particular, this rule uses non-zero
minutes, which is atypical.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::TimeZone};

<span class="kw">let </span>tz = TimeZone::posix(<span class="string">"NST3:30NDT,M3.2.0,M11.1.0"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">17</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>).to_zoned(tz)<span class="question-mark">?</span>;
<span class="comment">// There isn't any agreed upon mechanism for transmitting a POSIX time
// zone string within an RFC 9557 TZ annotation, so Jiff just emits the
// offset. In practice, POSIX TZ strings are rarely user facing anyway.
// (They are still in widespread use as an implementation detail of the
// IANA Time Zone Database however.)
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-06-20T17:03:00-02:30[-02:30]"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1682-1688">Source</a><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Add the given span of time to this datetime. If the sum would overflow
the minimum or maximum datetime values, then an error is returned.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic"><code>DateTimeArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>This routine is <em>not</em> reversible because some additions may
be ambiguous. For example, adding <code>1 month</code> to the datetime
<code>2024-03-31T00:00:00</code> will produce <code>2024-04-30T00:00:00</code> since April
has only 30 days in a month. Moreover, subtracting <code>1 month</code> from
<code>2024-04-30T00:00:00</code> will produce <code>2024-03-30T00:00:00</code>, which is not
the date we started with.</p>
<p>If spans of time are limited to units of days (or less), then this
routine <em>is</em> reversible. This also implies that all operations with a
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> or a <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a> are reversible.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>If the span added to this datetime would result in a datetime that
exceeds the range of a <code>DateTime</code>, then this will return an error.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<p>This shows a few examples of adding spans of time to various dates.
We make use of the <a href="../trait.ToSpan.html" title="trait jiff::ToSpan"><code>ToSpan</code></a> trait for convenient
creation of spans.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>);
<span class="kw">let </span>got = dt.checked_add(<span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(got, date(<span class="number">2016</span>, <span class="number">4</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">4_000</span>));

<span class="kw">let </span>dt = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>got = dt.checked_add(<span class="number">1</span>.months())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(got, date(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">28</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator. Note though that if it
fails, it will result in a panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>);
<span class="kw">let </span>got = dt + <span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>);
<span class="macro">assert_eq!</span>(got, date(<span class="number">2016</span>, <span class="number">4</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">4_000</span>));</code></pre></div>
<h5 id="example-negative-spans-are-supported"><a class="doc-anchor" href="#example-negative-spans-are-supported">§</a>Example: negative spans are supported</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">19</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    dt.checked_add(-<span class="number">1</span>.months())<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">19</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
</code></pre></div>
<h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);
<span class="macro">assert!</span>(dt.checked_add(<span class="number">9000</span>.years()).is_err());
<span class="macro">assert!</span>(dt.checked_add(-<span class="number">19000</span>.years()).is_err());</code></pre></div>
<h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>DateTime</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>dur = SignedDuration::from_hours(<span class="number">25</span>);
<span class="macro">assert_eq!</span>(dt.checked_add(dur)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(dt.checked_add(-dur)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">27</span>).at(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="kw">let </span>dur = Duration::from_secs(<span class="number">25 </span>* <span class="number">60 </span>* <span class="number">60</span>);
<span class="macro">assert_eq!</span>(dt.checked_add(dur)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).at(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// One cannot negate an unsigned duration,
// but you can subtract it!
</span><span class="macro">assert_eq!</span>(dt.checked_sub(dur)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">27</span>).at(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1796-1802">Source</a><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a> with the
duration negated.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Note though that if it
fails, it will result in a panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::date, SignedDuration, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_500</span>);
<span class="macro">assert_eq!</span>(
    dt - <span class="number">20</span>.years().months(<span class="number">4</span>).nanoseconds(<span class="number">500</span>),
    date(<span class="number">1975</span>, <span class="number">8</span>, <span class="number">7</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3_000</span>),
);

<span class="kw">let </span>dur = SignedDuration::new(<span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>, <span class="number">3_500</span>);
<span class="macro">assert_eq!</span>(dt - dur, date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">6</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">0</span>));

<span class="kw">let </span>dur = Duration::new(<span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>, <span class="number">3_500</span>);
<span class="macro">assert_eq!</span>(dt - dur, date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">6</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1821-1833">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.DateTime.html#associatedconstant.MIN" title="associated constant jiff::civil::DateTime::MIN"><code>DateTime::MIN</code></a> or <a href="struct.DateTime.html#associatedconstant.MAX" title="associated constant jiff::civil::DateTime::MAX"><code>DateTime::MAX</code></a> is returned.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTime, date}, SignedDuration, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);
<span class="macro">assert_eq!</span>(DateTime::MAX, dt.saturating_add(<span class="number">9000</span>.years()));
<span class="macro">assert_eq!</span>(DateTime::MIN, dt.saturating_add(-<span class="number">19000</span>.years()));
<span class="macro">assert_eq!</span>(DateTime::MAX, dt.saturating_add(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(DateTime::MIN, dt.saturating_add(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(DateTime::MAX, dt.saturating_add(std::time::Duration::MAX));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#1851-1860">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.DateTime.html#method.saturating_add" title="method jiff::civil::DateTime::saturating_add"><code>DateTime::saturating_add</code></a> with the span
parameter negated.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTime, date}, SignedDuration, ToSpan};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">31</span>).at(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);
<span class="macro">assert_eq!</span>(DateTime::MIN, dt.saturating_sub(<span class="number">19000</span>.years()));
<span class="macro">assert_eq!</span>(DateTime::MAX, dt.saturating_sub(-<span class="number">9000</span>.years()));
<span class="macro">assert_eq!</span>(DateTime::MIN, dt.saturating_sub(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(DateTime::MAX, dt.saturating_sub(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(DateTime::MIN, dt.saturating_sub(std::time::Duration::MAX));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2014-2025">Source</a><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference">DateTimeDifference</a>&gt;&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this datetime until
the given <code>other</code> datetime.</p>
<p>When <code>other</code> occurs before this datetime, then the span returned will
be negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced up to bigger units than the default. By default, the
span returned is balanced such that the biggest possible unit is days.
This default is an API guarantee. Users can rely on the default not
returning any calendar units bigger than days in the default
configuration.</p>
<p>This operation is configured by providing a <a href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference"><code>DateTimeDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;DateTimeDifference&gt;</code>, once can pass a <code>DateTime</code> directly.
One can also pass a <code>(Unit, DateTime)</code>, where <code>Unit</code> is treated as
<a href="struct.DateTimeDifference.html#method.largest" title="method jiff::civil::DateTimeDifference::largest"><code>DateTimeDifference::largest</code></a>.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>It is guaranteed that if the returned span is subtracted from <code>other</code>,
and if no rounding is requested, and if the largest unit requested is
at most <code>Unit::Day</code>, then the original datetime will be returned.</p>
<p>This routine is equivalent to <code>self.since(other).map(|span| -span)</code>
if no rounding options are set. If rounding options are set, then
it’s equivalent to
<code>self.since(other_without_rounding_options).map(|span| -span)</code>,
followed by a call to <a href="../struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> with the appropriate rounding
options set. This is because the negation of a span can result in
different rounding results depending on the rounding mode.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>An error can occur in some cases when the requested configuration would
result in a span that is beyond allowable limits. For example, the
nanosecond component of a span cannot the span of time between the
minimum and maximum datetime supported by Jiff. Therefore, if one
requests a span with its largest unit set to <a href="../enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then
it’s possible for this routine to fail.</p>
<p>It is guaranteed that if one provides a datetime with the default
<a href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference"><code>DateTimeDifference</code></a> configuration, then this routine will never
fail.</p>
<h5 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    earlier.until(later)<span class="question-mark">?</span>,
    <span class="number">4542</span>.days().hours(<span class="number">22</span>).minutes(<span class="number">30</span>).fieldwise(),
);

<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(
    later.until(earlier)<span class="question-mark">?</span>,
    -<span class="number">4542</span>.days().hours(<span class="number">22</span>).minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<h5 id="example-using-bigger-units"><a class="doc-anchor" href="#example-using-bigger-units">§</a>Example: using bigger units</h5>
<p>This example shows how to expand the span returned to bigger units.
This makes use of a <code>From&lt;(Unit, DateTime)&gt; for DateTimeDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ToSpan};

<span class="kw">let </span>dt1 = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">07</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2019</span>, <span class="number">01</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// The default limits durations to using "days" as the biggest unit.
</span><span class="kw">let </span>span = dt1.until(dt2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P8456DT12H5M29.9999965S"</span>);

<span class="comment">// But we can ask for units all the way up to years.
</span><span class="kw">let </span>span = dt1.until((Unit::Year, dt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P23Y1M24DT12H5M29.9999965S"</span>);</code></pre></div>
<h5 id="example-rounding-the-result"><a class="doc-anchor" href="#example-rounding-the-result">§</a>Example: rounding the result</h5>
<p>This shows how one might find the difference between two datetimes and
have the result rounded such that sub-seconds are removed.</p>
<p>In this case, we need to hand-construct a <a href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference"><code>DateTimeDifference</code></a>
in order to gain full configurability.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTimeDifference, date}, Unit, ToSpan};

<span class="kw">let </span>dt1 = date(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">07</span>).at(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2019</span>, <span class="number">01</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>span = dt1.until(
    DateTimeDifference::from(dt2).smallest(Unit::Second),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"8456d 12h 5m 29s"</span>);

<span class="comment">// We can combine smallest and largest units too!
</span><span class="kw">let </span>span = dt1.until(
    DateTimeDifference::from(dt2)
        .smallest(Unit::Second)
        .largest(Unit::Year),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P23Y1M24DT12H5M29S"</span>);</code></pre></div>
<h5 id="example-units-biggers-than-days-inhibit-reversibility"><a class="doc-anchor" href="#example-units-biggers-than-days-inhibit-reversibility">§</a>Example: units biggers than days inhibit reversibility</h5>
<p>If you ask for units bigger than days, then subtracting the span
returned from the <code>other</code> datetime is not guaranteed to result in the
original datetime. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit, ToSpan};

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">2</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2024</span>, <span class="number">5</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>span = dt1.until((Unit::Month, dt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">1</span>.month().days(<span class="number">29</span>).fieldwise());
<span class="kw">let </span>maybe_original = dt2.checked_sub(span)<span class="question-mark">?</span>;
<span class="comment">// Not the same as the original datetime!
</span><span class="macro">assert_eq!</span>(maybe_original, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">3</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// But in the default configuration, days are always the biggest unit
// and reversibility is guaranteed.
</span><span class="kw">let </span>span = dt1.until(dt2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">60</span>.days().fieldwise());
<span class="kw">let </span>is_original = dt2.checked_sub(span)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(is_original, dt1);
</code></pre></div>
<p>This occurs because span are added as if by adding the biggest units
first, and then the smaller units. Because months vary in length,
their meaning can change depending on how the span is added. In this
case, adding one month to <code>2024-03-02</code> corresponds to 31 days, but
subtracting one month from <code>2024-05-01</code> corresponds to 30 days.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2051-2062">Source</a><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference">DateTimeDifference</a>&gt;&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>.</p>
<h5 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible datetimes, it will never panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    later - earlier,
    <span class="number">4542</span>.days().hours(<span class="number">22</span>).minutes(<span class="number">30</span>).fieldwise(),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2167-2169">Source</a><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(self, other: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
datetime until the given <code>other</code> datetime.</p>
<p>When <code>other</code> occurs before this datetime, then the duration returned
will be negative.</p>
<p>Unlike <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>, this returns a duration corresponding to a
96-bit integer of nanoseconds between two datetimes.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>
can return an error in some cases due to misconfiguration. But like
this routine, <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a> never panics or returns an error in
its default configuration.</p>
<h5 id="when-should-i-use-this-versus-datetimeuntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-datetimeuntil">§</a>When should I use this versus <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>?</h5>
<p>See the type documentation for <a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>DateTime::until</code>) unless you have
a specific reason to do otherwise.</p>
<h5 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    earlier.duration_until(later),
    SignedDuration::from_hours(<span class="number">4542 </span>* <span class="number">24</span>)
    + SignedDuration::from_hours(<span class="number">22</span>)
    + SignedDuration::from_mins(<span class="number">30</span>),
);
<span class="comment">// Flipping the datetimes is fine, but you'll get a negative duration.
</span><span class="macro">assert_eq!</span>(
    later.duration_until(earlier),
    -SignedDuration::from_hours(<span class="number">4542 </span>* <span class="number">24</span>)
    - SignedDuration::from_hours(<span class="number">22</span>)
    - SignedDuration::from_mins(<span class="number">30</span>),
);</code></pre></div>
<h5 id="example-difference-with-datetimeuntil"><a class="doc-anchor" href="#example-difference-with-datetimeuntil">§</a>Example: difference with <a href="struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a></h5>
<p>The main difference between this routine and <code>DateTime::until</code> is that
the latter can return units other than a 96-bit integer of nanoseconds.
While a 96-bit integer of nanoseconds can be converted into other units
like hours, this can only be done for uniform units. (Uniform units are
units for which each individual unit always corresponds to the same
elapsed time regardless of the datetime it is relative to.) This can’t
be done for units like years or months.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, Span, SpanRound, ToSpan, Unit};

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2025</span>, <span class="number">4</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>span = dt1.until((Unit::Year, dt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">1</span>.year().months(<span class="number">3</span>).fieldwise());

<span class="kw">let </span>duration = dt1.duration_until(dt2);
<span class="macro">assert_eq!</span>(duration, SignedDuration::from_hours(<span class="number">456 </span>* <span class="number">24</span>));
<span class="comment">// There's no way to extract years or months from the signed
// duration like one might extract hours (because every hour
// is the same length). Instead, you actually have to convert
// it to a span and then balance it by providing a relative date!
</span><span class="kw">let </span>options = SpanRound::new().largest(Unit::Year).relative(dt1);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>.round(options)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">1</span>.year().months(<span class="number">3</span>).fieldwise());
</code></pre></div>
<h5 id="example-getting-an-unsigned-duration"><a class="doc-anchor" href="#example-getting-an-unsigned-duration">§</a>Example: getting an unsigned duration</h5>
<p>If you’re looking to find the duration between two datetimes as a
<a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>, you’ll need to use this method to get a
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> and then convert it to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>duration = Duration::try_from(dt1.duration_until(dt2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, Duration::from_secs(<span class="number">31 </span>* <span class="number">24 </span>* <span class="number">60 </span>* <span class="number">60</span>));

<span class="comment">// Note that unsigned durations cannot represent all
// possible differences! If the duration would be negative,
// then the conversion fails:
</span><span class="macro">assert!</span>(Duration::try_from(dt2.duration_until(dt1)).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2189-2191">Source</a><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(self, other: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.DateTime.html#method.duration_until" title="method jiff::civil::DateTime::duration_until"><code>DateTime::duration_until</code></a>, but the
order of the parameters is flipped.</p>
<h5 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration};

<span class="kw">let </span>earlier = date(<span class="number">2006</span>, <span class="number">8</span>, <span class="number">24</span>).at(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">31</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    later.duration_since(earlier),
    SignedDuration::from_hours(<span class="number">4542 </span>* <span class="number">24</span>)
    + SignedDuration::from_hours(<span class="number">22</span>)
    + SignedDuration::from_mins(<span class="number">30</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2333-2339">Source</a><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.DateTimeRound.html" title="struct jiff::civil::DateTimeRound">DateTimeRound</a>&gt;&gt;(
    self,
    options: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Rounds this datetime according to the <a href="struct.DateTimeRound.html" title="struct jiff::civil::DateTimeRound"><code>DateTimeRound</code></a> configuration
given.</p>
<p>The principal option is <a href="struct.DateTimeRound.html#method.smallest" title="method jiff::civil::DateTimeRound::smallest"><code>DateTimeRound::smallest</code></a>, which allows one
to configure the smallest units in the returned datetime. Rounding
is what determines whether that unit should keep its current value
or whether it should be incremented. Moreover, the amount it should
be incremented can be configured via <a href="struct.DateTimeRound.html#method.increment" title="method jiff::civil::DateTimeRound::increment"><code>DateTimeRound::increment</code></a>.
Finally, the rounding strategy itself can be configured via
<a href="struct.DateTimeRound.html#method.mode" title="method jiff::civil::DateTimeRound::mode"><code>DateTimeRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;DateTimeRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for DateTimeRound</code>, which will automatically create a
<code>DateTimeRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for DateTimeRound</code>, which will automatically
create a <code>DateTimeRound::new().smallest(unit).increment(number)</code> from
the unit and increment provided.</li>
</ul>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.DateTimeRound.html" title="struct jiff::civil::DateTimeRound"><code>DateTimeRound</code></a> is bigger than days. An error is also returned if
the rounding increment is greater than 1 when the units are days.
(Currently, rounding to the nearest week, month or year is not
supported.)</p>
<p>When the smallest unit is less than days, the rounding increment must
divide evenly into the next highest unit after the smallest unit
configured (and must not be equivalent to it). For example, if the
smallest unit is <a href="../enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then <em>some</em> of the valid values
for the rounding increment are <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>, <code>100</code> and <code>500</code>.
Namely, any integer that divides evenly into <code>1,000</code> nanoseconds since
there are <code>1,000</code> nanoseconds in the next highest unit (microseconds).</p>
<p>This can also return an error in some cases where rounding would
require arithmetic that exceeds the maximum datetime value.</p>
<h5 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a datetime to the
nearest day. This also demonstrates calling this method with the
smallest unit directly, instead of constructing a <code>DateTimeRound</code>
manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.round(Unit::Day)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.round(Unit::Day)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="../enum.RoundMode.html#variant.HalfExpand" title="variant jiff::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="../enum.RoundMode.html#variant.Trunc" title="variant jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTimeRound, date}, RoundMode, Unit};

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dt.round(Unit::Day)<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">20</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// The default will round up to the next day for any time past noon,
// but using truncation rounding will always round down.
</span><span class="macro">assert_eq!</span>(
    dt.round(
        DateTimeRound::new().smallest(Unit::Day).mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    dt.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="comment">// rounds up
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    dt.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">19</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-overflow-error"><a class="doc-anchor" href="#example-overflow-error">§</a>Example: overflow error</h5>
<p>This example demonstrates that it’s possible for this operation to
result in an error from datetime arithmetic overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::DateTime, Unit};

<span class="kw">let </span>dt = DateTime::MAX;
<span class="macro">assert!</span>(dt.round(Unit::Day).is_err());</code></pre></div>
<p>This occurs because rounding to the nearest day for the maximum
datetime would result in rounding up to the next day. But the next day
is greater than the maximum, and so this returns an error.</p>
<p>If one were to use a rounding mode like <a href="../enum.RoundMode.html#variant.Trunc" title="variant jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> (which
will never round up), always set a correct increment and always used
units less than or equal to days, then this routine is guaranteed to
never fail:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTime, DateTimeRound, date}, RoundMode, Unit};

<span class="kw">let </span>round = DateTimeRound::new()
    .smallest(Unit::Day)
    .mode(RoundMode::Trunc);
<span class="macro">assert_eq!</span>(
    DateTime::MAX.round(round)<span class="question-mark">?</span>,
    date(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    DateTime::MIN.round(round)<span class="question-mark">?</span>,
    date(-<span class="number">9999</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.series" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2380-2382">Source</a><h4 class="code-header">pub fn <a href="#method.series" class="fn">series</a>(self, period: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.DateTimeSeries.html" title="struct jiff::civil::DateTimeSeries">DateTimeSeries</a> <a href="#" class="tooltip" data-notable-ty="DateTimeSeries">ⓘ</a></h4></section></summary><div class="docblock"><p>Return an iterator of periodic datetimes determined by the given span.</p>
<p>The given span may be negative, in which case, the iterator will move
backwards through time. The iterator won’t stop until either the span
itself overflows, or it would otherwise exceed the minimum or maximum
<code>DateTime</code> value.</p>
<h5 id="example-when-to-check-a-glucose-monitor"><a class="doc-anchor" href="#example-when-to-check-a-glucose-monitor">§</a>Example: when to check a glucose monitor</h5>
<p>When my cat had diabetes, my veterinarian installed a glucose monitor
and instructed me to scan it about every 5 hours. This example lists
all of the times I need to scan it for the 2 days following its
installation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::datetime, ToSpan};

<span class="kw">let </span>start = datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>end = start.checked_add(<span class="number">2</span>.days())<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>scan_times = <span class="macro">vec!</span>[];
<span class="kw">for </span>dt <span class="kw">in </span>start.series(<span class="number">5</span>.hours()).take_while(|<span class="kw-2">&amp;</span>dt| dt &lt;= end) {
    scan_times.push(dt);
}
<span class="macro">assert_eq!</span>(scan_times, <span class="macro">vec!</span>[
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    datetime(<span class="number">2023</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
]);
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DateTime-1" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2416-2487">Source</a><a href="#impl-DateTime-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Parsing and formatting using a “printf”-style API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2446-2451">Source</a><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a civil datetime in <code>input</code> matching the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a civil datetime. For example, if an offset wasn’t parsed.</p>
<h5 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h5>
<p>This example shows how to parse a civil datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::DateTime;

<span class="kw">let </span>dt = DateTime::strptime(<span class="string">"%F %H:%M"</span>, <span class="string">"2024-07-14 21:14"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt.to_string(), <span class="string">"2024-07-14T21:14:00"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2481-2486">Source</a><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F: 'f + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    format: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;'f F</a>,
) -&gt; <a class="struct" href="../fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display">Display</a>&lt;'f&gt;</h4></section></summary><div class="docblock"><p>Formats this civil datetime according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="../fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="../fmt/strtime/fn.format.html" title="fn jiff::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="../fmt/strtime/struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-47"><a class="doc-anchor" href="#example-47">§</a>Example</h5>
<p>This example shows how to format a civil datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = dt.strftime(<span class="string">"%A, %B %e, %Y at %H:%M:%S"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"Monday, July 15, 2024 at 16:24:59"</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2742-2750">Source</a><a href="#impl-Add%3CDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2743">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2746-2749">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2692-2700">Source</a><a href="#impl-Add%3CSignedDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a signed duration of time to a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2693">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2696-2699">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2620-2627">Source</a><a href="#impl-Add%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a span of time to a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2621">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2624-2626">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2756-2761">Source</a><a href="#impl-AddAssign%3CDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2758-2760">Source</a><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2706-2711">Source</a><a href="#impl-AddAssign%3CSignedDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a signed duration of time to a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2708-2710">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2633-2638">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a span of time to a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2635-2637">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-Clone-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2521-2526">Source</a><a href="#impl-Debug-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <code>DateTime</code> into a human readable datetime string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-48"><a class="doc-anchor" href="#example-48">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.6?}"</span>), <span class="string">"2024-06-15T07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.300?}"</span>), <span class="string">"2024-06-15T07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.0?}"</span>), <span class="string">"2024-06-15T07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2523-2525">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2489-2494">Source</a><a href="#impl-Default-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2491-2493">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2569-2581">Source</a><a href="#impl-Display-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <code>DateTime</code> into an ISO 8601 compliant string.</p>
</div></section></summary><div class="docblock"><h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-49"><a class="doc-anchor" href="#example-49">§</a>Example</h4>
<p>This shows the default rendering:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="comment">// No fractional seconds:
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt}"</span>), <span class="string">"2024-06-15T07:00:00"</span>);

<span class="comment">// With fractional seconds:
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt}"</span>), <span class="string">"2024-06-15T07:00:00.123"</span>);
</code></pre></div>
<h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.6}"</span>), <span class="string">"2024-06-15T07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.300}"</span>), <span class="string">"2024-06-15T07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{dt:.0}"</span>), <span class="string">"2024-06-15T07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2571-2580">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2609-2614">Source</a><a href="#impl-From%3C%26Zoned%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <a href="../struct.Zoned.html" title="struct jiff::Zoned"><code>&amp;Zoned</code></a> to a <a href="struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2611-2613">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDate%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2593-2598">Source</a><a href="#impl-From%3CDate%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <a href="struct.Date.html" title="struct jiff::civil::Date"><code>Date</code></a> to a <a href="struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> with the time set to midnight.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2595-2597">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(date: <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#2991-3006">Source</a><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#2992-3005">Source</a><a href="#method.from-9" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Date" class="impl"><a class="src rightside" href="../../src/jiff/civil/date.rs.html#2291-2296">Source</a><a href="#impl-From%3CDateTime%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/date.rs.html#2293-2295">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-DateDifference" class="impl"><a class="src rightside" href="../../src/jiff/civil/date.rs.html#3038-3043">Source</a><a href="#impl-From%3CDateTime%3E-for-DateDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.DateDifference.html" title="struct jiff::civil::DateDifference">DateDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/date.rs.html#3040-3042">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.DateDifference.html" title="struct jiff::civil::DateDifference">DateDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-DateTimeDifference" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#3296-3301">Source</a><a href="#impl-From%3CDateTime%3E-for-DateTimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference">DateTimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#3298-3300">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.DateTimeDifference.html" title="struct jiff::civil::DateTimeDifference">DateTimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-ISOWeekDate" class="impl"><a class="src rightside" href="../../src/jiff/civil/iso_week_date.rs.html#790-795">Source</a><a href="#impl-From%3CDateTime%3E-for-ISOWeekDate" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate">ISOWeekDate</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/iso_week_date.rs.html#792-794">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate">ISOWeekDate</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Pieces%3C'static%3E" class="impl"><a class="src rightside" href="../../src/jiff/fmt/temporal/pieces.rs.html#1070-1075">Source</a><a href="#impl-From%3CDateTime%3E-for-Pieces%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="../fmt/temporal/struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces">Pieces</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="../../src/jiff/fmt/temporal/pieces.rs.html#1072-1074">Source</a><a href="#method.from-10" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../fmt/temporal/struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces">Pieces</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-SpanRelativeTo%3C'static%3E" class="impl"><a class="src rightside" href="../../src/jiff/span.rs.html#5723-5727">Source</a><a href="#impl-From%3CDateTime%3E-for-SpanRelativeTo%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="../struct.SpanRelativeTo.html" title="struct jiff::SpanRelativeTo">SpanRelativeTo</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="../../src/jiff/span.rs.html#5724-5726">Source</a><a href="#method.from-11" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../struct.SpanRelativeTo.html" title="struct jiff::SpanRelativeTo">SpanRelativeTo</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2098-2103">Source</a><a href="#impl-From%3CDateTime%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2100-2102">Source</a><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-TimeDifference" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2624-2629">Source</a><a href="#impl-From%3CDateTime%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2626-2628">Source</a><a href="#method.from-8" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2601-2606">Source</a><a href="#impl-From%3CZoned%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Converts a <a href="../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> to a <a href="struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2603-2605">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2583-2590">Source</a><a href="#impl-FromStr-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2584">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2587-2589">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-Hash-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-Ord-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1013-1015">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1052-1054">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1078-1080">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-PartialEq-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-PartialOrd-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2767-2775">Source</a><a href="#impl-Sub%3CDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2768">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2771-2774">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2717-2725">Source</a><a href="#impl-Sub%3CSignedDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2718">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2721-2724">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2644-2652">Source</a><a href="#impl-Sub%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a span of time from a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2645">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2648-2651">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2679-2686">Source</a><a href="#impl-Sub-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Computes the span of time between two datetimes.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the datetime being subtracted is
greater.</p>
<p>Since this uses the default configuration for calculating a span between
two datetimes (no rounding and largest units is days), this will never
panic or fail in any way. It is guaranteed that the largest non-zero
unit in the <code>Span</code> returned will be days.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.DateTime.html#method.since" title="method jiff::civil::DateTime::since"><code>DateTime::since</code></a>.</p>
<p>If you need a <a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> representing the span between two civil
datetimes, then use <a href="struct.DateTime.html#method.duration_since" title="method jiff::civil::DateTime::duration_since"><code>DateTime::duration_since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2680">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2683-2685">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2781-2786">Source</a><a href="#impl-SubAssign%3CDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2783-2785">Source</a><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2731-2736">Source</a><a href="#impl-SubAssign%3CSignedDuration%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2733-2735">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2658-2663">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a span of time from a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#2660-2662">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><section id="impl-Copy-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-Copy-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-Eq-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-Eq-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-StructuralPartialEq-for-DateTime" class="impl"><a class="src rightside" href="../../src/jiff/civil/datetime.rs.html#219">Source</a><a href="#impl-StructuralPartialEq-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-DateTime" class="impl"><a href="#impl-Freeze-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-RefUnwindSafe-for-DateTime" class="impl"><a href="#impl-RefUnwindSafe-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-Send-for-DateTime" class="impl"><a href="#impl-Send-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-Sync-for-DateTime" class="impl"><a href="#impl-Sync-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-Unpin-for-DateTime" class="impl"><a href="#impl-Unpin-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section><section id="impl-UnwindSafe-for-DateTime" class="impl"><a href="#impl-UnwindSafe-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-12" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2806">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2808">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"DateTimeSeries":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.DateTimeSeries.html\" title=\"struct jiff::civil::DateTimeSeries\">DateTimeSeries</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.DateTimeSeries.html\" title=\"struct jiff::civil::DateTimeSeries\">DateTimeSeries</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.DateTime.html\" title=\"struct jiff::civil::DateTime\">DateTime</a>;</div>"}</script></section></div></main></body></html>