<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A representation of civil “wall clock” time."><title>Time in jiff::civil - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#civil-time" title="Civil time">Civil time</a></li><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#default-value" title="Default value">Default value</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding" title="Rounding">Rounding</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.constant" title="constant">constant</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.midnight" title="midnight">midnight</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.on" title="on">on</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.series" title="series">series</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.to_datetime" title="to_datetime">to_datetime</a></li><li><a href="#method.until" title="until">until</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.wrapping_add" title="wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_sub" title="wrapping_sub">wrapping_sub</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-Time" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-Time" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Time" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-Time" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Time" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Time" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Time" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Time" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Time" title="Default">Default</a></li><li><a href="#impl-Display-for-Time" title="Display">Display</a></li><li><a href="#impl-Eq-for-Time" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Time" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Time" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-BrokenDownTime" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-Meridiem" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-TimeDifference" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Time" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromStr-for-Time" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-Time" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-Time" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-Time" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-Time" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-Time" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sub-for-Time" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-Time" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-Time" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Time" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-Time" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Time" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Time" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Time" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Time" title="Send">Send</a></li><li><a href="#impl-Sync-for-Time" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Time" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Time" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>civil</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">jiff</a>::<wbr><a href="index.html">civil</a></div><h1>Struct <span class="struct">Time</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/jiff/civil/time.rs.html#222-227">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Time { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A representation of civil “wall clock” time.</p>
<p>Conceptually, a <code>Time</code> value corresponds to the typical hours and minutes
that you might see on a clock. This type also contains the second and
fractional subsecond (to nanosecond precision) associated with a time.</p>
<h2 id="civil-time"><a class="doc-anchor" href="#civil-time">§</a>Civil time</h2>
<p>A <code>Time</code> value behaves as if it corresponds precisely to a single
nanosecond within a day, where all days have <code>86,400</code> seconds. That is,
any given <code>Time</code> value corresponds to a nanosecond in the inclusive range
<code>[0, 86399999999999]</code>, where <code>0</code> corresponds to <code>00:00:00.000000000</code>
(<a href="struct.Time.html#associatedconstant.MIN" title="associated constant jiff::civil::Time::MIN"><code>Time::MIN</code></a>) and <code>86399999999999</code> corresponds to <code>23:59:59.999999999</code>
(<a href="struct.Time.html#associatedconstant.MAX" title="associated constant jiff::civil::Time::MAX"><code>Time::MAX</code></a>). Moreover, in civil time, all hours have the same number of
minutes, all minutes have the same number of seconds and all seconds have
the same number of nanoseconds.</p>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Time</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"15:22:45"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>A civil <code>Time</code> can also be parsed from something that <em>contains</em> a
time, but with perhaps other data (such as an offset or time zone):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"2024-06-19T15:22:45-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="../fmt/temporal/index.html" title="mod jiff::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="default-value"><a class="doc-anchor" href="#default-value">§</a>Default value</h2>
<p>For convenience, this type implements the <code>Default</code> trait. Its default
value is midnight. i.e., <code>00:00:00.000000000</code>.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a time with a second component
of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Time, time};

<span class="kw">let </span>t: Time = <span class="string">"23:59:60"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>));
</code></pre></div>
<h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>Time</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations to
facilitate easy comparisons. When a time <code>t1</code> occurs before a time <code>t2</code>,
then <code>t1 &lt; t2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">7</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">8</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t1 &lt; t2);</code></pre></div>
<p>As mentioned above, <code>Time</code> values are not associated with timezones, and
thus transitions such as DST are not taken into account when comparing
<code>Time</code> values.</p>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>Time</code> values.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.Time.html#method.wrapping_add" title="method jiff::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> or <a href="struct.Time.html#method.wrapping_sub" title="method jiff::civil::Time::wrapping_sub"><code>Time::wrapping_sub</code></a> for wrapping arithmetic.</li>
<li><a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a> or <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a> for checked arithmetic.</li>
<li><a href="struct.Time.html#method.saturating_add" title="method jiff::civil::Time::saturating_add"><code>Time::saturating_add</code></a> or <a href="struct.Time.html#method.saturating_sub" title="method jiff::civil::Time::saturating_sub"><code>Time::saturating_sub</code></a> for saturating
arithmetic.</li>
</ul>
<p>Additionally, wrapping arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>span = <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>);
<span class="macro">assert_eq!</span>(t + span, time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// Overflow will result in wrap-around unless using checked
// arithmetic explicitly.
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), t + <span class="number">1</span>.nanoseconds());</code></pre></div>
<p>Wrapping arithmetic is used by default because it corresponds to how clocks
showing the time of day behave in practice.</p>
<p>One can compute the span of time between two times using either
<a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a> or <a href="struct.Time.html#method.since" title="method jiff::civil::Time::since"><code>Time::since</code></a>. It’s also possible to subtract two
<code>Time</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>time1 = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1 - time2,
    <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>).fieldwise(),
);</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is hours
(as exemplified above), but we can ask for smaller units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.since((Unit::Minute, time2))<span class="question-mark">?</span>,
    <span class="number">990</span>.minutes().fieldwise(),
);
</code></pre></div>
<p>Or even round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeDifference, time}, RoundMode, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">23</span>, <span class="number">35</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2).smallest(Unit::Minute),
    )<span class="question-mark">?</span>,
    <span class="number">5</span>.minutes().fieldwise(),
);
<span class="comment">// `TimeDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2)
            .smallest(Unit::Minute)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 6 minutes.
    </span><span class="number">6</span>.minutes().fieldwise(),
);
</code></pre></div>
<h2 id="rounding"><a class="doc-anchor" href="#rounding">§</a>Rounding</h2>
<p>A <code>Time</code> can be rounded based on a <a href="struct.TimeRound.html" title="struct jiff::civil::TimeRound"><code>TimeRound</code></a> configuration of smallest
units, rounding increment and rounding mode. Here’s an example showing how
to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(TimeRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for TimeRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(t.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>See <a href="struct.Time.html#method.round" title="method jiff::civil::Time::round"><code>Time::round</code></a> for more details.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#229-1585">Source</a><a href="#impl-Time" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#233">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The minimum representable time value.</p>
<p>This corresponds to <code>00:00:00.000000000</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#238">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The maximum representable time value.</p>
<p>This corresponds to <code>23:59:59.999999999</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#281-293">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value from its component hour, minute, second and
fractional subsecond (up to nanosecond precision) values.</p>
<p>To set the component values of a time after creating it, use
<a href="struct.TimeWith.html" title="struct jiff::civil::TimeWith"><code>TimeWith</code></a> via <a href="struct.Time.html#method.with" title="method jiff::civil::Time::with"><code>Time::with</code></a> to build a new <a href="struct.Time.html" title="struct jiff::civil::Time"><code>Time</code></a> from the fields
of an existing time.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error unless <em>all</em> of the following conditions are
true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>This shows an example of a valid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>).unwrap();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div>
<p>This shows an example of an invalid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="macro">assert!</span>(Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">0</span>).is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.constant" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#327-351">Source</a><h4 class="code-header">pub const fn <a href="#method.constant" class="fn">constant</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>,
) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value in a <code>const</code> context.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the given values do not correspond to a valid <code>Time</code>.
All of the following conditions must be true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<p>Similarly, when used in a const context, invalid parameters will
prevent your Rust program from compiling.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This shows an example of a valid time in a <code>const</code> context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">const </span>BEDTIME: Time = Time::constant(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(BEDTIME.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(BEDTIME.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(BEDTIME.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(BEDTIME.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(BEDTIME.nanosecond(), <span class="number">789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.subsec_nanosecond(), <span class="number">123_456_789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.midnight" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#372-374">Source</a><h4 class="code-header">pub const fn <a href="#method.midnight" class="fn">midnight</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Returns the first moment of time in a day.</p>
<p>Specifically, this has the <code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code>,
<code>microsecond</code> and <code>nanosecond</code> fields all set to <code>0</code>.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::midnight();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#403-405">Source</a><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>(self) -&gt; <a class="struct" href="struct.TimeWith.html" title="struct jiff::civil::TimeWith">TimeWith</a></h4></section></summary><div class="docblock"><p>Create a builder for constructing a <code>Time</code> from the fields of this
time.</p>
<p>See the methods on <a href="struct.TimeWith.html" title="struct jiff::civil::TimeWith"><code>TimeWith</code></a> for the different ways one can set the
fields of a new <code>Time</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>Unlike <a href="struct.Date.html" title="struct jiff::civil::Date"><code>Date</code></a>, a <a href="struct.Time.html" title="struct jiff::civil::Time"><code>Time</code></a> is valid for all possible valid values
of its fields. That is, there is no way for two valid field values
to combine into an invalid <code>Time</code>. So, for <code>Time</code>, this builder does
have as much of a benefit versus an API design with methods like
<code>Time::with_hour</code> and <code>Time::with_minute</code>. Nevertheless, this builder
permits settings multiple fields at the same time and performing only
one validity check. Moreover, this provides a consistent API with other
date and time types in this crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = t1.with().hour(<span class="number">15</span>).minute(<span class="number">30</span>).millisecond(<span class="number">10</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t2, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">10_000_000</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#420-422">Source</a><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “hour” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=23</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">13</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#437-439">Source</a><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “minute” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">35</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#454-456">Source</a><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “second” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">56</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#471-473">Source</a><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “millisecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#488-490">Source</a><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “microsecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#505-507">Source</a><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “nanosecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#557-559">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional nanosecond for this <code>Time</code> value.</p>
<p>If you want to set this value on <code>Time</code>, then use
<a href="struct.TimeWith.html#method.subsec_nanosecond" title="method jiff::civil::TimeWith::subsec_nanosecond"><code>TimeWith::subsec_nanosecond</code></a> via <a href="struct.Time.html#method.with" title="method jiff::civil::Time::with"><code>Time::with</code></a>.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999_999_999</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>Time</code> value
with routines like <code>with().millisecond()</code> and accessing the entire
fractional part as a nanosecond:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).with().millisecond(<span class="number">987</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.subsec_nanosecond(), <span class="number">987_000_000</span>);
</code></pre></div>
<h5 id="example-nanoseconds-from-a-timestamp"><a class="doc-anchor" href="#example-nanoseconds-from-a-timestamp">§</a>Example: nanoseconds from a timestamp</h5>
<p>This shows how the fractional nanosecond part of a <code>Time</code> value
manifests from a specific timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, Timestamp};

<span class="comment">// 1,234 nanoseconds after the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, <span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">1_234</span>);

<span class="comment">// 1,234 nanoseconds before the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, -<span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="comment">// The nanosecond is equal to `1_000_000_000 - 1_234`.
</span><span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">999998766</span>);
<span class="comment">// Looking at the other components of the time value might help.
</span><span class="macro">assert_eq!</span>(time.hour(), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(time.minute(), <span class="number">59</span>);
<span class="macro">assert_eq!</span>(time.second(), <span class="number">59</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_datetime" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#576-578">Source</a><h4 class="code-header">pub const fn <a href="#method.to_datetime" class="fn">to_datetime</a>(self, date: <a class="struct" href="struct.Date.html" title="struct jiff::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Given a <a href="struct.Date.html" title="struct jiff::civil::Date"><code>Date</code></a>, this constructs a <a href="struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> value with its time
component equal to this time.</p>
<p>This is a convenience function for <a href="struct.DateTime.html#method.from_parts" title="associated function jiff::civil::DateTime::from_parts"><code>DateTime::from_parts</code></a>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date, time};

<span class="kw">let </span>d = date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>);
<span class="kw">let </span>t = time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(DateTime::from_parts(d, t), t.to_datetime(d));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.on" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#605-607">Source</a><h4 class="code-header">pub const fn <a href="#method.on" class="fn">on</a>(self, year: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>, month: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>, day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>A convenience function for constructing a <a href="struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> from this time
on the date given by its components.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="macro">assert_eq!</span>(
    time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div>
<p>One can also flip the order by making use of <a href="struct.Date.html#method.at" title="method jiff::civil::Date::at"><code>Date::at</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="macro">assert_eq!</span>(
    date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#703-706">Source</a><h4 class="code-header">pub fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Add the given span to this time and wrap around on overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>Given times <code>t1</code> and <code>t2</code>, and a span <code>s</code>, with <code>t2 = t1 + s</code>, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t + <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>),
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
<h5 id="example-add-nanoseconds-to-a-time"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.wrapping_add(<span class="number">2_500_000_000i64</span>.nanoseconds()),
);</code></pre></div>
<h5 id="example-add-span-with-multiple-units"><a class="doc-anchor" href="#example-add-span-with-multiple-units">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.wrapping_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>)),
);</code></pre></div>
<h5 id="example-adding-an-empty-span-is-a-no-op"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(Span::new()));</code></pre></div>
<h5 id="example-addition-wraps-on-overflow"><a class="doc-anchor" href="#example-addition-wraps-on-overflow">§</a>Example: addition wraps on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in wrapping behavior (i.e., they are
ignored):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(<span class="number">1</span>.days()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#799-802">Source</a><h4 class="code-header">pub fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.wrapping_add" title="method jiff::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> with the duration
negated.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);

<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MIN),
    time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">8</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MAX),
    time(<span class="number">8</span>, <span class="number">29</span>, <span class="number">52</span>, <span class="number">1</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::MAX),
    time(<span class="number">16</span>, <span class="number">59</span>, <span class="number">44</span>, <span class="number">1</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#931-937">Source</a><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Add the given span to this time and return an error if the result would
otherwise overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>Given a time <code>t1</code> and a span <code>s</code>, and assuming <code>t2 = t1 + s</code> exists, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to a valid <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>If the sum would overflow the minimum or maximum timestamp values, then
an error is returned.</p>
<p>If the given span has any non-zero units greater than hours, then an
error is returned.</p>
<h5 id="example-add-nanoseconds-to-a-time-1"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time-1">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.checked_add(<span class="number">2_500_000_000i64</span>.nanoseconds())<span class="question-mark">?</span>,
);</code></pre></div>
<h5 id="example-add-span-with-multiple-units-1"><a class="doc-anchor" href="#example-add-span-with-multiple-units-1">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.checked_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
);</code></pre></div>
<h5 id="example-adding-an-empty-span-is-a-no-op-1"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op-1">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.checked_add(Span::new())<span class="question-mark">?</span>);
</code></pre></div>
<h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.checked_add(<span class="number">1</span>.nanoseconds())<span class="question-mark">?</span>,
);

<span class="comment">// not okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.nanoseconds()).is_err());
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus an error):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.days()).is_err());</code></pre></div>
<h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>Time</code>. As with adding a <code>Span</code>, any overflow that occurs results in
an error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>dur = SignedDuration::from_mins(<span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(t.checked_add(-dur)<span class="question-mark">?</span>, time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="kw">let </span>dur = Duration::new(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1003-1009">Source</a><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a> with the duration
negated.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.checked_sub(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
    time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(SignedDuration::from_hours(<span class="number">1</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(Duration::from_secs(<span class="number">60 </span>* <span class="number">60</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1048-1057">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.Time.html#associatedconstant.MIN" title="associated constant jiff::civil::Time::MIN"><code>Time::MIN</code></a> or <a href="struct.Time.html#associatedconstant.MAX" title="associated constant jiff::civil::Time::MAX"><code>Time::MAX</code></a> is returned.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.saturating_add(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_add(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(std::time::Duration::MAX));
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus saturation):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.days()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1084-1088">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.saturating_add" title="method jiff::civil::Time::saturating_add"><code>Time::saturating_add</code></a> with the duration
negated.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">0</span>).build()<span class="question-mark">?</span>,
    t.saturating_sub(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_sub(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(std::time::Duration::MAX));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1247-1258">Source</a><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a>&gt;&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this time until
the given <code>other</code> time.</p>
<p>When <code>other</code> is earlier than this time, the span returned will be
negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced down to smaller units than the default. By default,
the span returned is balanced such that the biggest possible unit is
hours.</p>
<p>This operation is configured by providing a <a href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference"><code>TimeDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;TimeDifference&gt;</code>, once can pass a <code>Time</code> directly. One
can also pass a <code>(Unit, Time)</code>, where <code>Unit</code> is treated as
<a href="struct.TimeDifference.html#method.largest" title="method jiff::civil::TimeDifference::largest"><code>TimeDifference::largest</code></a>.</p>
<h5 id="properties-2"><a class="doc-anchor" href="#properties-2">§</a>Properties</h5>
<p>As long as no rounding is requested, it is guaranteed that adding the
span returned to the <code>other</code> time will always equal this time.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>An error can occur if <code>TimeDifference</code> is misconfigured. For example,
if the smallest unit provided is bigger than the largest unit, or if
the largest unit is bigger than <a href="../enum.Unit.html#variant.Hour" title="variant jiff::Unit::Hour"><code>Unit::Hour</code></a>.</p>
<p>It is guaranteed that if one provides a time with the default
<a href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference"><code>TimeDifference</code></a> configuration, then this routine will never fail.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.until(t2)<span class="question-mark">?</span>, <span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(t2.until(t1)<span class="question-mark">?</span>, -<span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
</code></pre></div>
<h5 id="example-using-smaller-units"><a class="doc-anchor" href="#example-using-smaller-units">§</a>Example: using smaller units</h5>
<p>This example shows how to contract the span returned to smaller units.
This makes use of a <code>From&lt;(Unit, Time)&gt; for TimeDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>);
<span class="kw">let </span>t2 = time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// The default limits spans to using "hours" as the biggest unit.
</span><span class="kw">let </span>span = t1.until(t2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT12H5M29.9999965S"</span>);

<span class="comment">// But we can ask for smaller units, like capping the biggest unit
// to minutes instead of hours.
</span><span class="kw">let </span>span = t1.until((Unit::Minute, t2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT725M29.9999965S"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1281-1292">Source</a><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a>&gt;&gt;(self, other: A) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible times, it will never panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(later - earlier, <span class="number">21</span>.hours().minutes(<span class="number">30</span>).fieldwise());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1393-1395">Source</a><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(self, other: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
time until the given <code>other</code> time.</p>
<p>When <code>other</code> occurs before this time, then the duration returned will
be negative.</p>
<p>Unlike <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a>, this returns a duration corresponding to a
96-bit integer of nanoseconds between two times. In this case of
computing durations between civil times where all days are assumed to
be 24 hours long, the duration returned will always be less than 24
hours.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a> can
return an error in some cases due to misconfiguration. But like this
routine, <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a> never panics or returns an error in its
default configuration.</p>
<h5 id="when-should-i-use-this-versus-timeuntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-timeuntil">§</a>When should I use this versus <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a>?</h5>
<p>See the type documentation for <a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>Time::until</code>) unless you have a
specific reason to do otherwise.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.duration_until(t2), SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));
<span class="comment">// Flipping the time is fine, but you'll get a negative duration.
</span><span class="macro">assert_eq!</span>(t2.duration_until(t1), -SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div>
<h5 id="example-difference-with-timeuntil"><a class="doc-anchor" href="#example-difference-with-timeuntil">§</a>Example: difference with <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a></h5>
<p>Since the difference between two civil times is always expressed in
units of hours or smaller, and units of hours or smaller are always
uniform, there is no “expressive” difference between this routine and
<code>Time::until</code>. The only difference is that this routine returns a
<code>SignedDuration</code> and <code>Time::until</code> returns a <a href="../struct.Span.html" title="struct jiff::Span"><code>Span</code></a>. Moreover, since
the difference is always less than 24 hours, the return values can
always be infallibly and losslessly converted between each other:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = t1.duration_until(t2);
<span class="comment">// Guaranteed to never fail because the duration
// between two civil times never exceeds the limits
// of a `Span`.
</span><span class="kw">let </span>span = Span::try_from(dur).unwrap();
<span class="macro">assert_eq!</span>(span, Span::new().seconds(<span class="number">2</span>).milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Guaranteed to succeed and always return the original
// duration because the units are always hours or smaller,
// and thus uniform. This means a relative datetime is
// never required to do this conversion.
</span><span class="kw">let </span>dur = SignedDuration::try_from(span).unwrap();
<span class="macro">assert_eq!</span>(dur, SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div>
<p>This conversion guarantee also applies to <a href="struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a> since it
always returns a balanced span. That is, it never returns spans like
<code>1 second 1000 milliseconds</code>. (Those cannot be losslessly converted to
a <code>SignedDuration</code> since a <code>SignedDuration</code> is only represented as a
single 96-bit integer of nanoseconds.)</p>
<h5 id="example-getting-an-unsigned-duration"><a class="doc-anchor" href="#example-getting-an-unsigned-duration">§</a>Example: getting an unsigned duration</h5>
<p>If you’re looking to find the duration between two times as a
<a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>, you’ll need to use this method to get a
<a href="../struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> and then convert it to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = Duration::try_from(t1.duration_until(t2))<span class="question-mark">?</span>;;
<span class="macro">assert_eq!</span>(dur, Duration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));

<span class="comment">// Note that unsigned durations cannot represent all
// possible differences! If the duration would be negative,
// then the conversion fails:
</span><span class="macro">assert!</span>(Duration::try_from(t2.duration_until(t1)).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1413-1415">Source</a><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(self, other: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.duration_until" title="method jiff::civil::Time::duration_until"><code>Time::duration_until</code></a>, but the order of
the parameters is flipped.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    later.duration_since(earlier),
    SignedDuration::from_secs((<span class="number">21 </span>* <span class="number">60 </span>* <span class="number">60</span>) + (<span class="number">30 </span>* <span class="number">60</span>)),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1531-1534">Source</a><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimeRound.html" title="struct jiff::civil::TimeRound">TimeRound</a>&gt;&gt;(self, options: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Rounds this time according to the <a href="struct.TimeRound.html" title="struct jiff::civil::TimeRound"><code>TimeRound</code></a> configuration given.</p>
<p>The principal option is <a href="struct.TimeRound.html#method.smallest" title="method jiff::civil::TimeRound::smallest"><code>TimeRound::smallest</code></a>, which allows one
to configure the smallest units in the returned time. Rounding
is what determines whether that unit should keep its current value
or whether it should be incremented. Moreover, the amount it should
be incremented can be configured via <a href="struct.TimeRound.html#method.increment" title="method jiff::civil::TimeRound::increment"><code>TimeRound::increment</code></a>.
Finally, the rounding strategy itself can be configured via
<a href="struct.TimeRound.html#method.mode" title="method jiff::civil::TimeRound::mode"><code>TimeRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;TimeRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit).increment(number)</code> from the unit
and increment provided.</li>
</ul>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.TimeRound.html" title="struct jiff::civil::TimeRound"><code>TimeRound</code></a> is bigger than hours.</p>
<p>The rounding increment must divide evenly into the next highest unit
after the smallest unit configured (and must not be equivalent to it).
For example, if the smallest unit is <a href="../enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then <em>some</em>
of the valid values for the rounding increment are <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>,
<code>100</code> and <code>500</code>. Namely, any integer that divides evenly into <code>1,000</code>
nanoseconds since there are <code>1,000</code> nanoseconds in the next highest
unit (microseconds).</p>
<p>This can never fail because of overflow for any input. The only
possible errors are “configuration” errors.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a datetime to the
nearest second. This also demonstrates calling this method with the
smallest unit directly, instead of constructing a <code>TimeRound</code> manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">500_000_001</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="../enum.RoundMode.html#variant.HalfExpand" title="variant jiff::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="../enum.RoundMode.html#variant.Trunc" title="variant jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, RoundMode, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
<span class="comment">// The default will round up to the next second for any fraction
// greater than or equal to 0.5. But truncation will always round
// toward zero.
</span><span class="macro">assert_eq!</span>(
    t.round(
        TimeRound::new().smallest(Unit::Second).mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// rounds up
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-rounding-wraps-around-on-overflow"><a class="doc-anchor" href="#example-rounding-wraps-around-on-overflow">§</a>Example: rounding wraps around on overflow</h5>
<p>This example demonstrates that it’s possible for this operation to
overflow, and as a result, have the time wrap around.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Time, Unit};

<span class="kw">let </span>t = Time::MAX;
<span class="macro">assert_eq!</span>(t.round(Unit::Hour)<span class="question-mark">?</span>, Time::MIN);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.series" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1582-1584">Source</a><h4 class="code-header">pub fn <a href="#method.series" class="fn">series</a>(self, period: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.TimeSeries.html" title="struct jiff::civil::TimeSeries">TimeSeries</a> <a href="#" class="tooltip" data-notable-ty="TimeSeries">ⓘ</a></h4></section></summary><div class="docblock"><p>Return an iterator of periodic times determined by the given span.</p>
<p>The given span may be negative, in which case, the iterator will move
backwards through time. The iterator won’t stop until either the span
itself overflows, or it would otherwise exceed the minimum or maximum
<code>Time</code> value.</p>
<h5 id="example-visiting-every-third-hour"><a class="doc-anchor" href="#example-visiting-every-third-hour">§</a>Example: visiting every third hour</h5>
<p>This shows how to visit each third hour of a 24 hour time interval:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = Time::MIN;
<span class="kw">let </span><span class="kw-2">mut </span>every_third_hour = <span class="macro">vec!</span>[];
<span class="kw">for </span>t <span class="kw">in </span>start.series(<span class="number">3</span>.hours()) {
    every_third_hour.push(t);
}
<span class="macro">assert_eq!</span>(every_third_hour, <span class="macro">vec!</span>[
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div>
<p>Or go backwards every 6.5 hours:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>times: Vec&lt;Time&gt; = start.series(-<span class="number">6</span>.hours().minutes(<span class="number">30</span>)).collect();
<span class="macro">assert_eq!</span>(times, <span class="macro">vec!</span>[
    time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Time-1" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1588-1674">Source</a><a href="#impl-Time-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Parsing and formatting using a “printf”-style API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1619-1624">Source</a><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a civil time in <code>input</code> matching the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a civil time. For example, if an offset wasn’t parsed.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This example shows how to parse a civil time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="comment">// Parse with a 12-hour clock.
</span><span class="kw">let </span>time = Time::strptime(<span class="string">"%I:%M%P"</span>, <span class="string">"4:30pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"16:30:00"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1668-1673">Source</a><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F: 'f + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    format: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;'f F</a>,
) -&gt; <a class="struct" href="../fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display">Display</a>&lt;'f&gt;</h4></section></summary><div class="docblock"><p>Formats this civil time according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="../fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="../fmt/strtime/fn.format.html" title="fn jiff::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="../fmt/strtime/struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This example shows how to format a civil time in a 12 hour clock with
no padding for the hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:30pm"</span>);</code></pre></div>
<p>Note that one can round a <code>Time</code> before formatting. For example, to
round to the nearest minute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.round(Unit::Minute)<span class="question-mark">?</span>.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:31pm"</span>);
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2056-2063">Source</a><a href="#impl-Add%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2057">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2060-2062">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2012-2019">Source</a><a href="#impl-Add%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2013">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2016-2018">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1950-1957">Source</a><a href="#impl-Add%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1951">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1954-1956">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2068-2073">Source</a><a href="#impl-AddAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2070-2072">Source</a><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2024-2029">Source</a><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2026-2028">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1962-1967">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1964-1966">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-Clone-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1878-1883">Source</a><a href="#impl-Debug-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into a human readable time string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6?}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300?}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0?}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1880-1882">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1846-1851">Source</a><a href="#impl-Default-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1848-1850">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1924-1936">Source</a><a href="#impl-Display-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into an ISO 8601 compliant string.</p>
</div></section></summary><div class="docblock"><h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="comment">// No fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00"</span>);

<span class="comment">// With fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00.123"</span>);
</code></pre></div>
<h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1926-1935">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2112-2117">Source</a><a href="#impl-From%3C%26Zoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2114-2116">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2098-2103">Source</a><a href="#impl-From%3CDateTime%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2100-2102">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#3030-3041">Source</a><a href="#impl-From%3CTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>&gt; for <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#3031-3040">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-Meridiem" class="impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#3141-3149">Source</a><a href="#impl-From%3CTime%3E-for-Meridiem" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>&gt; for <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum jiff::fmt::strtime::Meridiem">Meridiem</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../../src/jiff/fmt/strtime/mod.rs.html#3142-3148">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum jiff::fmt::strtime::Meridiem">Meridiem</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-TimeDifference" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2617-2622">Source</a><a href="#impl-From%3CTime%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>&gt; for <a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2619-2621">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(time: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.TimeDifference.html" title="struct jiff::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2105-2110">Source</a><a href="#impl-From%3CZoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2107-2109">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1938-1945">Source</a><a href="#impl-FromStr-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1939">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1942-1944">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-Hash-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-Ord-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1013-1015">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1052-1054">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1078-1080">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-PartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-PartialOrd-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2078-2085">Source</a><a href="#impl-Sub%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2079">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2082-2084">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2034-2041">Source</a><a href="#impl-Sub%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2035">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2038-2040">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1972-1979">Source</a><a href="#impl-Sub%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1973">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1976-1978">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2000-2007">Source</a><a href="#impl-Sub-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Computes the span of time between two times.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the time being subtracted is greater.</p>
<p>Since this uses the default configuration for calculating a span between
two times (no rounding and largest units is hours), this will never panic
or fail in any way.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.Time.html#method.since" title="method jiff::civil::Time::since"><code>Time::since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2001">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2004-2006">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2091-2096">Source</a><a href="#impl-SubAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time in place. This uses wrapping
arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2093-2095">Source</a><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2046-2051">Source</a><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#2048-2050">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1984-1989">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#1986-1988">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><section id="impl-Copy-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-Copy-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-Eq-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-Eq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-StructuralPartialEq-for-Time" class="impl"><a class="src rightside" href="../../src/jiff/civil/time.rs.html#221">Source</a><a href="#impl-StructuralPartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Time" class="impl"><a href="#impl-Freeze-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-RefUnwindSafe-for-Time" class="impl"><a href="#impl-RefUnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-Send-for-Time" class="impl"><a href="#impl-Send-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-Sync-for-Time" class="impl"><a href="#impl-Sync-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-Unpin-for-Time" class="impl"><a href="#impl-Unpin-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section><section id="impl-UnwindSafe-for-Time" class="impl"><a href="#impl-UnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct jiff::civil::Time">Time</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2806">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2808">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"TimeSeries":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct jiff::civil::TimeSeries\">TimeSeries</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct jiff::civil::TimeSeries\">TimeSeries</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Time.html\" title=\"struct jiff::civil::Time\">Time</a>;</div>"}</script></section></div></main></body></html>