<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A span of time represented via a mixture of calendar and clock units."><title>Span in jiff - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Span</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#range-of-spans" title="Range of spans">Range of spans</a></li><li><a href="#building-spans" title="Building spans">Building spans</a></li><li><a href="#negative-spans" title="Negative spans">Negative spans</a></li><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding-and-balancing" title="Rounding and balancing">Rounding and balancing</a></li><li><a href="#days-are-not-always-24-hours" title="Days are not always 24 hours!">Days are not always 24 hours!</a></li><li><a href="#integration-with-stdtimeduration-and-signedduration" title="Integration with `std::time::Duration` and `SignedDuration`">Integration with <code>std::time::Duration</code> and <code>SignedDuration</code></a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.abs" title="abs">abs</a></li><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_mul" title="checked_mul">checked_mul</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.compare" title="compare">compare</a></li><li><a href="#method.days" title="days">days</a></li><li><a href="#method.fieldwise" title="fieldwise">fieldwise</a></li><li><a href="#method.get_days" title="get_days">get_days</a></li><li><a href="#method.get_hours" title="get_hours">get_hours</a></li><li><a href="#method.get_microseconds" title="get_microseconds">get_microseconds</a></li><li><a href="#method.get_milliseconds" title="get_milliseconds">get_milliseconds</a></li><li><a href="#method.get_minutes" title="get_minutes">get_minutes</a></li><li><a href="#method.get_months" title="get_months">get_months</a></li><li><a href="#method.get_nanoseconds" title="get_nanoseconds">get_nanoseconds</a></li><li><a href="#method.get_seconds" title="get_seconds">get_seconds</a></li><li><a href="#method.get_weeks" title="get_weeks">get_weeks</a></li><li><a href="#method.get_years" title="get_years">get_years</a></li><li><a href="#method.hours" title="hours">hours</a></li><li><a href="#method.is_negative" title="is_negative">is_negative</a></li><li><a href="#method.is_positive" title="is_positive">is_positive</a></li><li><a href="#method.is_zero" title="is_zero">is_zero</a></li><li><a href="#method.microseconds" title="microseconds">microseconds</a></li><li><a href="#method.milliseconds" title="milliseconds">milliseconds</a></li><li><a href="#method.minutes" title="minutes">minutes</a></li><li><a href="#method.months" title="months">months</a></li><li><a href="#method.nanoseconds" title="nanoseconds">nanoseconds</a></li><li><a href="#method.negate" title="negate">negate</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.seconds" title="seconds">seconds</a></li><li><a href="#method.signum" title="signum">signum</a></li><li><a href="#method.to_duration" title="to_duration">to_duration</a></li><li><a href="#method.total" title="total">total</a></li><li><a href="#method.try_days" title="try_days">try_days</a></li><li><a href="#method.try_hours" title="try_hours">try_hours</a></li><li><a href="#method.try_microseconds" title="try_microseconds">try_microseconds</a></li><li><a href="#method.try_milliseconds" title="try_milliseconds">try_milliseconds</a></li><li><a href="#method.try_minutes" title="try_minutes">try_minutes</a></li><li><a href="#method.try_months" title="try_months">try_months</a></li><li><a href="#method.try_nanoseconds" title="try_nanoseconds">try_nanoseconds</a></li><li><a href="#method.try_seconds" title="try_seconds">try_seconds</a></li><li><a href="#method.try_weeks" title="try_weeks">try_weeks</a></li><li><a href="#method.try_years" title="try_years">try_years</a></li><li><a href="#method.weeks" title="weeks">weeks</a></li><li><a href="#method.years" title="years">years</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CSpan%3E-for-%26Zoned" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Date" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-DateTime" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Offset" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Time" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Timestamp" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Date" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-DateTime" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Offset" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Time" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Timestamp" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Zoned" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Span" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Span" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Span" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Span" title="Default">Default</a></li><li><a href="#impl-Display-for-Span" title="Display">Display</a></li><li><a href="#impl-From%3C%26Span%3E-for-DateArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-DateTimeArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-OffsetArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-SpanArithmetic%3C'static%3E" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-SpanCompare%3C'static%3E" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-TimeArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-TimestampArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3C%26Span%3E-for-ZonedArithmetic" title="From&#60;&#38;&#39;a Span&#62;">From&#60;&#38;&#39;a Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-DateArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-DateTimeArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-OffsetArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-SpanArithmetic%3C'static%3E" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-SpanCompare%3C'static%3E" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-SpanFieldwise" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-TimeArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-TimestampArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpan%3E-for-ZonedArithmetic" title="From&#60;Span&#62;">From&#60;Span&#62;</a></li><li><a href="#impl-From%3CSpanFieldwise%3E-for-Span" title="From&#60;SpanFieldwise&#62;">From&#60;SpanFieldwise&#62;</a></li><li><a href="#impl-FromStr-for-Span" title="FromStr">FromStr</a></li><li><a href="#impl-Mul%3CSpan%3E-for-i64" title="Mul&#60;Span&#62;">Mul&#60;Span&#62;</a></li><li><a href="#impl-Mul%3Ci64%3E-for-Span" title="Mul&#60;i64&#62;">Mul&#60;i64&#62;</a></li><li><a href="#impl-Neg-for-Span" title="Neg">Neg</a></li><li><a href="#impl-PartialEq%3CSpan%3E-for-SpanFieldwise" title="PartialEq&#60;Span&#62;">PartialEq&#60;Span&#62;</a></li><li><a href="#impl-PartialEq%3CSpanFieldwise%3E-for-%26Span" title="PartialEq&#60;SpanFieldwise&#62;">PartialEq&#60;SpanFieldwise&#62;</a></li><li><a href="#impl-PartialEq%3CSpanFieldwise%3E-for-Span" title="PartialEq&#60;SpanFieldwise&#62;">PartialEq&#60;SpanFieldwise&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-%26Zoned" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Date" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-DateTime" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Offset" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Time" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Timestamp" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Date" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-DateTime" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Offset" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Time" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Timestamp" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Zoned" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-TryFrom%3CDuration%3E-for-Span" title="TryFrom&#60;Duration&#62;">TryFrom&#60;Duration&#62;</a></li><li><a href="#impl-TryFrom%3CSignedDuration%3E-for-Span" title="TryFrom&#60;SignedDuration&#62;">TryFrom&#60;SignedDuration&#62;</a></li><li><a href="#impl-TryFrom%3CSpan%3E-for-Duration" title="TryFrom&#60;Span&#62;">TryFrom&#60;Span&#62;</a></li><li><a href="#impl-TryFrom%3CSpan%3E-for-SignedDuration" title="TryFrom&#60;Span&#62;">TryFrom&#60;Span&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Span" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Span" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Span" title="Send">Send</a></li><li><a href="#impl-Sync-for-Span" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Span" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Span" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate jiff</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">jiff</a></div><h1>Struct <span class="struct">Span</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/jiff/span.rs.html#710-723">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Span { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A span of time represented via a mixture of calendar and clock units.</p>
<p>A span represents a duration of time in units of years, months, weeks,
days, hours, minutes, seconds, milliseconds, microseconds and nanoseconds.
Spans are used to as inputs to routines like
<a href="struct.Zoned.html#method.checked_add" title="method jiff::Zoned::checked_add"><code>Zoned::checked_add</code></a> and <a href="civil/struct.Date.html#method.saturating_sub" title="method jiff::civil::Date::saturating_sub"><code>Date::saturating_sub</code></a>,
and are also outputs from routines like
<a href="struct.Timestamp.html#method.since" title="method jiff::Timestamp::since"><code>Timestamp::since</code></a> and <a href="civil/struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a>.</p>
<h2 id="range-of-spans"><a class="doc-anchor" href="#range-of-spans">§</a>Range of spans</h2>
<p>Except for nanoseconds, each unit can represent the full span of time
expressible via any combination of datetime supported by Jiff. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{DateTime, DateTimeDifference}, ToSpan, Unit};

<span class="kw">let </span>options = DateTimeDifference::new(DateTime::MAX).largest(Unit::Year);
<span class="macro">assert_eq!</span>(DateTime::MIN.until(options)<span class="question-mark">?</span>.get_years(), <span class="number">19_998</span>);

<span class="kw">let </span>options = options.largest(Unit::Day);
<span class="macro">assert_eq!</span>(DateTime::MIN.until(options)<span class="question-mark">?</span>.get_days(), <span class="number">7_304_483</span>);

<span class="kw">let </span>options = options.largest(Unit::Microsecond);
<span class="macro">assert_eq!</span>(
    DateTime::MIN.until(options)<span class="question-mark">?</span>.get_microseconds(),
    <span class="number">631_107_417_599_999_999i64</span>,
);

<span class="kw">let </span>options = options.largest(Unit::Nanosecond);
<span class="comment">// Span is too big, overflow!
</span><span class="macro">assert!</span>(DateTime::MIN.until(options).is_err());
</code></pre></div>
<h2 id="building-spans"><a class="doc-anchor" href="#building-spans">§</a>Building spans</h2>
<p>A default or empty span corresponds to a duration of zero time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Span;

<span class="macro">assert!</span>(Span::new().is_zero());
<span class="macro">assert!</span>(Span::default().is_zero());</code></pre></div>
<p>Spans are <code>Copy</code> types that have mutator methods on them for creating new
spans:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Span;

<span class="kw">let </span>span = Span::new().days(<span class="number">5</span>).hours(<span class="number">8</span>).minutes(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P5DT8H1M"</span>);</code></pre></div>
<p>But Jiff provides a <a href="trait.ToSpan.html" title="trait jiff::ToSpan"><code>ToSpan</code></a> trait that defines extension methods on
primitive signed integers to make span creation terser:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">5</span>.days().hours(<span class="number">8</span>).minutes(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P5DT8H1M"</span>);
<span class="comment">// singular units on integers can be used too:
</span><span class="kw">let </span>span = <span class="number">1</span>.day().hours(<span class="number">8</span>).minutes(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P1DT8H1M"</span>);</code></pre></div>
<h2 id="negative-spans"><a class="doc-anchor" href="#negative-spans">§</a>Negative spans</h2>
<p>A span may be negative. All of these are equivalent:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span = -Span::new().days(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = Span::new().days(<span class="number">5</span>).negate();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = Span::new().days(-<span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = -Span::new().days(-<span class="number">5</span>).negate();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = -<span class="number">5</span>.days();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = (-<span class="number">5</span>).days();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);

<span class="kw">let </span>span = -(<span class="number">5</span>.days());
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P5D"</span>);</code></pre></div>
<p>The sign of a span applies to the entire span. When a span is negative,
then all of its units are negative:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = -<span class="number">5</span>.days().hours(<span class="number">10</span>).minutes(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.get_days(), -<span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.get_hours(), -<span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.get_minutes(), -<span class="number">1</span>);</code></pre></div>
<p>And if any of a span’s units are negative, then the entire span is regarded
as negative:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="comment">// It's the same thing.
</span><span class="kw">let </span>span = (-<span class="number">5</span>).days().hours(-<span class="number">10</span>).minutes(-<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.get_days(), -<span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.get_hours(), -<span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.get_minutes(), -<span class="number">1</span>);

<span class="comment">// Still the same. All negative.
</span><span class="kw">let </span>span = <span class="number">5</span>.days().hours(-<span class="number">10</span>).minutes(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.get_days(), -<span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.get_hours(), -<span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.get_minutes(), -<span class="number">1</span>);

<span class="comment">// But this is not! The negation in front applies
// to the entire span, which was already negative
// by virtue of at least one of its units being
// negative. So the negation operator in front turns
// the span positive.
</span><span class="kw">let </span>span = -<span class="number">5</span>.days().hours(-<span class="number">10</span>).minutes(-<span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.get_days(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.get_hours(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.get_minutes(), <span class="number">1</span>);</code></pre></div>
<p>You can also ask for the absolute value of a span:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Span;

<span class="kw">let </span>span = Span::new().days(<span class="number">5</span>).hours(<span class="number">10</span>).minutes(<span class="number">1</span>).negate().abs();
<span class="macro">assert_eq!</span>(span.get_days(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(span.get_hours(), <span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.get_minutes(), <span class="number">1</span>);</code></pre></div>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Span</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span: Span = <span class="string">"P2m10dT2h30m"</span>.parse()<span class="question-mark">?</span>;
<span class="comment">// By default, capital unit designator labels are used.
// This can be changed with `jiff::fmt::temporal::SpanPrinter::lowercase`.
</span><span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P2M10DT2H30M"</span>);

<span class="comment">// Or use the "friendly" format by invoking the `Display` alternate:
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"2mo 10d 2h 30m"</span>);

<span class="comment">// Parsing automatically supports both the ISO 8601 and "friendly"
// formats. Note that we use `Span::fieldwise` to create a `Span` that
// compares based on each field. To compare based on total duration, use
// `Span::compare` or `Span::total`.
</span><span class="kw">let </span>span: Span = <span class="string">"2mo 10d 2h 30m"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">2</span>.months().days(<span class="number">10</span>).hours(<span class="number">2</span>).minutes(<span class="number">30</span>).fieldwise());
<span class="kw">let </span>span: Span = <span class="string">"2 months, 10 days, 2 hours, 30 minutes"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span, <span class="number">2</span>.months().days(<span class="number">10</span>).hours(<span class="number">2</span>).minutes(<span class="number">30</span>).fieldwise());
</code></pre></div>
<p>The format supported is a variation (nearly a subset) of the duration
format specified in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601</a> <em>and</em> a Jiff-specific “friendly” format.
Here are more examples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>spans = [
    <span class="comment">// ISO 8601
    </span>(<span class="string">"P40D"</span>, <span class="number">40</span>.days()),
    (<span class="string">"P1y1d"</span>, <span class="number">1</span>.year().days(<span class="number">1</span>)),
    (<span class="string">"P3dT4h59m"</span>, <span class="number">3</span>.days().hours(<span class="number">4</span>).minutes(<span class="number">59</span>)),
    (<span class="string">"PT2H30M"</span>, <span class="number">2</span>.hours().minutes(<span class="number">30</span>)),
    (<span class="string">"P1m"</span>, <span class="number">1</span>.month()),
    (<span class="string">"P1w"</span>, <span class="number">1</span>.week()),
    (<span class="string">"P1w4d"</span>, <span class="number">1</span>.week().days(<span class="number">4</span>)),
    (<span class="string">"PT1m"</span>, <span class="number">1</span>.minute()),
    (<span class="string">"PT0.0021s"</span>, <span class="number">2</span>.milliseconds().microseconds(<span class="number">100</span>)),
    (<span class="string">"PT0s"</span>, <span class="number">0</span>.seconds()),
    (<span class="string">"P0d"</span>, <span class="number">0</span>.seconds()),
    (
        <span class="string">"P1y1m1dT1h1m1.1s"</span>,
        <span class="number">1</span>.year().months(<span class="number">1</span>).days(<span class="number">1</span>).hours(<span class="number">1</span>).minutes(<span class="number">1</span>).seconds(<span class="number">1</span>).milliseconds(<span class="number">100</span>),
    ),
    <span class="comment">// Jiff's "friendly" format
    </span>(<span class="string">"40d"</span>, <span class="number">40</span>.days()),
    (<span class="string">"40 days"</span>, <span class="number">40</span>.days()),
    (<span class="string">"1y1d"</span>, <span class="number">1</span>.year().days(<span class="number">1</span>)),
    (<span class="string">"1yr 1d"</span>, <span class="number">1</span>.year().days(<span class="number">1</span>)),
    (<span class="string">"3d4h59m"</span>, <span class="number">3</span>.days().hours(<span class="number">4</span>).minutes(<span class="number">59</span>)),
    (<span class="string">"3 days, 4 hours, 59 minutes"</span>, <span class="number">3</span>.days().hours(<span class="number">4</span>).minutes(<span class="number">59</span>)),
    (<span class="string">"3d 4h 59m"</span>, <span class="number">3</span>.days().hours(<span class="number">4</span>).minutes(<span class="number">59</span>)),
    (<span class="string">"2h30m"</span>, <span class="number">2</span>.hours().minutes(<span class="number">30</span>)),
    (<span class="string">"2h 30m"</span>, <span class="number">2</span>.hours().minutes(<span class="number">30</span>)),
    (<span class="string">"1mo"</span>, <span class="number">1</span>.month()),
    (<span class="string">"1w"</span>, <span class="number">1</span>.week()),
    (<span class="string">"1 week"</span>, <span class="number">1</span>.week()),
    (<span class="string">"1w4d"</span>, <span class="number">1</span>.week().days(<span class="number">4</span>)),
    (<span class="string">"1 wk 4 days"</span>, <span class="number">1</span>.week().days(<span class="number">4</span>)),
    (<span class="string">"1m"</span>, <span class="number">1</span>.minute()),
    (<span class="string">"0.0021s"</span>, <span class="number">2</span>.milliseconds().microseconds(<span class="number">100</span>)),
    (<span class="string">"0s"</span>, <span class="number">0</span>.seconds()),
    (<span class="string">"0d"</span>, <span class="number">0</span>.seconds()),
    (<span class="string">"0 days"</span>, <span class="number">0</span>.seconds()),
    (
        <span class="string">"1y1mo1d1h1m1.1s"</span>,
        <span class="number">1</span>.year().months(<span class="number">1</span>).days(<span class="number">1</span>).hours(<span class="number">1</span>).minutes(<span class="number">1</span>).seconds(<span class="number">1</span>).milliseconds(<span class="number">100</span>),
    ),
    (
        <span class="string">"1yr 1mo 1day 1hr 1min 1.1sec"</span>,
        <span class="number">1</span>.year().months(<span class="number">1</span>).days(<span class="number">1</span>).hours(<span class="number">1</span>).minutes(<span class="number">1</span>).seconds(<span class="number">1</span>).milliseconds(<span class="number">100</span>),
    ),
    (
        <span class="string">"1 year, 1 month, 1 day, 1 hour, 1 minute 1.1 seconds"</span>,
        <span class="number">1</span>.year().months(<span class="number">1</span>).days(<span class="number">1</span>).hours(<span class="number">1</span>).minutes(<span class="number">1</span>).seconds(<span class="number">1</span>).milliseconds(<span class="number">100</span>),
    ),
    (
        <span class="string">"1 year, 1 month, 1 day, 01:01:01.1"</span>,
        <span class="number">1</span>.year().months(<span class="number">1</span>).days(<span class="number">1</span>).hours(<span class="number">1</span>).minutes(<span class="number">1</span>).seconds(<span class="number">1</span>).milliseconds(<span class="number">100</span>),
    ),
];
<span class="kw">for </span>(string, span) <span class="kw">in </span>spans {
    <span class="kw">let </span>parsed: Span = string.parse()<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(
        span.fieldwise(),
        parsed.fieldwise(),
        <span class="string">"result of parsing {string:?}"</span>,
    );
}
</code></pre></div>
<p>For more details, see the <a href="fmt/temporal/index.html" title="mod jiff::fmt::temporal"><code>fmt::temporal</code></a> and
<a href="fmt/friendly/index.html" title="mod jiff::fmt::friendly"><code>fmt::friendly</code></a> modules.</p>
<h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>A <code>Span</code> does not implement the <code>PartialEq</code> or <code>Eq</code> traits. These traits
were implemented in an earlier version of Jiff, but they made it too
easy to introduce bugs. For example, <code>120.minutes()</code> and <code>2.hours()</code>
always correspond to the same total duration, but they have different
representations in memory and so didn’t compare equivalent.</p>
<p>The reason why the <code>PartialEq</code> and <code>Eq</code> trait implementations do not do
comparisons with total duration is because it is fundamentally impossible
to do such comparisons without a reference date in all cases.</p>
<p>However, it is undeniably occasionally useful to do comparisons based
on the component fields, so long as such use cases can tolerate two
different spans comparing unequal even when their total durations are
equivalent. For example, many of the tests in Jiff (including the tests in
the documentation) work by comparing a <code>Span</code> to an expected result. This
is a good demonstration of when fieldwise comparisons are appropriate.</p>
<p>To do fieldwise comparisons with a span, use the <a href="struct.Span.html#method.fieldwise" title="method jiff::Span::fieldwise"><code>Span::fieldwise</code></a>
method. This method creates a <a href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise"><code>SpanFieldwise</code></a>, which is just a <code>Span</code>
that implements <code>PartialEq</code> and <code>Eq</code> in a fieldwise manner. In other words,
it’s a speed bump to ensure this is the kind of comparison you actually
want. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert_ne!</span>(<span class="number">1</span>.hour().fieldwise(), <span class="number">60</span>.minutes().fieldwise());
<span class="comment">// These also work since you only need one fieldwise span to do a compare:
</span><span class="macro">assert_ne!</span>(<span class="number">1</span>.hour(), <span class="number">60</span>.minutes().fieldwise());
<span class="macro">assert_ne!</span>(<span class="number">1</span>.hour().fieldwise(), <span class="number">60</span>.minutes());</code></pre></div>
<p>This is because doing true comparisons requires arithmetic and a relative
datetime in the general case, and which can fail due to overflow. This
operation is provided via <a href="struct.Span.html#method.compare" title="method jiff::Span::compare"><code>Span::compare</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="comment">// This doesn't need a reference date since it's only using time units.
</span><span class="macro">assert_eq!</span>(<span class="number">1</span>.hour().compare(<span class="number">60</span>.minutes())<span class="question-mark">?</span>, std::cmp::Ordering::Equal);
<span class="comment">// But if you have calendar units, then you need a
// reference date at minimum:
</span><span class="macro">assert!</span>(<span class="number">1</span>.month().compare(<span class="number">30</span>.days()).is_err());
<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.month().compare((<span class="number">30</span>.days(), date(<span class="number">2025</span>, <span class="number">6</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    std::cmp::Ordering::Equal,
);
<span class="comment">// A month can be a differing number of days!
</span><span class="macro">assert_eq!</span>(
    <span class="number">1</span>.month().compare((<span class="number">30</span>.days(), date(<span class="number">2025</span>, <span class="number">7</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    std::cmp::Ordering::Greater,
);
</code></pre></div>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>Spans can be added or subtracted via <a href="struct.Span.html#method.checked_add" title="method jiff::Span::checked_add"><code>Span::checked_add</code></a> and
<a href="struct.Span.html#method.checked_sub" title="method jiff::Span::checked_sub"><code>Span::checked_sub</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span1 = <span class="number">2</span>.hours().minutes(<span class="number">20</span>);
<span class="kw">let </span>span2: Span = <span class="string">"PT89400s"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span1.checked_add(span2)<span class="question-mark">?</span>, <span class="number">27</span>.hours().minutes(<span class="number">10</span>).fieldwise());
</code></pre></div>
<p>When your spans involve calendar units, a relative datetime must be
provided. (Because, for example, 1 month from March 1 is 31 days, but
1 month from April 1 is 30 days.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Span, ToSpan};

<span class="kw">let </span>span1 = <span class="number">2</span>.years().months(<span class="number">6</span>).days(<span class="number">20</span>);
<span class="kw">let </span>span2 = <span class="number">400</span>.days();
<span class="macro">assert_eq!</span>(
    span1.checked_add((span2, date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">3</span>.years().months(<span class="number">7</span>).days(<span class="number">24</span>).fieldwise(),
);
<span class="comment">// The span changes when a leap year isn't included!
</span><span class="macro">assert_eq!</span>(
    span1.checked_add((span2, date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">3</span>.years().months(<span class="number">7</span>).days(<span class="number">23</span>).fieldwise(),
);
</code></pre></div>
<h2 id="rounding-and-balancing"><a class="doc-anchor" href="#rounding-and-balancing">§</a>Rounding and balancing</h2>
<p>Unlike datetimes, multiple distinct <code>Span</code> values can actually correspond
to the same duration of time. For example, all of the following correspond
to the same duration:</p>
<ul>
<li>2 hours, 30 minutes</li>
<li>150 minutes</li>
<li>1 hour, 90 minutes</li>
</ul>
<p>The first is said to be balanced. That is, its biggest non-zero unit cannot
be expressed in an integer number of units bigger than hours. But the
second is unbalanced because 150 minutes can be split up into hours and
minutes. We call this sort of span a “top-heavy” unbalanced span. The third
span is also unbalanced, but it’s “bottom-heavy” and rarely used. Jiff
will generally only produce spans of the first two types. In particular,
most <code>Span</code> producing APIs accept a “largest” <a href="enum.Unit.html" title="enum jiff::Unit"><code>Unit</code></a> parameter, and the
result can be said to be a span “balanced up to the largest unit provided.”</p>
<p>Balanced and unbalanced spans can be switched between as needed via
the <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> API by providing a rounding configuration with
<a href="struct.SpanRound.html#method.largest" title="method jiff::SpanRound::largest"><code>SpanRound::largest</code></a>` set:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">2</span>.hours().minutes(<span class="number">30</span>);
<span class="kw">let </span>unbalanced = span.round(SpanRound::new().largest(Unit::Minute))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(unbalanced, <span class="number">150</span>.minutes().fieldwise());
<span class="kw">let </span>balanced = unbalanced.round(SpanRound::new().largest(Unit::Hour))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(balanced, <span class="number">2</span>.hours().minutes(<span class="number">30</span>).fieldwise());
</code></pre></div>
<p>Balancing can also be done as part of computing spans from two datetimes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">7</span>).at(<span class="number">15</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">5</span>).at(<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// To make arithmetic reversible, the default largest unit for spans of
// time computed from zoned datetimes is hours:
</span><span class="macro">assert_eq!</span>(zdt1.until(<span class="kw-2">&amp;</span>zdt2)<span class="question-mark">?</span>, <span class="number">2_897</span>.hour().minutes(<span class="number">37</span>).fieldwise());
<span class="comment">// But we can ask for the span to be balanced up to years:
</span><span class="macro">assert_eq!</span>(
    zdt1.until((Unit::Year, <span class="kw-2">&amp;</span>zdt2))<span class="question-mark">?</span>,
    <span class="number">3</span>.months().days(<span class="number">28</span>).hours(<span class="number">16</span>).minutes(<span class="number">37</span>).fieldwise(),
);
</code></pre></div>
<p>While the <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> API does balancing, it also, of course, does
rounding as well. Rounding occurs when the smallest unit is set to
something bigger than <a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">2</span>.hours().minutes(<span class="number">30</span>);
<span class="macro">assert_eq!</span>(span.round(Unit::Hour)<span class="question-mark">?</span>, <span class="number">3</span>.hours().fieldwise());
</code></pre></div>
<p>When rounding spans with calendar units (years, months or weeks), then a
relative datetime is required:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">10</span>.years().months(<span class="number">11</span>);
<span class="kw">let </span>options = SpanRound::new()
    .smallest(Unit::Year)
    .relative(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>));
<span class="macro">assert_eq!</span>(span.round(options)<span class="question-mark">?</span>, <span class="number">11</span>.years().fieldwise());
</code></pre></div>
<h2 id="days-are-not-always-24-hours"><a class="doc-anchor" href="#days-are-not-always-24-hours">§</a>Days are not always 24 hours!</h2>
<p>That is, a <code>Span</code> is made up of uniform and non-uniform units.</p>
<p>A uniform unit is a unit whose elapsed duration is always the same.
A non-uniform unit is a unit whose elapsed duration is not always the same.
There are two things that can impact the length of a non-uniform unit:
the calendar date and the time zone.</p>
<p>Years and months are always considered non-uniform units. For example,
1 month from <code>2024-04-01</code> is 30 days, while 1 month from <code>2024-05-01</code> is
31 days. Similarly for years because of leap years.</p>
<p>Hours, minutes, seconds, milliseconds, microseconds and nanoseconds are
always considered uniform units.</p>
<p>Days are only considered non-uniform when in the presence of a zone aware
datetime. A day can be more or less than 24 hours, and it can be balanced
up and down, but only when a relative zoned datetime is given. This
typically happens because of DST (daylight saving time), but can also occur
because of other time zone transitions too.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SpanRound, ToSpan, Unit};

<span class="comment">// 2024-03-10 in New York was 23 hours long,
// because of a jump to DST at 2am.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">9</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// Goes from days to hours:
</span><span class="macro">assert_eq!</span>(
    <span class="number">1</span>.day().round(SpanRound::new().largest(Unit::Hour).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">23</span>.hours().fieldwise(),
);
<span class="comment">// Goes from hours to days:
</span><span class="macro">assert_eq!</span>(
    <span class="number">23</span>.hours().round(SpanRound::new().largest(Unit::Day).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">1</span>.day().fieldwise(),
);
<span class="comment">// 24 hours is more than 1 day starting at this time:
</span><span class="macro">assert_eq!</span>(
    <span class="number">24</span>.hours().round(SpanRound::new().largest(Unit::Day).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">1</span>.day().hours(<span class="number">1</span>).fieldwise(),
);
</code></pre></div>
<p>And similarly, days can be longer than 24 hours:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SpanRound, ToSpan, Unit};

<span class="comment">// 2024-11-03 in New York was 25 hours long,
// because of a repetition of the 1 o'clock AM hour.
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">2</span>).at(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// Goes from days to hours:
</span><span class="macro">assert_eq!</span>(
    <span class="number">1</span>.day().round(SpanRound::new().largest(Unit::Hour).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">25</span>.hours().fieldwise(),
);
<span class="comment">// Goes from hours to days:
</span><span class="macro">assert_eq!</span>(
    <span class="number">25</span>.hours().round(SpanRound::new().largest(Unit::Day).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">1</span>.day().fieldwise(),
);
<span class="comment">// 24 hours is less than 1 day starting at this time,
// so it stays in units of hours even though we ask
// for days (because 24 isn't enough hours to make
// 1 day):
</span><span class="macro">assert_eq!</span>(
    <span class="number">24</span>.hours().round(SpanRound::new().largest(Unit::Day).relative(<span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>,
    <span class="number">24</span>.hours().fieldwise(),
);
</code></pre></div>
<p>The APIs on <code>Span</code> will otherwise treat days as non-uniform unless a
relative civil date is given, or there is an explicit opt-in to invariant
24-hour days. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, SpanRelativeTo, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">1</span>.day();

<span class="comment">// An error because days aren't always 24 hours:
</span><span class="macro">assert_eq!</span>(
    span.total(Unit::Hour).unwrap_err().to_string(),
    <span class="string">"using unit 'day' in a span or configuration requires that either \
     a relative reference time be given or \
     `SpanRelativeTo::days_are_24_hours()` is used to indicate \
     invariant 24-hour days, but neither were provided"</span>,
);
<span class="comment">// Opt into invariant 24 hour days without a relative date:
</span><span class="kw">let </span>marker = SpanRelativeTo::days_are_24_hours();
<span class="kw">let </span>hours = span.total((Unit::Hour, marker))<span class="question-mark">?</span>;
<span class="comment">// Or use a relative civil date, and all days are 24 hours:
</span><span class="kw">let </span>date = civil::date(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);
<span class="kw">let </span>hours = span.total((Unit::Hour, date))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(hours, <span class="number">24.0</span>);
</code></pre></div>
<p>In Jiff, all weeks are 7 days. And generally speaking, weeks only appear in
a <code>Span</code> if they were explicitly put there by the caller or if they were
explicitly requested by the caller in an API. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>dt1 = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>dt2 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">16</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="comment">// Default units go up to days.
</span><span class="macro">assert_eq!</span>(dt1.until(dt2)<span class="question-mark">?</span>, <span class="number">197</span>.days().fieldwise());
<span class="comment">// No weeks, even though we requested up to year.
</span><span class="macro">assert_eq!</span>(dt1.until((Unit::Year, dt2))<span class="question-mark">?</span>, <span class="number">6</span>.months().days(<span class="number">15</span>).fieldwise());
<span class="comment">// We get weeks only when we ask for them.
</span><span class="macro">assert_eq!</span>(dt1.until((Unit::Week, dt2))<span class="question-mark">?</span>, <span class="number">28</span>.weeks().days(<span class="number">1</span>).fieldwise());
</code></pre></div>
<h2 id="integration-with-stdtimeduration-and-signedduration"><a class="doc-anchor" href="#integration-with-stdtimeduration-and-signedduration">§</a>Integration with <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a> and <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a></h2>
<p>While Jiff primarily uses a <code>Span</code> for doing arithmetic on datetimes,
one can convert between a <code>Span</code> and a <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a> or a
<a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a>. The main difference between them is that a <code>Span</code>
always keeps tracks of its individual units, and a <code>Span</code> can represent
non-uniform units like months. In contrast, <code>Duration</code> and <code>SignedDuration</code>
are always an exact elapsed amount of time. They don’t distinguish between
<code>120 seconds</code> and <code>2 minutes</code>. And they can’t represent the concept of
“months” because a month doesn’t have a single fixed amount of time.</p>
<p>However, an exact duration is still useful in certain contexts. Beyond
that, it serves as an interoperability point due to the presence of an
unsigned exact duration type in the standard library. Because of that,
Jiff provides <code>TryFrom</code> trait implementations for converting to and from a
<code>std::time::Duration</code> (and, of course, a <code>SignedDuration</code>). For example, to
convert from a <code>std::time::Duration</code> to a <code>Span</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>duration = Duration::new(<span class="number">86_400</span>, <span class="number">123_456_789</span>);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>;
<span class="comment">// A duration-to-span conversion always results in a span with
// non-zero units no bigger than seconds.
</span><span class="macro">assert_eq!</span>(
    span.fieldwise(),
    <span class="number">86_400</span>.seconds().milliseconds(<span class="number">123</span>).microseconds(<span class="number">456</span>).nanoseconds(<span class="number">789</span>),
);

<span class="comment">// Note that the conversion is fallible! For example:
</span><span class="macro">assert!</span>(Span::try_from(Duration::from_secs(u64::MAX)).is_err());
<span class="comment">// At present, a Jiff `Span` can only represent a range of time equal to
// the range of time expressible via minimum and maximum Jiff timestamps.
// Which is roughly -9999-01-01 to 9999-12-31, or ~20,000 years.
</span><span class="macro">assert!</span>(Span::try_from(Duration::from_secs(<span class="number">999_999_999_999</span>)).is_err());
</code></pre></div>
<p>And to convert from a <code>Span</code> to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span = <span class="number">86_400</span>.seconds()
    .milliseconds(<span class="number">123</span>)
    .microseconds(<span class="number">456</span>)
    .nanoseconds(<span class="number">789</span>);
<span class="kw">let </span>duration = Duration::try_from(span)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, Duration::new(<span class="number">86_400</span>, <span class="number">123_456_789</span>));
</code></pre></div>
<p>Note that an error will occur when converting a <code>Span</code> to a
<code>std::time::Duration</code> using the <code>TryFrom</code> trait implementation with units
bigger than hours:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">2</span>.days().hours(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(
    Duration::try_from(span).unwrap_err().to_string(),
    <span class="string">"failed to convert span to duration without relative datetime \
     (must use `Span::to_duration` instead): using unit 'day' in a \
     span or configuration requires that either a relative reference \
     time be given or `SpanRelativeTo::days_are_24_hours()` is used \
     to indicate invariant 24-hour days, but neither were provided"</span>,
);
</code></pre></div>
<p>Similar code can be written for <code>SignedDuration</code> as well.</p>
<p>If you need to convert such spans, then as the error suggests, you’ll need
to use <a href="struct.Span.html#method.to_duration" title="method jiff::Span::to_duration"><code>Span::to_duration</code></a> with a relative date.</p>
<p>And note that since a <code>Span</code> is signed and a <code>std::time::Duration</code> is unsigned,
converting a negative <code>Span</code> to <code>std::time::Duration</code> will always fail. One can use
<a href="struct.Span.html#method.signum" title="method jiff::Span::signum"><code>Span::signum</code></a> to get the sign of the span and <a href="struct.Span.html#method.abs" title="method jiff::Span::abs"><code>Span::abs</code></a> to make the
span positive before converting it to a <code>Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span = -<span class="number">86_400</span>.seconds().nanoseconds(<span class="number">1</span>);
<span class="kw">let </span>(sign, duration) = (span.signum(), Duration::try_from(span.abs())<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>((sign, duration), (-<span class="number">1</span>, Duration::new(<span class="number">86_400</span>, <span class="number">1</span>)));
</code></pre></div>
<p>Or, consider using Jiff’s own <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Span, ToSpan};

<span class="kw">let </span>span = -<span class="number">86_400</span>.seconds().nanoseconds(<span class="number">1</span>);
<span class="kw">let </span>duration = SignedDuration::try_from(span)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, SignedDuration::new(-<span class="number">86_400</span>, -<span class="number">1</span>));
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#730-886">Source</a><a href="#impl-Span" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Infallible routines for setting units on a <code>Span</code>.</p>
</div></section></summary><div class="docblock"><p>These are useful when the units are determined by the programmer or when
they have been validated elsewhere. In general, use these routines when
constructing an invalid <code>Span</code> should be considered a bug in the program.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#733-735">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Creates a new span representing a zero duration. That is, a duration
in which no time has passed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.years" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#747-749">Source</a><h4 class="code-header">pub fn <a href="#method.years" class="fn">years</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, years: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of years on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_years" title="method jiff::Span::try_years"><code>Span::try_years</code></a>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics when the number of years is too small or too big.
The minimum value is <code>-19,998</code>.
The maximum value is <code>19,998</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.months" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#761-763">Source</a><h4 class="code-header">pub fn <a href="#method.months" class="fn">months</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, months: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of months on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_months" title="method jiff::Span::try_months"><code>Span::try_months</code></a>.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This panics when the number of months is too small or too big.
The minimum value is <code>-239,976</code>.
The maximum value is <code>239,976</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weeks" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#775-777">Source</a><h4 class="code-header">pub fn <a href="#method.weeks" class="fn">weeks</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, weeks: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of weeks on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_weeks" title="method jiff::Span::try_weeks"><code>Span::try_weeks</code></a>.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>This panics when the number of weeks is too small or too big.
The minimum value is <code>-1,043,497</code>.
The maximum value is <code>1_043_497</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.days" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#789-791">Source</a><h4 class="code-header">pub fn <a href="#method.days" class="fn">days</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, days: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of days on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_days" title="method jiff::Span::try_days"><code>Span::try_days</code></a>.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>This panics when the number of days is too small or too big.
The minimum value is <code>-7,304,484</code>.
The maximum value is <code>7,304,484</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hours" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#803-805">Source</a><h4 class="code-header">pub fn <a href="#method.hours" class="fn">hours</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, hours: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of hours on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_hours" title="method jiff::Span::try_hours"><code>Span::try_hours</code></a>.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>This panics when the number of hours is too small or too big.
The minimum value is <code>-175,307,616</code>.
The maximum value is <code>175,307,616</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minutes" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#817-819">Source</a><h4 class="code-header">pub fn <a href="#method.minutes" class="fn">minutes</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, minutes: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of minutes on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_minutes" title="method jiff::Span::try_minutes"><code>Span::try_minutes</code></a>.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>This panics when the number of minutes is too small or too big.
The minimum value is <code>-10,518,456,960</code>.
The maximum value is <code>10,518,456,960</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.seconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#831-833">Source</a><h4 class="code-header">pub fn <a href="#method.seconds" class="fn">seconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, seconds: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of seconds on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_seconds" title="method jiff::Span::try_seconds"><code>Span::try_seconds</code></a>.</p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h5>
<p>This panics when the number of seconds is too small or too big.
The minimum value is <code>-631,107,417,600</code>.
The maximum value is <code>631,107,417,600</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.milliseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#845-848">Source</a><h4 class="code-header">pub fn <a href="#method.milliseconds" class="fn">milliseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, milliseconds: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of milliseconds on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_milliseconds" title="method jiff::Span::try_milliseconds"><code>Span::try_milliseconds</code></a>.</p>
<h5 id="panics-7"><a class="doc-anchor" href="#panics-7">§</a>Panics</h5>
<p>This panics when the number of milliseconds is too small or too big.
The minimum value is <code>-631,107,417,600,000</code>.
The maximum value is <code>631,107,417,600,000</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.microseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#860-863">Source</a><h4 class="code-header">pub fn <a href="#method.microseconds" class="fn">microseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, microseconds: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of microseconds on this span. The value may be negative.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_microseconds" title="method jiff::Span::try_microseconds"><code>Span::try_microseconds</code></a>.</p>
<h5 id="panics-8"><a class="doc-anchor" href="#panics-8">§</a>Panics</h5>
<p>This panics when the number of microseconds is too small or too big.
The minimum value is <code>-631,107,417,600,000,000</code>.
The maximum value is <code>631,107,417,600,000,000</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nanoseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#882-885">Source</a><h4 class="code-header">pub fn <a href="#method.nanoseconds" class="fn">nanoseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, nanoseconds: I) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Set the number of nanoseconds on this span. The value may be negative.</p>
<p>Note that unlike all other units, a 64-bit integer number of
nanoseconds is not big enough to represent all possible spans between
all possible datetimes supported by Jiff. This means, for example, that
computing a span between two datetimes that are far enough apart <em>and</em>
requesting a largest unit of <a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, might return an
error due to lack of precision.</p>
<p>The fallible version of this method is <a href="struct.Span.html#method.try_nanoseconds" title="method jiff::Span::try_nanoseconds"><code>Span::try_nanoseconds</code></a>.</p>
<h5 id="panics-9"><a class="doc-anchor" href="#panics-9">§</a>Panics</h5>
<p>This panics when the number of nanoseconds is too small or too big.
The minimum value is <code>-9,223,372,036,854,775,807</code>.
The maximum value is <code>9,223,372,036,854,775,807</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Span-1" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#892-1075">Source</a><a href="#impl-Span-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Fallible methods for setting units on a <code>Span</code>.</p>
</div></section></summary><div class="docblock"><p>These methods are useful when the span is made up of user provided values
that may not be in range.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_years" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#903-906">Source</a><h4 class="code-header">pub fn <a href="#method.try_years" class="fn">try_years</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, years: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of years on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.years" title="method jiff::Span::years"><code>Span::years</code></a>.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when the number of years is too small or too big.
The minimum value is <code>-19,998</code>.
The maximum value is <code>19,998</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_months" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#918-922">Source</a><h4 class="code-header">pub fn <a href="#method.try_months" class="fn">try_months</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, months: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of months on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.months" title="method jiff::Span::months"><code>Span::months</code></a>.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when the number of months is too small or too big.
The minimum value is <code>-239,976</code>.
The maximum value is <code>239,976</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_weeks" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#934-938">Source</a><h4 class="code-header">pub fn <a href="#method.try_weeks" class="fn">try_weeks</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, weeks: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of weeks on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.weeks" title="method jiff::Span::weeks"><code>Span::weeks</code></a>.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when the number of weeks is too small or too big.
The minimum value is <code>-1,043,497</code>.
The maximum value is <code>1_043_497</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_days" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#950-954">Source</a><h4 class="code-header">pub fn <a href="#method.try_days" class="fn">try_days</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, days: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of days on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.days" title="method jiff::Span::days"><code>Span::days</code></a>.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when the number of days is too small or too big.
The minimum value is <code>-7,304,484</code>.
The maximum value is <code>7,304,484</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_hours" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#966-970">Source</a><h4 class="code-header">pub fn <a href="#method.try_hours" class="fn">try_hours</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, hours: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of hours on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.hours" title="method jiff::Span::hours"><code>Span::hours</code></a>.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when the number of hours is too small or too big.
The minimum value is <code>-175,307,616</code>.
The maximum value is <code>175,307,616</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_minutes" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#982-986">Source</a><h4 class="code-header">pub fn <a href="#method.try_minutes" class="fn">try_minutes</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, minutes: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of minutes on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.minutes" title="method jiff::Span::minutes"><code>Span::minutes</code></a>.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error when the number of minutes is too small or too big.
The minimum value is <code>-10,518,456,960</code>.
The maximum value is <code>10,518,456,960</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_seconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#998-1002">Source</a><h4 class="code-header">pub fn <a href="#method.try_seconds" class="fn">try_seconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(self, seconds: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of seconds on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.seconds" title="method jiff::Span::seconds"><code>Span::seconds</code></a>.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when the number of seconds is too small or too big.
The minimum value is <code>-631,107,417,600</code>.
The maximum value is <code>631,107,417,600</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_milliseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1015-1024">Source</a><h4 class="code-header">pub fn <a href="#method.try_milliseconds" class="fn">try_milliseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(
    self,
    milliseconds: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of milliseconds on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.milliseconds" title="method jiff::Span::milliseconds"><code>Span::milliseconds</code></a>.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>This returns an error when the number of milliseconds is too small or
too big.
The minimum value is <code>-631,107,417,600,000</code>.
The maximum value is <code>631,107,417,600,000</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_microseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1037-1046">Source</a><h4 class="code-header">pub fn <a href="#method.try_microseconds" class="fn">try_microseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(
    self,
    microseconds: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of microseconds on this span. The value may be negative.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.microseconds" title="method jiff::Span::microseconds"><code>Span::microseconds</code></a>.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This returns an error when the number of microseconds is too small or
too big.
The minimum value is <code>-631,107,417,600,000,000</code>.
The maximum value is <code>631,107,417,600,000,000</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_nanoseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1066-1074">Source</a><h4 class="code-header">pub fn <a href="#method.try_nanoseconds" class="fn">try_nanoseconds</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt;&gt;(
    self,
    nanoseconds: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the number of nanoseconds on this span. The value may be negative.</p>
<p>Note that unlike all other units, a 64-bit integer number of
nanoseconds is not big enough to represent all possible spans between
all possible datetimes supported by Jiff. This means, for example, that
computing a span between two datetimes that are far enough apart <em>and</em>
requesting a largest unit of <a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, might return an
error due to lack of precision.</p>
<p>The panicking version of this method is <a href="struct.Span.html#method.nanoseconds" title="method jiff::Span::nanoseconds"><code>Span::nanoseconds</code></a>.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error when the number of nanoseconds is too small or
too big.
The minimum value is <code>-9,223,372,036,854,775,807</code>.
The maximum value is <code>9,223,372,036,854,775,807</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Span-2" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#1078-1300">Source</a><a href="#impl-Span-2" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Routines for accessing the individual units in a <code>Span</code>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.get_years" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1097-1099">Source</a><h4 class="code-header">pub fn <a href="#method.get_years" class="fn">get_years</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the number of year units in this span.</p>
<p>Note that this is not the same as the total number of years in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.years().months(<span class="number">24</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_years());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total((Unit::Year, date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>)))<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_months" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1119-1121">Source</a><h4 class="code-header">pub fn <a href="#method.get_months" class="fn">get_months</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the number of month units in this span.</p>
<p>Note that this is not the same as the total number of months in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">7</span>.months().days(<span class="number">59</span>);
<span class="macro">assert_eq!</span>(<span class="number">7</span>, span.get_months());
<span class="macro">assert_eq!</span>(<span class="number">9.0</span>, span.total((Unit::Month, date(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">1</span>)))<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_weeks" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1141-1143">Source</a><h4 class="code-header">pub fn <a href="#method.get_weeks" class="fn">get_weeks</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the number of week units in this span.</p>
<p>Note that this is not the same as the total number of weeks in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.weeks().days(<span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_weeks());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total((Unit::Week, date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>)))<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_days" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1165-1167">Source</a><h4 class="code-header">pub fn <a href="#method.get_days" class="fn">get_days</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the number of day units in this span.</p>
<p>Note that this is not the same as the total number of days in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit, Zoned};

<span class="kw">let </span>span = <span class="number">3</span>.days().hours(<span class="number">47</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_days());

<span class="kw">let </span>zdt: Zoned = <span class="string">"2024-03-07[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total((Unit::Day, <span class="kw-2">&amp;</span>zdt))<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_hours" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1187-1189">Source</a><h4 class="code-header">pub fn <a href="#method.get_hours" class="fn">get_hours</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the number of hour units in this span.</p>
<p>Note that this is not the same as the total number of hours in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.hours().minutes(<span class="number">120</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_hours());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total(Unit::Hour)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_minutes" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1209-1211">Source</a><h4 class="code-header">pub fn <a href="#method.get_minutes" class="fn">get_minutes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns the number of minute units in this span.</p>
<p>Note that this is not the same as the total number of minutes in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.minutes().seconds(<span class="number">120</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_minutes());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total(Unit::Minute)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_seconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1231-1233">Source</a><h4 class="code-header">pub fn <a href="#method.get_seconds" class="fn">get_seconds</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns the number of second units in this span.</p>
<p>Note that this is not the same as the total number of seconds in the
span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.seconds().milliseconds(<span class="number">2_000</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_seconds());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total(Unit::Second)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_milliseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1253-1255">Source</a><h4 class="code-header">pub fn <a href="#method.get_milliseconds" class="fn">get_milliseconds</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns the number of millisecond units in this span.</p>
<p>Note that this is not the same as the total number of milliseconds in
the span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.milliseconds().microseconds(<span class="number">2_000</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_milliseconds());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total(Unit::Millisecond)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_microseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1275-1277">Source</a><h4 class="code-header">pub fn <a href="#method.get_microseconds" class="fn">get_microseconds</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns the number of microsecond units in this span.</p>
<p>Note that this is not the same as the total number of microseconds in
the span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.microseconds().nanoseconds(<span class="number">2_000</span>);
<span class="macro">assert_eq!</span>(<span class="number">3</span>, span.get_microseconds());
<span class="macro">assert_eq!</span>(<span class="number">5.0</span>, span.total(Unit::Microsecond)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_nanoseconds" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1297-1299">Source</a><h4 class="code-header">pub fn <a href="#method.get_nanoseconds" class="fn">get_nanoseconds</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns the number of nanosecond units in this span.</p>
<p>Note that this is not the same as the total number of nanoseconds in
the span. To get that, you’ll need to use either <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> or
<a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.microseconds().nanoseconds(<span class="number">2_000</span>);
<span class="macro">assert_eq!</span>(<span class="number">2_000</span>, span.get_nanoseconds());
<span class="macro">assert_eq!</span>(<span class="number">5_000.0</span>, span.total(Unit::Nanosecond)<span class="question-mark">?</span>);
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Span-3" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#1303-2480">Source</a><a href="#impl-Span-3" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Routines for manipulating, comparing and inspecting <code>Span</code> values.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.abs" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1319-1324">Source</a><h4 class="code-header">pub fn <a href="#method.abs" class="fn">abs</a>(self) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns a new span that is the absolute value of this span.</p>
<p>If this span is zero or positive, then this is a no-op.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = -<span class="number">100</span>.seconds();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-PT100S"</span>);
<span class="kw">let </span>span = span.abs();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT100S"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.negate" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1356-1358">Source</a><h4 class="code-header">pub fn <a href="#method.negate" class="fn">negate</a>(self) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns a new span that negates this span.</p>
<p>If this span is zero, then this is a no-op. If this span is negative,
then the returned span is positive. If this span is positive, then
the returned span is negative.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">100</span>.days();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P100D"</span>);
<span class="kw">let </span>span = span.negate();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P100D"</span>);</code></pre></div>
<h5 id="example-available-via-the-negation-operator"><a class="doc-anchor" href="#example-available-via-the-negation-operator">§</a>Example: available via the negation operator</h5>
<p>This routine can also be used via <code>-</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">100</span>.days();
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"P100D"</span>);
<span class="kw">let </span>span = -span;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"-P100D"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.signum" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1365-1367">Source</a><h4 class="code-header">pub fn <a href="#method.signum" class="fn">signum</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “sign number” or “signum” of this span.</p>
<p>The number returned is <code>-1</code> when this span is negative,
<code>0</code> when this span is zero and <code>1</code> when this span is positive.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_positive" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1382-1384">Source</a><h4 class="code-header">pub fn <a href="#method.is_positive" class="fn">is_positive</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this span is positive.</p>
<p>This returns false when the span is zero or negative.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert!</span>(!<span class="number">2</span>.months().is_negative());
<span class="macro">assert!</span>((-<span class="number">2</span>.months()).is_negative());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_negative" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1399-1401">Source</a><h4 class="code-header">pub fn <a href="#method.is_negative" class="fn">is_negative</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this span is negative.</p>
<p>This returns false when the span is zero or positive.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert!</span>(!<span class="number">2</span>.months().is_negative());
<span class="macro">assert!</span>((-<span class="number">2</span>.months()).is_negative());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_zero" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1417-1419">Source</a><h4 class="code-header">pub fn <a href="#method.is_zero" class="fn">is_zero</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if every field in this span is set to <code>0</code>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan};

<span class="macro">assert!</span>(Span::new().is_zero());
<span class="macro">assert!</span>(Span::default().is_zero());
<span class="macro">assert!</span>(<span class="number">0</span>.seconds().is_zero());
<span class="macro">assert!</span>(!<span class="number">0</span>.seconds().seconds(<span class="number">1</span>).is_zero());
<span class="macro">assert!</span>(<span class="number">0</span>.seconds().seconds(<span class="number">1</span>).seconds(<span class="number">0</span>).is_zero());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fieldwise" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1450-1452">Source</a><h4 class="code-header">pub fn <a href="#method.fieldwise" class="fn">fieldwise</a>(self) -&gt; <a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a></h4></section></summary><div class="docblock"><p>Returns this <code>Span</code> as a value with a type that implements the
<code>Hash</code>, <code>Eq</code> and <code>PartialEq</code> traits in a fieldwise fashion.</p>
<p>A <code>SpanFieldwise</code> is meant to make it easy to compare two spans in a
“dumb” way based purely on its unit values. This is distinct from
something like <a href="struct.Span.html#method.compare" title="method jiff::Span::compare"><code>Span::compare</code></a> that performs a comparison on the
actual elapsed time of two spans.</p>
<p>It is generally discouraged to use <code>SpanFieldwise</code> since spans that
represent an equivalent elapsed amount of time may compare unequal.
However, in some cases, it is useful to be able to assert precise
field values. For example, Jiff itself makes heavy use of fieldwise
comparisons for tests.</p>
<h5 id="example-the-difference-between-spanfieldwise-and-spancompare"><a class="doc-anchor" href="#example-the-difference-between-spanfieldwise-and-spancompare">§</a>Example: the difference between <code>SpanFieldwise</code> and <code>Span::compare</code></h5>
<p>In short, <code>SpanFieldwise</code> considers <code>2 hours</code> and <code>120 minutes</code> to be
distinct values, but <code>Span::compare</code> considers them to be equivalent:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cmp::Ordering;
<span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert_ne!</span>(<span class="number">120</span>.minutes().fieldwise(), <span class="number">2</span>.hours().fieldwise());
<span class="macro">assert_eq!</span>(<span class="number">120</span>.minutes().compare(<span class="number">2</span>.hours())<span class="question-mark">?</span>, Ordering::Equal);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_mul" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1494-1569">Source</a><h4 class="code-header">pub fn <a href="#method.checked_mul" class="fn">checked_mul</a>(self, rhs: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Multiplies each field in this span by a given integer.</p>
<p>If this would cause any individual field in this span to overflow, then
this returns an error.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">4</span>.days().seconds(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(span.checked_mul(<span class="number">2</span>)<span class="question-mark">?</span>, <span class="number">8</span>.days().seconds(<span class="number">16</span>).fieldwise());
<span class="macro">assert_eq!</span>(span.checked_mul(-<span class="number">3</span>)<span class="question-mark">?</span>, -<span class="number">12</span>.days().seconds(<span class="number">24</span>).fieldwise());
<span class="comment">// Notice that no re-balancing is done. It's "just" multiplication.
</span><span class="macro">assert_eq!</span>(span.checked_mul(<span class="number">10</span>)<span class="question-mark">?</span>, <span class="number">40</span>.days().seconds(<span class="number">80</span>).fieldwise());

<span class="kw">let </span>span = <span class="number">10_000</span>.years();
<span class="comment">// too big!
</span><span class="macro">assert!</span>(span.checked_mul(<span class="number">3</span>).is_err());
</code></pre></div>
<h5 id="example-available-via-the-multiplication-operator"><a class="doc-anchor" href="#example-available-via-the-multiplication-operator">§</a>Example: available via the multiplication operator</h5>
<p>This method can be used via the <code>*</code> operator. Note though that a panic
happens on overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span = <span class="number">4</span>.days().seconds(<span class="number">8</span>);
<span class="macro">assert_eq!</span>(span * <span class="number">2</span>, <span class="number">8</span>.days().seconds(<span class="number">16</span>).fieldwise());
<span class="macro">assert_eq!</span>(<span class="number">2 </span>* span, <span class="number">8</span>.days().seconds(<span class="number">16</span>).fieldwise());
<span class="macro">assert_eq!</span>(span * -<span class="number">3</span>, -<span class="number">12</span>.days().seconds(<span class="number">24</span>).fieldwise());
<span class="macro">assert_eq!</span>(-<span class="number">3 </span>* span, -<span class="number">12</span>.days().seconds(<span class="number">24</span>).fieldwise());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1762-1768">Source</a><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;'a, A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'a&gt;&gt;&gt;(
    &amp;self,
    options: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Adds a span to this one and returns the sum as a new span.</p>
<p>When adding a span with units greater than hours, callers must provide
a relative datetime to anchor the spans.</p>
<p>Arithmetic proceeds as specified in <a href="https://datatracker.ietf.org/doc/html/rfc5545">RFC 5545</a>. Bigger units are
added together before smaller units.</p>
<p>This routine accepts anything that implements <code>Into&lt;SpanArithmetic&gt;</code>.
There are some trait implementations that make using this routine
ergonomic:</p>
<ul>
<li><code>From&lt;Span&gt; for SpanArithmetic</code> adds the given span to this one.</li>
<li><code>From&lt;(Span, civil::Date)&gt; for SpanArithmetic</code> adds the given
span to this one relative to the given date. There are also <code>From</code>
implementations for <code>civil::DateTime</code> and <code>Zoned</code>.</li>
</ul>
<p>This also works with different duration types, such as
<a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>, via additional trait
implementations:</p>
<ul>
<li><code>From&lt;SignedDuration&gt; for SpanArithmetic</code> adds the given duration to
this one.</li>
<li><code>From&lt;(SignedDuration, civil::Date)&gt; for SpanArithmetic</code> adds the
given duration to this one relative to the given date. There are also
<code>From</code> implementations for <code>civil::DateTime</code> and <code>Zoned</code>.</li>
</ul>
<p>And similarly for <code>std::time::Duration</code>.</p>
<p>Adding a negative span is equivalent to subtracting its absolute value.</p>
<p>The largest non-zero unit in the span returned is at most the largest
non-zero unit among the two spans being added. For an absolute
duration, its “largest” unit is considered to be nanoseconds.</p>
<p>The sum returned is automatically re-balanced so that the span is not
“bottom heavy.”</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error when adding the two spans would overflow any
individual field of a span. This will also return an error if either
of the spans have non-zero units of days or greater and no relative
reference time is provided.</p>
<p>Callers may use <a href="struct.SpanArithmetic.html#method.days_are_24_hours" title="method jiff::SpanArithmetic::days_are_24_hours"><code>SpanArithmetic::days_are_24_hours</code></a> as a special
marker instead of providing a relative civil date to indicate that
all days should be 24 hours long. This also results in treating all
weeks as seven 24 hour days (168 hours).</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_add(<span class="number">30</span>.minutes())<span class="question-mark">?</span>,
    <span class="number">1</span>.hour().minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<h5 id="example-re-balancing"><a class="doc-anchor" href="#example-re-balancing">§</a>Example: re-balancing</h5>
<p>This example shows how units are automatically rebalanced into bigger
units when appropriate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span1 = <span class="number">2</span>.hours().minutes(<span class="number">59</span>);
<span class="kw">let </span>span2 = <span class="number">2</span>.minutes();
<span class="macro">assert_eq!</span>(span1.checked_add(span2)<span class="question-mark">?</span>, <span class="number">3</span>.hours().minutes(<span class="number">1</span>).fieldwise());
</code></pre></div>
<h5 id="example-days-are-not-assumed-to-be-24-hours-by-default"><a class="doc-anchor" href="#example-days-are-not-assumed-to-be-24-hours-by-default">§</a>Example: days are not assumed to be 24 hours by default</h5>
<p>When dealing with units involving days or weeks, one must either
provide a relative datetime (shown in the following examples) or opt
into invariant 24 hour days:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanRelativeTo, ToSpan};

<span class="kw">let </span>span1 = <span class="number">2</span>.days().hours(<span class="number">23</span>);
<span class="kw">let </span>span2 = <span class="number">2</span>.hours();
<span class="macro">assert_eq!</span>(
    span1.checked_add((span2, SpanRelativeTo::days_are_24_hours()))<span class="question-mark">?</span>,
    <span class="number">3</span>.days().hours(<span class="number">1</span>).fieldwise(),
);
</code></pre></div>
<h5 id="example-adding-spans-with-calendar-units"><a class="doc-anchor" href="#example-adding-spans-with-calendar-units">§</a>Example: adding spans with calendar units</h5>
<p>If you try to add two spans with calendar units without specifying a
relative datetime, you’ll get an error:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span1 = <span class="number">1</span>.month().days(<span class="number">15</span>);
<span class="kw">let </span>span2 = <span class="number">15</span>.days();
<span class="macro">assert!</span>(span1.checked_add(span2).is_err());</code></pre></div>
<p>A relative datetime is needed because calendar spans may correspond to
different actual durations depending on where the span begins:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan};

<span class="kw">let </span>span1 = <span class="number">1</span>.month().days(<span class="number">15</span>);
<span class="kw">let </span>span2 = <span class="number">15</span>.days();
<span class="comment">// 1 month from March 1 is 31 days...
</span><span class="macro">assert_eq!</span>(
    span1.checked_add((span2, date(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">2</span>.months().fieldwise(),
);
<span class="comment">// ... but 1 month from April 1 is 30 days!
</span><span class="macro">assert_eq!</span>(
    span1.checked_add((span2, date(<span class="number">2008</span>, <span class="number">4</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">1</span>.month().days(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<p>Adding two spans can overflow, and this will result in an error:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="macro">assert!</span>(<span class="number">19_998</span>.years().checked_add(<span class="number">1</span>.year()).is_err());</code></pre></div>
<h5 id="example-adding-an-absolute-duration-to-a-span"><a class="doc-anchor" href="#example-adding-an-absolute-duration-to-a-span">§</a>Example: adding an absolute duration to a span</h5>
<p>This shows how one isn’t limited to just adding two spans together.
One can also add absolute durations to a span.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{SignedDuration, ToSpan};

<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_add(SignedDuration::from_mins(<span class="number">30</span>))<span class="question-mark">?</span>,
    <span class="number">1</span>.hour().minutes(<span class="number">30</span>).fieldwise(),
);
<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_add(Duration::from_secs(<span class="number">30 </span>* <span class="number">60</span>))<span class="question-mark">?</span>,
    <span class="number">1</span>.hour().minutes(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
<p>Note that even when adding an absolute duration, if the span contains
non-uniform units, you still need to provide a relative datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, ToSpan};

<span class="comment">// Might be 1 month or less than 1 month!
</span><span class="kw">let </span>dur = SignedDuration::from_hours(<span class="number">30 </span>* <span class="number">24</span>);
<span class="comment">// No relative datetime provided even when the span
// contains non-uniform units results in an error.
</span><span class="macro">assert!</span>(<span class="number">1</span>.month().checked_add(dur).is_err());
<span class="comment">// In this case, 30 days is one month (April).
</span><span class="macro">assert_eq!</span>(
    <span class="number">1</span>.month().checked_add((dur, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">2</span>.months().fieldwise(),
);
<span class="comment">// In this case, 30 days is less than one month (May).
</span><span class="macro">assert_eq!</span>(
    <span class="number">1</span>.month().checked_add((dur, date(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">1</span>)))<span class="question-mark">?</span>,
    <span class="number">1</span>.month().days(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1878-1885">Source</a><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;'a, A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'a&gt;&gt;&gt;(
    &amp;self,
    options: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Span.html#method.checked_add" title="method jiff::Span::checked_add"><code>Span::checked_add</code></a> with the given
duration negated.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Span.html#method.checked_add" title="method jiff::Span::checked_add"><code>Span::checked_add</code></a>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{SignedDuration, ToSpan};

<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_sub(<span class="number">30</span>.minutes())<span class="question-mark">?</span>,
    <span class="number">30</span>.minutes().fieldwise(),
);
<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_sub(SignedDuration::from_mins(<span class="number">30</span>))<span class="question-mark">?</span>,
    <span class="number">30</span>.minutes().fieldwise(),
);
<span class="macro">assert_eq!</span>(
    <span class="number">1</span>.hour().checked_sub(Duration::from_secs(<span class="number">30 </span>* <span class="number">60</span>))<span class="question-mark">?</span>,
    <span class="number">30</span>.minutes().fieldwise(),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#1982-1988">Source</a><h4 class="code-header">pub fn <a href="#method.compare" class="fn">compare</a>&lt;'a, C: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanCompare.html" title="struct jiff::SpanCompare">SpanCompare</a>&lt;'a&gt;&gt;&gt;(
    &amp;self,
    options: C,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Compares two spans in terms of how long they are. Negative spans are
considered shorter than the zero span.</p>
<p>Two spans compare equal when they correspond to the same duration
of time, even if their individual fields are different. This is in
contrast to the <code>Eq</code> trait implementation of <code>SpanFieldwise</code> (created
by <a href="struct.Span.html#method.fieldwise" title="method jiff::Span::fieldwise"><code>Span::fieldwise</code></a>), which performs exact field-wise comparisons.
This split exists because the comparison provided by this routine is
“heavy” in that it may need to do datetime arithmetic to return an
answer. In contrast, the <code>Eq</code> trait implementation is “cheap.”</p>
<p>This routine accepts anything that implements <code>Into&lt;SpanCompare&gt;</code>.
There are some trait implementations that make using this routine
ergonomic:</p>
<ul>
<li><code>From&lt;Span&gt; for SpanCompare</code> compares the given span to this one.</li>
<li><code>From&lt;(Span, civil::Date)&gt; for SpanArithmetic</code> compares the given
span to this one relative to the given date. There are also <code>From</code>
implementations for <code>civil::DateTime</code> and <code>Zoned</code>.</li>
</ul>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>If either of the spans being compared have a non-zero calendar unit
(units bigger than hours), then this routine requires a relative
datetime. If one is not provided, then an error is returned.</p>
<p>An error can also occur when adding either span to the relative
datetime given results in overflow.</p>
<p>Callers may use <a href="struct.SpanArithmetic.html#method.days_are_24_hours" title="method jiff::SpanArithmetic::days_are_24_hours"><code>SpanArithmetic::days_are_24_hours</code></a> as a special
marker instead of providing a relative civil date to indicate that
all days should be 24 hours long. This also results in treating all
weeks as seven 24 hour days (168 hours).</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span1 = <span class="number">3</span>.hours();
<span class="kw">let </span>span2 = <span class="number">180</span>.minutes();
<span class="macro">assert_eq!</span>(span1.compare(span2)<span class="question-mark">?</span>, std::cmp::Ordering::Equal);
<span class="comment">// But notice that the two spans are not equal via `Eq`:
</span><span class="macro">assert_ne!</span>(span1.fieldwise(), span2.fieldwise());
</code></pre></div>
<h5 id="example-negative-spans-are-less-than-zero"><a class="doc-anchor" href="#example-negative-spans-are-less-than-zero">§</a>Example: negative spans are less than zero</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::ToSpan;

<span class="kw">let </span>span1 = -<span class="number">1</span>.second();
<span class="kw">let </span>span2 = <span class="number">0</span>.seconds();
<span class="macro">assert_eq!</span>(span1.compare(span2)<span class="question-mark">?</span>, std::cmp::Ordering::Less);
</code></pre></div>
<h5 id="example-comparisons-take-dst-into-account"><a class="doc-anchor" href="#example-comparisons-take-dst-into-account">§</a>Example: comparisons take DST into account</h5>
<p>When a relative datetime is time zone aware, then DST is taken into
account when comparing spans:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, ToSpan, Zoned};

<span class="kw">let </span>span1 = <span class="number">79</span>.hours().minutes(<span class="number">10</span>);
<span class="kw">let </span>span2 = <span class="number">3</span>.days().hours(<span class="number">7</span>).seconds(<span class="number">630</span>);
<span class="kw">let </span>span3 = <span class="number">3</span>.days().hours(<span class="number">6</span>).minutes(<span class="number">50</span>);

<span class="kw">let </span>relative: Zoned = <span class="string">"2020-11-01T00-07[America/Los_Angeles]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>spans = [span1, span2, span3];
spans.sort_by(|s1, s2| s1.compare((s2, <span class="kw-2">&amp;</span>relative)).unwrap());
<span class="macro">assert_eq!</span>(
    spans.map(|sp| sp.fieldwise()),
    [span1.fieldwise(), span3.fieldwise(), span2.fieldwise()],
);

<span class="comment">// Compare with the result of sorting without taking DST into account.
// We can that by providing a relative civil date:
</span><span class="kw">let </span>relative = civil::date(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">1</span>);
spans.sort_by(|s1, s2| s1.compare((s2, relative)).unwrap());
<span class="macro">assert_eq!</span>(
    spans.map(|sp| sp.fieldwise()),
    [span3.fieldwise(), span1.fieldwise(), span2.fieldwise()],
);
</code></pre></div>
<p>See the examples for <a href="struct.Span.html#method.total" title="method jiff::Span::total"><code>Span::total</code></a> if you want to sort spans without
an <code>unwrap()</code> call.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.total" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#2126-2132">Source</a><h4 class="code-header">pub fn <a href="#method.total" class="fn">total</a>&lt;'a, T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanTotal.html" title="struct jiff::SpanTotal">SpanTotal</a>&lt;'a&gt;&gt;&gt;(
    &amp;self,
    options: T,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.f64.html">f64</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a floating point number representing the total number of a
specific unit (as given) in this span. If the span is not evenly
divisible by the requested units, then the number returned may have a
fractional component.</p>
<p>This routine accepts anything that implements <code>Into&lt;SpanTotal&gt;</code>. There
are some trait implementations that make using this routine ergonomic:</p>
<ul>
<li><code>From&lt;Unit&gt; for SpanTotal</code> computes a total for the given unit in
this span.</li>
<li><code>From&lt;(Unit, civil::Date)&gt; for SpanTotal</code> computes a total for the
given unit in this span, relative to the given date. There are also
<code>From</code> implementations for <code>civil::DateTime</code> and <code>Zoned</code>.</li>
</ul>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>If this span has any non-zero calendar unit (units bigger than hours),
then this routine requires a relative datetime. If one is not provided,
then an error is returned.</p>
<p>An error can also occur when adding the span to the relative
datetime given results in overflow.</p>
<p>Callers may use <a href="struct.SpanArithmetic.html#method.days_are_24_hours" title="method jiff::SpanArithmetic::days_are_24_hours"><code>SpanArithmetic::days_are_24_hours</code></a> as a special
marker instead of providing a relative civil date to indicate that
all days should be 24 hours long. This also results in treating all
weeks as seven 24 hour days (168 hours).</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<p>This example shows how to find the number of seconds in a particular
span:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">3</span>.hours().minutes(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(span.total(Unit::Second)<span class="question-mark">?</span>, <span class="number">11_400.0</span>);
</code></pre></div>
<h5 id="example-24-hour-days"><a class="doc-anchor" href="#example-24-hour-days">§</a>Example: 24 hour days</h5>
<p>This shows how to find the total number of 24 hour days in
<code>123,456,789</code> seconds.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanTotal, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">123_456_789</span>.seconds();
<span class="macro">assert_eq!</span>(
    span.total(SpanTotal::from(Unit::Day).days_are_24_hours())<span class="question-mark">?</span>,
    <span class="number">1428.8980208333332</span>,
);
</code></pre></div>
<h5 id="example-dst-is-taken-into-account"><a class="doc-anchor" href="#example-dst-is-taken-into-account">§</a>Example: DST is taken into account</h5>
<p>The month of March 2024 in <code>America/New_York</code> had 31 days, but one of
those days was 23 hours long due a transition into daylight saving
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">744</span>.hours();
<span class="kw">let </span>relative = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// Because of the short day, 744 hours is actually a little *more* than
// 1 month starting from 2024-03-01.
</span><span class="macro">assert_eq!</span>(span.total((Unit::Month, <span class="kw-2">&amp;</span>relative))<span class="question-mark">?</span>, <span class="number">1.0013888888888889</span>);
</code></pre></div>
<p>Now compare what happens when the relative datetime is civil and not
time zone aware:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">744</span>.hours();
<span class="kw">let </span>relative = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(span.total((Unit::Month, relative))<span class="question-mark">?</span>, <span class="number">1.0</span>);
</code></pre></div>
<h5 id="example-infallible-sorting"><a class="doc-anchor" href="#example-infallible-sorting">§</a>Example: infallible sorting</h5>
<p>The sorting example in <a href="struct.Span.html#method.compare" title="method jiff::Span::compare"><code>Span::compare</code></a> has to use <code>unwrap()</code> in
its <code>sort_by(..)</code> call because <code>Span::compare</code> may fail and there
is no “fallible” sorting routine in Rust’s standard library (as of
2024-07-07). While the ways in which <code>Span::compare</code> can fail for
a valid configuration are limited to overflow for “extreme” values, it
is possible to sort spans infallibly by computing floating point
representations for each span up-front:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Date, ToSpan, Unit, Zoned};

<span class="kw">let </span>span1 = <span class="number">79</span>.hours().minutes(<span class="number">10</span>);
<span class="kw">let </span>span2 = <span class="number">3</span>.days().hours(<span class="number">7</span>).seconds(<span class="number">630</span>);
<span class="kw">let </span>span3 = <span class="number">3</span>.days().hours(<span class="number">6</span>).minutes(<span class="number">50</span>);

<span class="kw">let </span>relative: Zoned = <span class="string">"2020-11-01T00-07[America/Los_Angeles]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>spans = [
    (span1, span1.total((Unit::Day, <span class="kw-2">&amp;</span>relative))<span class="question-mark">?</span>),
    (span2, span2.total((Unit::Day, <span class="kw-2">&amp;</span>relative))<span class="question-mark">?</span>),
    (span3, span3.total((Unit::Day, <span class="kw-2">&amp;</span>relative))<span class="question-mark">?</span>),
];
spans.sort_by(|<span class="kw-2">&amp;</span>(<span class="kw">_</span>, total1), <span class="kw-2">&amp;</span>(<span class="kw">_</span>, total2)| total1.total_cmp(<span class="kw-2">&amp;</span>total2));
<span class="macro">assert_eq!</span>(
    spans.map(|(sp, <span class="kw">_</span>)| sp.fieldwise()),
    [span1.fieldwise(), span3.fieldwise(), span2.fieldwise()],
);

<span class="comment">// Compare with the result of sorting without taking DST into account.
// We do that here by providing a relative civil date.
</span><span class="kw">let </span>relative: Date = <span class="string">"2020-11-01"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>spans = [
    (span1, span1.total((Unit::Day, relative))<span class="question-mark">?</span>),
    (span2, span2.total((Unit::Day, relative))<span class="question-mark">?</span>),
    (span3, span3.total((Unit::Day, relative))<span class="question-mark">?</span>),
];
spans.sort_by(|<span class="kw-2">&amp;</span>(<span class="kw">_</span>, total1), <span class="kw-2">&amp;</span>(<span class="kw">_</span>, total2)| total1.total_cmp(<span class="kw-2">&amp;</span>total2));
<span class="macro">assert_eq!</span>(
    spans.map(|(sp, <span class="kw">_</span>)| sp.fieldwise()),
    [span3.fieldwise(), span1.fieldwise(), span2.fieldwise()],
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#2317-2323">Source</a><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;'a, R: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanRound.html" title="struct jiff::SpanRound">SpanRound</a>&lt;'a&gt;&gt;&gt;(
    self,
    options: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a new span that is balanced and rounded.</p>
<p>Rounding a span has a number of parameters, all of which are optional.
When no parameters are given, then no rounding or balancing is done,
and the span as given is returned. That is, it’s a no-op.</p>
<p>The parameters are, in brief:</p>
<ul>
<li><a href="struct.SpanRound.html#method.largest" title="method jiff::SpanRound::largest"><code>SpanRound::largest</code></a> sets the largest <a href="enum.Unit.html" title="enum jiff::Unit"><code>Unit</code></a> that is allowed to
be non-zero in the span returned. When <em>only</em> the largest unit is set,
rounding itself doesn’t occur and instead the span is merely balanced.</li>
<li><a href="struct.SpanRound.html#method.smallest" title="method jiff::SpanRound::smallest"><code>SpanRound::smallest</code></a> sets the smallest <a href="enum.Unit.html" title="enum jiff::Unit"><code>Unit</code></a> that is allowed to
be non-zero in the span returned. By default, it is set to
<a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, i.e., no rounding occurs. When the smallest unit
is set to something bigger than nanoseconds, then the non-zero units
in the span smaller than the smallest unit are used to determine how
the span should be rounded. For example, rounding <code>1 hour 59 minutes</code>
to the nearest hour using the default rounding mode would produce
<code>2 hours</code>.</li>
<li><a href="struct.SpanRound.html#method.mode" title="method jiff::SpanRound::mode"><code>SpanRound::mode</code></a> determines how to handle the remainder when
rounding. The default is <a href="enum.RoundMode.html#variant.HalfExpand" title="variant jiff::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which corresponds
to how you were taught to round in school. Alternative modes, like
<a href="enum.RoundMode.html#variant.Trunc" title="variant jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a>, exist too. For example, a truncating rounding of
<code>1 hour 59 minutes</code> to the nearest hour would produce <code>1 hour</code>.</li>
<li><a href="struct.SpanRound.html#method.increment" title="method jiff::SpanRound::increment"><code>SpanRound::increment</code></a> sets the rounding granularity to use for
the configured smallest unit. For example, if the smallest unit is
minutes and the increment is 5, then the span returned will always have
its minute units set to a multiple of <code>5</code>.</li>
<li><a href="struct.SpanRound.html#method.relative" title="method jiff::SpanRound::relative"><code>SpanRound::relative</code></a> sets the datetime from which to interpret the
span. This is required when rounding spans with calendar units (years,
months or weeks). When a relative datetime is time zone aware, then
rounding accounts for the fact that not all days are 24 hours long.
When a relative datetime is omitted or is civil (not time zone aware),
then days are always 24 hours long.</li>
</ul>
<h5 id="constructing-a-spanround"><a class="doc-anchor" href="#constructing-a-spanround">§</a>Constructing a <a href="struct.SpanRound.html" title="struct jiff::SpanRound"><code>SpanRound</code></a></h5>
<p>This routine accepts anything that implements <code>Into&lt;SpanRound&gt;</code>. There
are a few key trait implementations that make this convenient:</p>
<ul>
<li><code>From&lt;Unit&gt; for SpanRound</code> will construct a rounding configuration
where the smallest unit is set to the one given.</li>
<li><code>From&lt;(Unit, i64)&gt; for SpanRound</code> will construct a rounding
configuration where the smallest unit and the rounding increment are
set to the ones given.</li>
</ul>
<p>To set other options (like the largest unit, the rounding mode and the
relative datetime), one must explicitly create a <code>SpanRound</code> and pass
it to this routine.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>In general, there are two main ways for rounding to fail: an improper
configuration like trying to round a span with calendar units but
without a relative datetime, or when overflow occurs. Overflow can
occur when the span, added to the relative datetime if given, would
exceed the minimum or maximum datetime values. Overflow can also occur
if the span is too big to fit into the requested unit configuration.
For example, a span like <code>19_998.years()</code> cannot be represented with a
64-bit integer number of nanoseconds.</p>
<p>Callers may use <a href="struct.SpanArithmetic.html#method.days_are_24_hours" title="method jiff::SpanArithmetic::days_are_24_hours"><code>SpanArithmetic::days_are_24_hours</code></a> as a special
marker instead of providing a relative civil date to indicate that
all days should be 24 hours long. This also results in treating all
weeks as seven 24 hour days (168 hours).</p>
<h5 id="example-balancing"><a class="doc-anchor" href="#example-balancing">§</a>Example: balancing</h5>
<p>This example demonstrates balancing, not rounding. And in particular,
this example shows how to balance a span as much as possible (i.e.,
with units of hours or smaller) without needing to specify a relative
datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">123_456_789_123_456_789i64</span>.nanoseconds();
<span class="macro">assert_eq!</span>(
    span.round(SpanRound::new().largest(Unit::Hour))<span class="question-mark">?</span>.fieldwise(),
    <span class="number">34_293</span>.hours().minutes(<span class="number">33</span>).seconds(<span class="number">9</span>)
        .milliseconds(<span class="number">123</span>).microseconds(<span class="number">456</span>).nanoseconds(<span class="number">789</span>),
);
</code></pre></div>
<p>Or you can opt into invariant 24-hour days (and 7-day weeks) without a
relative date with <a href="struct.SpanRound.html#method.days_are_24_hours" title="method jiff::SpanRound::days_are_24_hours"><code>SpanRound::days_are_24_hours</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">123_456_789_123_456_789i64</span>.nanoseconds();
<span class="macro">assert_eq!</span>(
    span.round(
        SpanRound::new().largest(Unit::Day).days_are_24_hours(),
    )<span class="question-mark">?</span>.fieldwise(),
    <span class="number">1_428</span>.days()
        .hours(<span class="number">21</span>).minutes(<span class="number">33</span>).seconds(<span class="number">9</span>)
        .milliseconds(<span class="number">123</span>).microseconds(<span class="number">456</span>).nanoseconds(<span class="number">789</span>),
);
</code></pre></div>
<h5 id="example-balancing-and-rounding"><a class="doc-anchor" href="#example-balancing-and-rounding">§</a>Example: balancing and rounding</h5>
<p>This example is like the one before it, but where we round to the
nearest second:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">123_456_789_123_456_789i64</span>.nanoseconds();
<span class="macro">assert_eq!</span>(
    span.round(SpanRound::new().largest(Unit::Hour).smallest(Unit::Second))<span class="question-mark">?</span>,
    <span class="number">34_293</span>.hours().minutes(<span class="number">33</span>).seconds(<span class="number">9</span>).fieldwise(),
);
</code></pre></div>
<p>Or, just rounding to the nearest hour can make use of the
<code>From&lt;Unit&gt; for SpanRound</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">123_456_789_123_456_789i64</span>.nanoseconds();
<span class="macro">assert_eq!</span>(span.round(Unit::Hour)<span class="question-mark">?</span>, <span class="number">34_294</span>.hours().fieldwise());
</code></pre></div>
<h5 id="example-balancing-with-a-relative-datetime"><a class="doc-anchor" href="#example-balancing-with-a-relative-datetime">§</a>Example: balancing with a relative datetime</h5>
<p>Even with calendar units, so long as a relative datetime is provided,
it’s easy to turn days into bigger units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SpanRound, ToSpan, Unit};

<span class="kw">let </span>span = <span class="number">1_000</span>.days();
<span class="kw">let </span>relative = date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);
<span class="kw">let </span>options = SpanRound::new().largest(Unit::Year).relative(relative);
<span class="macro">assert_eq!</span>(span.round(options)<span class="question-mark">?</span>, <span class="number">2</span>.years().months(<span class="number">8</span>).days(<span class="number">26</span>).fieldwise());
</code></pre></div>
<h5 id="example-round-to-the-nearest-half-hour"><a class="doc-anchor" href="#example-round-to-the-nearest-half-hour">§</a>Example: round to the nearest half-hour</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Span, ToSpan, Unit};

<span class="kw">let </span>span: Span = <span class="string">"PT23h50m3.123s"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.round((Unit::Minute, <span class="number">30</span>))<span class="question-mark">?</span>, <span class="number">24</span>.hours().fieldwise());
</code></pre></div>
<h5 id="example-yearly-quarters-in-a-span"><a class="doc-anchor" href="#example-yearly-quarters-in-a-span">§</a>Example: yearly quarters in a span</h5>
<p>This example shows how to find how many full 3 month quarters are in a
particular span of time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, RoundMode, SpanRound, ToSpan, Unit};

<span class="kw">let </span>span1 = <span class="number">10</span>.months().days(<span class="number">15</span>);
<span class="kw">let </span>round = SpanRound::new()
    .smallest(Unit::Month)
    .increment(<span class="number">3</span>)
    .mode(RoundMode::Trunc)
    <span class="comment">// A relative datetime must be provided when
    // rounding involves calendar units.
    </span>.relative(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>));
<span class="kw">let </span>span2 = span1.round(round)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span2.get_months() / <span class="number">3</span>, <span class="number">3</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_duration" class="method"><a class="src rightside" href="../src/jiff/span.rs.html#2389-2423">Source</a><h4 class="code-header">pub fn <a href="#method.to_duration" class="fn">to_duration</a>&lt;'a, R: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SpanRelativeTo.html" title="struct jiff::SpanRelativeTo">SpanRelativeTo</a>&lt;'a&gt;&gt;&gt;(
    &amp;self,
    relative: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Span</code> to a <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> relative to the date given.</p>
<p>In most cases, it is unlikely that you’ll need to use this routine to
convert a <code>Span</code> to a <code>SignedDuration</code>. Namely, by default:</p>
<ul>
<li><a href="struct.Zoned.html#method.until" title="method jiff::Zoned::until"><code>Zoned::until</code></a> guarantees that the biggest non-zero unit is hours.</li>
<li><a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a> guarantees that the biggest non-zero unit is
seconds.</li>
<li><a href="civil/struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a> guarantees that the biggest non-zero unit is
days.</li>
<li><a href="civil/struct.Date.html#method.until" title="method jiff::civil::Date::until"><code>Date::until</code></a> guarantees that the biggest non-zero unit is days.</li>
<li><a href="civil/struct.Time.html#method.until" title="method jiff::civil::Time::until"><code>Time::until</code></a> guarantees that the biggest non-zero unit is hours.</li>
</ul>
<p>In the above, only <a href="civil/struct.DateTime.html#method.until" title="method jiff::civil::DateTime::until"><code>DateTime::until</code></a> and <a href="civil/struct.Date.html#method.until" title="method jiff::civil::Date::until"><code>Date::until</code></a> return
calendar units by default. In which case, one may pass
<a href="struct.SpanRelativeTo.html#method.days_are_24_hours" title="associated function jiff::SpanRelativeTo::days_are_24_hours"><code>SpanRelativeTo::days_are_24_hours</code></a> or an actual relative date to
resolve the length of a day.</p>
<p>Of course, any of the above can be changed by asking, for example,
<code>Zoned::until</code> to return units up to years.</p>
<h5 id="errors-15"><a class="doc-anchor" href="#errors-15">§</a>Errors</h5>
<p>This returns an error if adding this span to the date given results in
overflow. This can also return an error if one uses
<a href="struct.SpanRelativeTo.html#method.days_are_24_hours" title="associated function jiff::SpanRelativeTo::days_are_24_hours"><code>SpanRelativeTo::days_are_24_hours</code></a> with a <code>Span</code> that has non-zero
units greater than weeks.</p>
<h5 id="example-converting-a-span-with-calendar-units-to-a-signedduration"><a class="doc-anchor" href="#example-converting-a-span-with-calendar-units-to-a-signedduration">§</a>Example: converting a span with calendar units to a <code>SignedDuration</code></h5>
<p>This compares the number of seconds in a non-leap year with a leap
year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, ToSpan};

<span class="kw">let </span>span = <span class="number">1</span>.year();

<span class="kw">let </span>duration = span.to_duration(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, SignedDuration::from_secs(<span class="number">31_622_400</span>));
<span class="kw">let </span>duration = span.to_duration(date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, SignedDuration::from_secs(<span class="number">31_536_000</span>));
</code></pre></div>
<h5 id="example-converting-a-span-without-a-relative-datetime"><a class="doc-anchor" href="#example-converting-a-span-without-a-relative-datetime">§</a>Example: converting a span without a relative datetime</h5>
<p>If for some reason it doesn’t make sense to include a
relative datetime, you can use this routine to convert a
<code>Span</code> with units up to weeks to a <code>SignedDuration</code> via the
<a href="struct.SpanRelativeTo.html#method.days_are_24_hours" title="associated function jiff::SpanRelativeTo::days_are_24_hours"><code>SpanRelativeTo::days_are_24_hours</code></a> marker:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, SpanRelativeTo, ToSpan};

<span class="kw">let </span>span = <span class="number">1</span>.week().days(<span class="number">1</span>);

<span class="kw">let </span>duration = span.to_duration(SpanRelativeTo::days_are_24_hours())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, SignedDuration::from_hours(<span class="number">192</span>));
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-%26Zoned" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3356-3364">Source</a><a href="#impl-Add%3CSpan%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a span of time to a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method jiff::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-13" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3357">Source</a><a href="#associatedtype.Output-13" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3360-3363">Source</a><a href="#method.add-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Date" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2316-2323">Source</a><a href="#impl-Add%3CSpan%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h3><div class="docblock"><p>Adds a span of time to a date.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.Date.html#method.checked_add" title="method jiff::civil::Date::checked_add"><code>Date::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2317">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2320-2322">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2620-2627">Source</a><a href="#impl-Add%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a span of time to a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2621">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2624-2626">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Offset" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1142-1150">Source</a><a href="#impl-Add%3CSpan%3E-for-Offset" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h3><div class="docblock"><p>Adds a span of time to an offset. This panics on overflow.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="tz/struct.Offset.html#method.checked_add" title="method jiff::tz::Offset::checked_add"><code>Offset::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-11" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1143">Source</a><a href="#associatedtype.Output-11" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1146-1149">Source</a><a href="#method.add-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1950-1957">Source</a><a href="#impl-Add%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="civil/struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1951">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1954-1956">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2635-2642">Source</a><a href="#impl-Add%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a span of time to a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2636">Source</a><a href="#associatedtype.Output-9" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2639-2641">Source</a><a href="#method.add-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Date" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2329-2334">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h3><div class="docblock"><p>Adds a span of time to a date in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.Date.html#method.checked_add" title="method jiff::civil::Date::checked_add"><code>Date::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2331-2333">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2633-2638">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Adds a span of time to a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.DateTime.html#method.checked_add" title="method jiff::civil::DateTime::checked_add"><code>DateTime::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2635-2637">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Offset" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1155-1160">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Offset" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h3><div class="docblock"><p>Adds a span of time to an offset in place. This panics on overflow.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="tz/struct.Offset.html#method.checked_add" title="method jiff::tz::Offset::checked_add"><code>Offset::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1157-1159">Source</a><a href="#method.add_assign-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1962-1967">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="civil/struct.Time.html#method.checked_add" title="method jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1964-1966">Source</a><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2650-2655">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a span of time to a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2652-2654">Source</a><a href="#method.add_assign-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Zoned" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3370-3375">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h3><div class="docblock"><p>Adds a span of time to a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_add" title="method jiff::Zoned::checked_add"><code>Zoned::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3372-3374">Source</a><a href="#method.add_assign-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#709">Source</a><a href="#impl-Clone-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#709">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3240-3249">Source</a><a href="#impl-Debug-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3242-3248">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3220-3238">Source</a><a href="#impl-Default-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3222-3237">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3251-3266">Source</a><a href="#impl-Display-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3253-3265">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-DateArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2648-2652">Source</a><a href="#impl-From%3C%26Span%3E-for-DateArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateArithmetic.html" title="struct jiff::civil::DateArithmetic">DateArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2649-2651">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateArithmetic.html" title="struct jiff::civil::DateArithmetic">DateArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-DateTimeArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2967-2971">Source</a><a href="#impl-From%3C%26Span%3E-for-DateTimeArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2968-2970">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-OffsetArithmetic" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1434-1438">Source</a><a href="#impl-From%3C%26Span%3E-for-OffsetArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.OffsetArithmetic.html" title="struct jiff::tz::OffsetArithmetic">OffsetArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-15" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1435-1437">Source</a><a href="#method.from-15" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="tz/struct.OffsetArithmetic.html" title="struct jiff::tz::OffsetArithmetic">OffsetArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-SpanArithmetic%3C'static%3E" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#4380-4385">Source</a><a href="#impl-From%3C%26Span%3E-for-SpanArithmetic%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#4381-4384">Source</a><a href="#method.from-9" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-SpanCompare%3C'static%3E" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#4635-4639">Source</a><a href="#impl-From%3C%26Span%3E-for-SpanCompare%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanCompare.html" title="struct jiff::SpanCompare">SpanCompare</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#4636-4638">Source</a><a href="#method.from-11" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.SpanCompare.html" title="struct jiff::SpanCompare">SpanCompare</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-TimeArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#2334-2338">Source</a><a href="#impl-From%3C%26Span%3E-for-TimeArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#2335-2337">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-TimestampArithmetic" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3140-3144">Source</a><a href="#impl-From%3C%26Span%3E-for-TimestampArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-13" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3141-3143">Source</a><a href="#method.from-13" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Span%3E-for-ZonedArithmetic" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3716-3720">Source</a><a href="#impl-From%3C%26Span%3E-for-ZonedArithmetic" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.ZonedArithmetic.html" title="struct jiff::ZonedArithmetic">ZonedArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-17" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3717-3719">Source</a><a href="#method.from-17" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.ZonedArithmetic.html" title="struct jiff::ZonedArithmetic">ZonedArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-DateArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2627-2632">Source</a><a href="#impl-From%3CSpan%3E-for-DateArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateArithmetic.html" title="struct jiff::civil::DateArithmetic">DateArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2628-2631">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateArithmetic.html" title="struct jiff::civil::DateArithmetic">DateArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-DateTimeArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2946-2951">Source</a><a href="#impl-From%3CSpan%3E-for-DateTimeArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2947-2950">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateTimeArithmetic.html" title="struct jiff::civil::DateTimeArithmetic">DateTimeArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-OffsetArithmetic" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1413-1418">Source</a><a href="#impl-From%3CSpan%3E-for-OffsetArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.OffsetArithmetic.html" title="struct jiff::tz::OffsetArithmetic">OffsetArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-14" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1414-1417">Source</a><a href="#method.from-14" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="tz/struct.OffsetArithmetic.html" title="struct jiff::tz::OffsetArithmetic">OffsetArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-SpanArithmetic%3C'static%3E" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#4373-4378">Source</a><a href="#impl-From%3CSpan%3E-for-SpanArithmetic%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#4374-4377">Source</a><a href="#method.from-8" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.SpanArithmetic.html" title="struct jiff::SpanArithmetic">SpanArithmetic</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-SpanCompare%3C'static%3E" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#4629-4633">Source</a><a href="#impl-From%3CSpan%3E-for-SpanCompare%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanCompare.html" title="struct jiff::SpanCompare">SpanCompare</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#4630-4632">Source</a><a href="#method.from-10" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.SpanCompare.html" title="struct jiff::SpanCompare">SpanCompare</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-SpanFieldwise" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3832-3836">Source</a><a href="#impl-From%3CSpan%3E-for-SpanFieldwise" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3833-3835">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-TimeArithmetic" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#2313-2318">Source</a><a href="#impl-From%3CSpan%3E-for-TimeArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#2314-2317">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.TimeArithmetic.html" title="struct jiff::civil::TimeArithmetic">TimeArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-TimestampArithmetic" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3119-3124">Source</a><a href="#impl-From%3CSpan%3E-for-TimestampArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-12" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3120-3123">Source</a><a href="#method.from-12" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpan%3E-for-ZonedArithmetic" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3695-3700">Source</a><a href="#impl-From%3CSpan%3E-for-ZonedArithmetic" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.ZonedArithmetic.html" title="struct jiff::ZonedArithmetic">ZonedArithmetic</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-16" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3696-3699">Source</a><a href="#method.from-16" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.ZonedArithmetic.html" title="struct jiff::ZonedArithmetic">ZonedArithmetic</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CSpanFieldwise%3E-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3838-3842">Source</a><a href="#impl-From%3CSpanFieldwise%3E-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>&gt; for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3839-3841">Source</a><a href="#method.from-7" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(span: <a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3268-3275">Source</a><a href="#impl-FromStr-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3269">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3272-3274">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3CSpan%3E-for-i64" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3302-3310">Source</a><a href="#impl-Mul%3CSpan%3E-for-i64" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h3><div class="docblock"><p>This multiplies each unit in a span by an integer.</p>
</div></section></summary><div class="docblock"><p>This panics on overflow. For checked arithmetic, use <a href="struct.Span.html#method.checked_mul" title="method jiff::Span::checked_mul"><code>Span::checked_mul</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3303">Source</a><a href="#associatedtype.Output-8" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3306-3309">Source</a><a href="#method.mul-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Mul%3Ci64%3E-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3289-3297">Source</a><a href="#impl-Mul%3Ci64%3E-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html" title="trait core::ops::arith::Mul">Mul</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>&gt; for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>This multiplies each unit in a span by an integer.</p>
</div></section></summary><div class="docblock"><p>This panics on overflow. For checked arithmetic, use <a href="struct.Span.html#method.checked_mul" title="method jiff::Span::checked_mul"><code>Span::checked_mul</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3290">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>*</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.mul" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3293-3296">Source</a><a href="#method.mul" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#tymethod.mul" class="fn">mul</a>(self, rhs: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>*</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Mul.html#tymethod.mul">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Neg-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3277-3284">Source</a><a href="#impl-Neg-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Neg.html" title="trait core::ops::arith::Neg">Neg</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3278">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.neg" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3281-3283">Source</a><a href="#method.neg" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Neg.html#tymethod.neg" class="fn">neg</a>(self) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the unary <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Neg.html#tymethod.neg">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CSpan%3E-for-SpanFieldwise" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3798-3802">Source</a><a href="#impl-PartialEq%3CSpan%3E-for-SpanFieldwise" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3799-3801">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CSpanFieldwise%3E-for-%26Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3810-3814">Source</a><a href="#impl-PartialEq%3CSpanFieldwise%3E-for-%26Span" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>&gt; for &amp;'a <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3811-3813">Source</a><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CSpanFieldwise%3E-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3804-3808">Source</a><a href="#impl-PartialEq%3CSpanFieldwise%3E-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>&gt; for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3805-3807">Source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.SpanFieldwise.html" title="struct jiff::SpanFieldwise">SpanFieldwise</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-%26Zoned" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3381-3389">Source</a><a href="#impl-Sub%3CSpan%3E-for-%26Zoned" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for &amp;'a <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a span of time from a zoned datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method jiff::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-14" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3382">Source</a><a href="#associatedtype.Output-14" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3385-3388">Source</a><a href="#method.sub-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Date" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2340-2347">Source</a><a href="#impl-Sub%3CSpan%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h3><div class="docblock"><p>Subtracts a span of time from a date.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.Date.html#method.checked_sub" title="method jiff::civil::Date::checked_sub"><code>Date::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2341">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2344-2346">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2644-2652">Source</a><a href="#impl-Sub%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a span of time from a datetime.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2645">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2648-2651">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Offset" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1165-1173">Source</a><a href="#impl-Sub%3CSpan%3E-for-Offset" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h3><div class="docblock"><p>Subtracts a span of time from an offset. This panics on overflow.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="tz/struct.Offset.html#method.checked_sub" title="method jiff::tz::Offset::checked_sub"><code>Offset::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-12" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1166">Source</a><a href="#associatedtype.Output-12" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1169-1172">Source</a><a href="#method.sub-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1972-1979">Source</a><a href="#impl-Sub%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="civil/struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1973">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1976-1978">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2663-2671">Source</a><a href="#impl-Sub%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a span of time from a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2664">Source</a><a href="#associatedtype.Output-10" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2667-2670">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Date" class="impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2353-2358">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Date" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a></h3><div class="docblock"><p>Subtracts a span of time from a date in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.Date.html#method.checked_sub" title="method jiff::civil::Date::checked_sub"><code>Date::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/date.rs.html#2355-2357">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-DateTime" class="impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2658-2663">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-DateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h3><div class="docblock"><p>Subtracts a span of time from a datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="civil/struct.DateTime.html#method.checked_sub" title="method jiff::civil::DateTime::checked_sub"><code>DateTime::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/datetime.rs.html#2660-2662">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Offset" class="impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1178-1183">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Offset" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a></h3><div class="docblock"><p>Subtracts a span of time from an offset in place. This panics on overflow.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="tz/struct.Offset.html#method.checked_sub" title="method jiff::tz::Offset::checked_sub"><code>Offset::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/tz/offset.rs.html#1180-1182">Source</a><a href="#method.sub_assign-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Time" class="impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1984-1989">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="civil/struct.Time.html#method.checked_sub" title="method jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/civil/time.rs.html#1986-1988">Source</a><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2679-2684">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a span of time from a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2681-2683">Source</a><a href="#method.sub_assign-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Zoned" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3395-3400">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Zoned" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h3><div class="docblock"><p>Subtracts a span of time from a zoned datetime in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Zoned.html#method.checked_sub" title="method jiff::Zoned::checked_sub"><code>Zoned::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#3397-3399">Source</a><a href="#method.sub_assign-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CDuration%3E-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3444-3470">Source</a><a href="#impl-TryFrom%3CDuration%3E-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Converts a <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a> to a <code>Span</code>.</p>
</div></section></summary><div class="docblock"><p>The span returned from this conversion will only ever have non-zero units
of seconds or smaller.</p>
<h4 id="errors-17"><a class="doc-anchor" href="#errors-17">§</a>Errors</h4>
<p>This only fails when the given <code>Duration</code> overflows the maximum number of
seconds representable by a <code>Span</code>.</p>
<h4 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h4>
<p>This shows a basic conversion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>duration = Duration::new(<span class="number">86_400</span>, <span class="number">123_456_789</span>);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>;
<span class="comment">// A duration-to-span conversion always results in a span with
// non-zero units no bigger than seconds.
</span><span class="macro">assert_eq!</span>(
    span.fieldwise(),
    <span class="number">86_400</span>.seconds().milliseconds(<span class="number">123</span>).microseconds(<span class="number">456</span>).nanoseconds(<span class="number">789</span>),
);
</code></pre></div>
<h4 id="example-rounding"><a class="doc-anchor" href="#example-rounding">§</a>Example: rounding</h4>
<p>This example shows how to convert a <code>Duration</code> to a <code>Span</code>, and then round
it up to bigger units given a relative date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::date, Span, SpanRound, ToSpan, Unit};

<span class="kw">let </span>duration = Duration::new(<span class="number">450 </span>* <span class="number">86_401</span>, <span class="number">0</span>);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>;
<span class="comment">// We get back a simple span of just seconds:
</span><span class="macro">assert_eq!</span>(span.fieldwise(), Span::new().seconds(<span class="number">450 </span>* <span class="number">86_401</span>));
<span class="comment">// But we can balance it up to bigger units:
</span><span class="kw">let </span>options = SpanRound::new()
    .largest(Unit::Year)
    .relative(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>));
<span class="macro">assert_eq!</span>(
    span.round(options)<span class="question-mark">?</span>,
    <span class="number">1</span>.year().months(<span class="number">2</span>).days(<span class="number">25</span>).minutes(<span class="number">7</span>).seconds(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3445">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3448-3469">Source</a><a href="#method.try_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(d: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CSignedDuration%3E-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3572-3596">Source</a><a href="#impl-TryFrom%3CSignedDuration%3E-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3><div class="docblock"><p>Converts a <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> to a <code>Span</code>.</p>
</div></section></summary><div class="docblock"><p>The span returned from this conversion will only ever have non-zero units
of seconds or smaller.</p>
<h4 id="errors-19"><a class="doc-anchor" href="#errors-19">§</a>Errors</h4>
<p>This only fails when the given <code>SignedDuration</code> overflows the maximum
number of seconds representable by a <code>Span</code>.</p>
<h4 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h4>
<p>This shows a basic conversion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Span, ToSpan};

<span class="kw">let </span>duration = SignedDuration::new(<span class="number">86_400</span>, <span class="number">123_456_789</span>);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>;
<span class="comment">// A duration-to-span conversion always results in a span with
// non-zero units no bigger than seconds.
</span><span class="macro">assert_eq!</span>(
    span.fieldwise(),
    <span class="number">86_400</span>.seconds().milliseconds(<span class="number">123</span>).microseconds(<span class="number">456</span>).nanoseconds(<span class="number">789</span>),
);
</code></pre></div>
<h4 id="example-rounding-1"><a class="doc-anchor" href="#example-rounding-1">§</a>Example: rounding</h4>
<p>This example shows how to convert a <code>SignedDuration</code> to a <code>Span</code>, and then
round it up to bigger units given a relative date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, SignedDuration, Span, SpanRound, ToSpan, Unit};

<span class="kw">let </span>duration = SignedDuration::new(<span class="number">450 </span>* <span class="number">86_401</span>, <span class="number">0</span>);
<span class="kw">let </span>span = Span::try_from(duration)<span class="question-mark">?</span>;
<span class="comment">// We get back a simple span of just seconds:
</span><span class="macro">assert_eq!</span>(span.fieldwise(), Span::new().seconds(<span class="number">450 </span>* <span class="number">86_401</span>));
<span class="comment">// But we can balance it up to bigger units:
</span><span class="kw">let </span>options = SpanRound::new()
    .largest(Unit::Year)
    .relative(date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>));
<span class="macro">assert_eq!</span>(
    span.round(options)<span class="question-mark">?</span>,
    <span class="number">1</span>.year().months(<span class="number">2</span>).days(<span class="number">25</span>).minutes(<span class="number">7</span>).seconds(<span class="number">30</span>).fieldwise(),
);
</code></pre></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3573">Source</a><a href="#associatedtype.Error-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3576-3595">Source</a><a href="#method.try_from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(d: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CSpan%3E-for-Duration" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3372-3386">Source</a><a href="#impl-TryFrom%3CSpan%3E-for-Duration" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a></h3><div class="docblock"><p>Converts a <code>Span</code> to a <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>.</p>
</div></section></summary><div class="docblock"><h4 id="errors-16"><a class="doc-anchor" href="#errors-16">§</a>Errors</h4>
<p>This can fail for only two reasons:</p>
<ul>
<li>The span is negative. This is an error because a <code>std::time::Duration</code> is
unsigned.)</li>
<li>The span has any non-zero units greater than hours. This is an error
because it’s impossible to determine the length of, e.g., a month without
a reference date.</li>
</ul>
<p>This can never result in overflow because a <code>Duration</code> can represent a
bigger span of time than <code>Span</code> when limited to units of hours or lower.</p>
<p>If you need to convert a <code>Span</code> to a <code>Duration</code> that has non-zero
units bigger than hours, then please use <a href="struct.Span.html#method.to_duration" title="method jiff::Span::to_duration"><code>Span::to_duration</code></a> with a
corresponding relative date.</p>
<h4 id="example-maximal-span"><a class="doc-anchor" href="#example-maximal-span">§</a>Example: maximal span</h4>
<p>This example shows the maximum possible span using units of hours or
smaller, and the corresponding <code>Duration</code> value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::Span;

<span class="kw">let </span>sp = Span::new()
    .hours(<span class="number">175_307_616</span>)
    .minutes(<span class="number">10_518_456_960i64</span>)
    .seconds(<span class="number">631_107_417_600i64</span>)
    .milliseconds(<span class="number">631_107_417_600_000i64</span>)
    .microseconds(<span class="number">631_107_417_600_000_000i64</span>)
    .nanoseconds(<span class="number">9_223_372_036_854_775_807i64</span>);
<span class="kw">let </span>duration = Duration::try_from(sp)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, Duration::new(<span class="number">3_164_760_460_036</span>, <span class="number">854_775_807</span>));
</code></pre></div>
<h4 id="example-converting-a-negative-span"><a class="doc-anchor" href="#example-converting-a-negative-span">§</a>Example: converting a negative span</h4>
<p>Since a <code>Span</code> is signed and a <code>Duration</code> is unsigned, converting
a negative <code>Span</code> to <code>Duration</code> will always fail. One can use
<a href="struct.Span.html#method.signum" title="method jiff::Span::signum"><code>Span::signum</code></a> to get the sign of the span and <a href="struct.Span.html#method.abs" title="method jiff::Span::abs"><code>Span::abs</code></a> to make the
span positive before converting it to a <code>Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{Span, ToSpan};

<span class="kw">let </span>span = -<span class="number">86_400</span>.seconds().nanoseconds(<span class="number">1</span>);
<span class="kw">let </span>(sign, duration) = (span.signum(), Duration::try_from(span.abs())<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>((sign, duration), (-<span class="number">1</span>, Duration::new(<span class="number">86_400</span>, <span class="number">1</span>)));
</code></pre></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3373">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3376-3385">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(sp: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CSpan%3E-for-SignedDuration" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#3507-3518">Source</a><a href="#impl-TryFrom%3CSpan%3E-for-SignedDuration" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h3><div class="docblock"><p>Converts a <code>Span</code> to a <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a>.</p>
</div></section></summary><div class="docblock"><h4 id="errors-18"><a class="doc-anchor" href="#errors-18">§</a>Errors</h4>
<p>This can fail for only when the span has any non-zero units greater than
hours. This is an error because it’s impossible to determine the length of,
e.g., a month without a reference date.</p>
<p>This can never result in overflow because a <code>SignedDuration</code> can represent
a bigger span of time than <code>Span</code> when limited to units of hours or lower.</p>
<p>If you need to convert a <code>Span</code> to a <code>SignedDuration</code> that has non-zero
units bigger than hours, then please use <a href="struct.Span.html#method.to_duration" title="method jiff::Span::to_duration"><code>Span::to_duration</code></a> with a
corresponding relative date.</p>
<h4 id="example-maximal-span-1"><a class="doc-anchor" href="#example-maximal-span-1">§</a>Example: maximal span</h4>
<p>This example shows the maximum possible span using units of hours or
smaller, and the corresponding <code>SignedDuration</code> value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Span};

<span class="kw">let </span>sp = Span::new()
    .hours(<span class="number">175_307_616</span>)
    .minutes(<span class="number">10_518_456_960i64</span>)
    .seconds(<span class="number">631_107_417_600i64</span>)
    .milliseconds(<span class="number">631_107_417_600_000i64</span>)
    .microseconds(<span class="number">631_107_417_600_000_000i64</span>)
    .nanoseconds(<span class="number">9_223_372_036_854_775_807i64</span>);
<span class="kw">let </span>duration = SignedDuration::try_from(sp)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(duration, SignedDuration::new(<span class="number">3_164_760_460_036</span>, <span class="number">854_775_807</span>));
</code></pre></div>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3508">Source</a><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/span.rs.html#3511-3517">Source</a><a href="#method.try_from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(sp: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Copy-for-Span" class="impl"><a class="src rightside" href="../src/jiff/span.rs.html#709">Source</a><a href="#impl-Copy-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Span" class="impl"><a href="#impl-Freeze-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section><section id="impl-RefUnwindSafe-for-Span" class="impl"><a href="#impl-RefUnwindSafe-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section><section id="impl-Send-for-Span" class="impl"><a href="#impl-Send-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section><section id="impl-Sync-for-Span" class="impl"><a href="#impl-Sync-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section><section id="impl-Unpin-for-Span" class="impl"><a href="#impl-Unpin-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section><section id="impl-UnwindSafe-for-Span" class="impl"><a href="#impl-UnwindSafe-for-Span" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-18" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-18" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2806">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2808">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-5" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-4" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>