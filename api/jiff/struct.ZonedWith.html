<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A builder for setting the fields on a `Zoned`."><title>ZonedWith in jiff - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Zoned<wbr>With</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.build" title="build">build</a></li><li><a href="#method.date" title="date">date</a></li><li><a href="#method.day" title="day">day</a></li><li><a href="#method.day_of_year" title="day_of_year">day_of_year</a></li><li><a href="#method.day_of_year_no_leap" title="day_of_year_no_leap">day_of_year_no_leap</a></li><li><a href="#method.disambiguation" title="disambiguation">disambiguation</a></li><li><a href="#method.era_year" title="era_year">era_year</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.month" title="month">month</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.offset_conflict" title="offset_conflict">offset_conflict</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.time" title="time">time</a></li><li><a href="#method.year" title="year">year</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-ZonedWith" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-ZonedWith" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-ZonedWith" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-ZonedWith" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ZonedWith" title="Send">Send</a></li><li><a href="#impl-Sync-for-ZonedWith" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ZonedWith" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ZonedWith" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate jiff</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">jiff</a></div><h1>Struct <span class="struct">ZonedWith</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/jiff/zoned.rs.html#4398-4404">Source</a> </span></div><pre class="rust item-decl"><code>pub struct ZonedWith { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A builder for setting the fields on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>This builder is constructed via <a href="struct.Zoned.html#method.with" title="method jiff::Zoned::with"><code>Zoned::with</code></a>.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>The builder ensures one can chain together the individual components of a
zoned datetime without it failing at an intermediate step. For example,
if you had a date of <code>2024-10-31T00:00:00[America/New_York]</code> and wanted
to change both the day and the month, and each setting was validated
independent of the other, you would need to be careful to set the day first
and then the month. In some cases, you would need to set the month first
and then the day!</p>
<p>But with the builder, you can set values in any order:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().month(<span class="number">11</span>).day(<span class="number">30</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">4</span>, <span class="number">30</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().day(<span class="number">31</span>).month(<span class="number">7</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ZonedWith" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#4406-5448">Source</a><a href="#impl-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4469-4475">Source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>Zoned</code> from the fields set on this configuration.</p>
<p>An error occurs when the fields combine to an invalid zoned datetime.</p>
<p>For any fields not set on this configuration, the values are taken from
the <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> that originally created this configuration. When no
values are set, this routine is guaranteed to succeed and will always
return the original zoned datetime without modification.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This creates a zoned datetime corresponding to the last day in the year
at noon:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">365</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// It also works with leap years for the same input:
</span><span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">365</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<h5 id="example-error-for-invalid-zoned-datetime"><a class="doc-anchor" href="#example-error-for-invalid-zoned-datetime">§</a>Example: error for invalid zoned datetime</h5>
<p>If the fields combine to form an invalid datetime, then an error is
returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">30</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().day(<span class="number">31</span>).build().is_err());

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().year(<span class="number">2023</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.date" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4499-4501">Source</a><h4 class="code-header">pub fn <a href="#method.date" class="fn">date</a>(self, date: <a class="struct" href="civil/struct.Date.html" title="struct jiff::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the year, month and day fields via the <code>Date</code> given.</p>
<p>This overrides any previous year, month or day settings.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>This shows how to create a new zoned datetime with a different date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().date(date(<span class="number">2017</span>, <span class="number">10</span>, <span class="number">31</span>)).build()<span class="question-mark">?</span>;
<span class="comment">// The date changes but the time remains the same.
</span><span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2017</span>, <span class="number">10</span>, <span class="number">31</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.time" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4529-4531">Source</a><h4 class="code-header">pub fn <a href="#method.time" class="fn">time</a>(self, time: <a class="struct" href="civil/struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the hour, minute, second, millisecond, microsecond and nanosecond
fields via the <code>Time</code> given.</p>
<p>This overrides any previous hour, minute, second, millisecond,
microsecond, nanosecond or subsecond nanosecond settings.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This shows how to create a new zoned datetime with a different time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{date, time};

<span class="kw">let </span>zdt1 = date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().time(time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">123_456_789</span>)).build()<span class="question-mark">?</span>;
<span class="comment">// The time changes but the date remains the same.
</span><span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">123_456_789</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.year" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4574-4576">Source</a><h4 class="code-header">pub fn <a href="#method.year" class="fn">year</a>(self, year: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the year field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.year" title="method jiff::Zoned::year"><code>Zoned::year</code></a>.</p>
<p>This overrides any previous year settings.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given year is outside the range <code>-9999..=9999</code>. This can also return an
error if the resulting date is otherwise invalid.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This shows how to create a new zoned datetime with a different year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>).at(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.year(), <span class="number">2005</span>);
<span class="kw">let </span>zdt2 = zdt1.with().year(<span class="number">2007</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.year(), <span class="number">2007</span>);
</code></pre></div>
<h5 id="example-only-changing-the-year-can-fail"><a class="doc-anchor" href="#example-only-changing-the-year-can-fail">§</a>Example: only changing the year can fail</h5>
<p>For example, while <code>2024-02-29T01:30:00[America/New_York]</code> is valid,
<code>2023-02-29T01:30:00[America/New_York]</code> is not:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().year(<span class="number">2023</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.era_year" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4668-4673">Source</a><h4 class="code-header">pub fn <a href="#method.era_year" class="fn">era_year</a>(self, year: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>, era: <a class="enum" href="civil/enum.Era.html" title="enum jiff::civil::Era">Era</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the year of a zoned datetime via its era and its non-negative
numeric component.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.era_year" title="method jiff::Zoned::era_year"><code>Zoned::era_year</code></a>.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
year is outside the range for the era specified. For <a href="civil/enum.Era.html#variant.BCE" title="variant jiff::civil::Era::BCE"><code>Era::BCE</code></a>, the
range is <code>1..=10000</code>. For <a href="civil/enum.Era.html#variant.CE" title="variant jiff::civil::Era::CE"><code>Era::CE</code></a>, the range is <code>1..=9999</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This shows that <code>CE</code> years are equivalent to the years used by this
crate:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>zdt1 = date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>).at(<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.year(), <span class="number">2005</span>);
<span class="kw">let </span>zdt2 = zdt1.with().era_year(<span class="number">2007</span>, Era::CE).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.year(), <span class="number">2007</span>);

<span class="comment">// CE years are always positive and can be at most 9999:
</span><span class="macro">assert!</span>(zdt1.with().era_year(-<span class="number">5</span>, Era::CE).build().is_err());
<span class="macro">assert!</span>(zdt1.with().era_year(<span class="number">10_000</span>, Era::CE).build().is_err());
</code></pre></div>
<p>But <code>BCE</code> years always correspond to years less than or equal to <code>0</code>
in this crate:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>zdt1 = date(-<span class="number">27</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">8</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.year(), -<span class="number">27</span>);
<span class="macro">assert_eq!</span>(zdt1.era_year(), (<span class="number">28</span>, Era::BCE));

<span class="kw">let </span>zdt2 = zdt1.with().era_year(<span class="number">509</span>, Era::BCE).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.year(), -<span class="number">508</span>);
<span class="macro">assert_eq!</span>(zdt2.era_year(), (<span class="number">509</span>, Era::BCE));

<span class="kw">let </span>zdt2 = zdt1.with().era_year(<span class="number">10_000</span>, Era::BCE).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.year(), -<span class="number">9_999</span>);
<span class="macro">assert_eq!</span>(zdt2.era_year(), (<span class="number">10_000</span>, Era::BCE));

<span class="comment">// BCE years are always positive and can be at most 10000:
</span><span class="macro">assert!</span>(zdt1.with().era_year(-<span class="number">5</span>, Era::BCE).build().is_err());
<span class="macro">assert!</span>(zdt1.with().era_year(<span class="number">10_001</span>, Era::BCE).build().is_err());
</code></pre></div>
<h5 id="example-overrides-zonedwithyear"><a class="doc-anchor" href="#example-overrides-zonedwithyear">§</a>Example: overrides <code>ZonedWith::year</code></h5>
<p>Setting this option will override any previous <code>ZonedWith::year</code>
option:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">2</span>).at(<span class="number">10</span>, <span class="number">27</span>, <span class="number">10</span>, <span class="number">123</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().year(<span class="number">2000</span>).era_year(<span class="number">1900</span>, Era::CE).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">1900</span>, <span class="number">7</span>, <span class="number">2</span>).at(<span class="number">10</span>, <span class="number">27</span>, <span class="number">10</span>, <span class="number">123</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>Similarly, <code>ZonedWith::year</code> will override any previous call to
<code>ZonedWith::era_year</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Era, date};

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">2</span>).at(<span class="number">19</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().era_year(<span class="number">1900</span>, Era::CE).year(<span class="number">2000</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2,
    date(<span class="number">2000</span>, <span class="number">7</span>, <span class="number">2</span>).at(<span class="number">19</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4719-4721">Source</a><h4 class="code-header">pub fn <a href="#method.month" class="fn">month</a>(self, month: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the month field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.month" title="method jiff::Zoned::month"><code>Zoned::month</code></a>.</p>
<p>This overrides any previous month settings.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given month is outside the range <code>1..=12</code>. This can also return an
error if the resulting date is otherwise invalid.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This shows how to create a new zoned datetime with a different month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2005</span>, <span class="number">11</span>, <span class="number">5</span>)
    .at(<span class="number">18</span>, <span class="number">3</span>, <span class="number">59</span>, <span class="number">123_456_789</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.month(), <span class="number">11</span>);

<span class="kw">let </span>zdt2 = zdt1.with().month(<span class="number">6</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.month(), <span class="number">6</span>);
</code></pre></div>
<h5 id="example-only-changing-the-month-can-fail"><a class="doc-anchor" href="#example-only-changing-the-month-can-fail">§</a>Example: only changing the month can fail</h5>
<p>For example, while <code>2024-10-31T00:00:00[America/New_York]</code> is valid,
<code>2024-11-31T00:00:00[America/New_York]</code> is not:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">10</span>, <span class="number">31</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().month(<span class="number">11</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4772-4774">Source</a><h4 class="code-header">pub fn <a href="#method.day" class="fn">day</a>(self, day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the day field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.day" title="method jiff::Zoned::day"><code>Zoned::day</code></a>.</p>
<p>This overrides any previous day settings.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given given day is outside of allowable days for the corresponding year
and month fields.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This shows some examples of setting the day, including a leap day:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">5</span>).at(<span class="number">21</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">999</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.day(), <span class="number">5</span>);
<span class="kw">let </span>zdt2 = zdt1.with().day(<span class="number">10</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.day(), <span class="number">10</span>);
<span class="kw">let </span>zdt3 = zdt1.with().day(<span class="number">29</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt3.day(), <span class="number">29</span>);
</code></pre></div>
<h5 id="example-changing-only-the-day-can-fail"><a class="doc-anchor" href="#example-changing-only-the-day-can-fail">§</a>Example: changing only the day can fail</h5>
<p>This shows some examples that will fail:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt1 = date(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">5</span>)
    .at(<span class="number">22</span>, <span class="number">58</span>, <span class="number">58</span>, <span class="number">9_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// 2023 is not a leap year
</span><span class="macro">assert!</span>(zdt1.with().day(<span class="number">29</span>).build().is_err());

<span class="comment">// September has 30 days, not 31.
</span><span class="kw">let </span>zdt1 = date(<span class="number">2023</span>, <span class="number">9</span>, <span class="number">5</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt1.with().day(<span class="number">31</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4847-4852">Source</a><h4 class="code-header">pub fn <a href="#method.day_of_year" class="fn">day_of_year</a>(self, day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the day field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> via the ordinal number of a day
within a year.</p>
<p>When used, any settings for month are ignored since the month is
determined by the day of the year.</p>
<p>The valid values for <code>day</code> are <code>1..=366</code>. Note though that <code>366</code> is
only valid for leap years.</p>
<p>This overrides any previous day settings.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given day is outside the allowed range of <code>1..=366</code>, or when a value of
<code>366</code> is given for a non-leap year.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This demonstrates that if a year is a leap year, then <code>60</code> corresponds
to February 29:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year(<span class="number">60</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>But for non-leap years, day 60 is March 1:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year(<span class="number">60</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">1</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>And using <code>366</code> for a non-leap year will result in an error, since
non-leap years only have 365 days:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().day_of_year(<span class="number">366</span>).build().is_err());
<span class="comment">// The maximal year is not a leap year, so it returns an error too.
</span><span class="kw">let </span>zdt = date(<span class="number">9999</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().day_of_year(<span class="number">366</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year_no_leap" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4955-4960">Source</a><h4 class="code-header">pub fn <a href="#method.day_of_year_no_leap" class="fn">day_of_year_no_leap</a>(self, day: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the day field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> via the ordinal number of a day
within a year, but ignoring leap years.</p>
<p>When used, any settings for month are ignored since the month is
determined by the day of the year.</p>
<p>The valid values for <code>day</code> are <code>1..=365</code>. The value <code>365</code> always
corresponds to the last day of the year, even for leap years. It is
impossible for this routine to return a zoned datetime corresponding to
February 29. (Unless there is a relevant time zone transition that
provokes disambiguation that shifts the datetime into February 29.)</p>
<p>This overrides any previous day settings.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given day is outside the allowed range of <code>1..=365</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<p>This demonstrates that <code>60</code> corresponds to March 1, regardless of
whether the year is a leap year or not:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">60</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">1</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">60</span>).build()<span class="question-mark">?</span>,
    date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">1</span>)
        .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
        .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>And using <code>365</code> for any year will always yield the last day of the
year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">365</span>).build()<span class="question-mark">?</span>,
    zdt.last_of_year()<span class="question-mark">?</span>,
);

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">365</span>).build()<span class="question-mark">?</span>,
    zdt.last_of_year()<span class="question-mark">?</span>,
);

<span class="comment">// Careful at the boundaries. The last day of the year isn't
// representable with all time zones. For example:
</span><span class="kw">let </span>zdt = date(<span class="number">9999</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().day_of_year_no_leap(<span class="number">365</span>).build().is_err());
<span class="comment">// But with other time zones, it works okay:
</span><span class="kw">let </span>zdt = date(<span class="number">9999</span>, <span class="number">1</span>, <span class="number">1</span>)
    .at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>)
    .to_zoned(jiff::tz::TimeZone::fixed(jiff::tz::Offset::MAX))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.with().day_of_year_no_leap(<span class="number">365</span>).build()<span class="question-mark">?</span>,
    zdt.last_of_year()<span class="question-mark">?</span>,
);
</code></pre></div>
<p>A value of <code>366</code> is out of bounds, even for leap years:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">5</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(zdt.with().day_of_year_no_leap(<span class="number">366</span>).build().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#4986-4988">Source</a><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(self, hour: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the hour field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.hour" title="method jiff::Zoned::hour"><code>Zoned::hour</code></a>.</p>
<p>This overrides any previous hour settings.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given hour is outside the range <code>0..=23</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.hour(), <span class="number">15</span>);
<span class="kw">let </span>zdt2 = zdt1.with().hour(<span class="number">3</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.hour(), <span class="number">3</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5014-5016">Source</a><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(self, minute: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the minute field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.minute" title="method jiff::Zoned::minute"><code>Zoned::minute</code></a>.</p>
<p>This overrides any previous minute settings.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given minute is outside the range <code>0..=59</code>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.minute(), <span class="number">21</span>);
<span class="kw">let </span>zdt2 = zdt1.with().minute(<span class="number">3</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.minute(), <span class="number">3</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5042-5044">Source</a><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(self, second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the second field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.second" title="method jiff::Zoned::second"><code>Zoned::second</code></a>.</p>
<p>This overrides any previous second settings.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given second is outside the range <code>0..=59</code>.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">59</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.second(), <span class="number">59</span>);
<span class="kw">let </span>zdt2 = zdt1.with().second(<span class="number">3</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.second(), <span class="number">3</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5078-5083">Source</a><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(self, millisecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the millisecond field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.millisecond" title="method jiff::Zoned::millisecond"><code>Zoned::millisecond</code></a>.</p>
<p>This overrides any previous millisecond settings.</p>
<p>Note that this only sets the millisecond component. It does
not change the microsecond or nanosecond components. To set
the fractional second component to nanosecond precision, use
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a>.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given millisecond is outside the range <code>0..=999</code>, or if both this and
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a> are set.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<p>This shows the relationship between <a href="struct.Zoned.html#method.millisecond" title="method jiff::Zoned::millisecond"><code>Zoned::millisecond</code></a> and
<a href="struct.Zoned.html#method.subsec_nanosecond" title="method jiff::Zoned::subsec_nanosecond"><code>Zoned::subsec_nanosecond</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().millisecond(<span class="number">123</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.subsec_nanosecond(), <span class="number">123_000_000</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5117-5122">Source</a><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(self, microsecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the microsecond field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.microsecond" title="method jiff::Zoned::microsecond"><code>Zoned::microsecond</code></a>.</p>
<p>This overrides any previous microsecond settings.</p>
<p>Note that this only sets the microsecond component. It does
not change the millisecond or nanosecond components. To set
the fractional second component to nanosecond precision, use
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a>.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given microsecond is outside the range <code>0..=999</code>, or if both this and
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a> are set.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<p>This shows the relationship between <a href="struct.Zoned.html#method.microsecond" title="method jiff::Zoned::microsecond"><code>Zoned::microsecond</code></a> and
<a href="struct.Zoned.html#method.subsec_nanosecond" title="method jiff::Zoned::subsec_nanosecond"><code>Zoned::subsec_nanosecond</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().microsecond(<span class="number">123</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.subsec_nanosecond(), <span class="number">123_000</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5156-5161">Source</a><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(self, nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the nanosecond field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>One can access this value via <a href="struct.Zoned.html#method.nanosecond" title="method jiff::Zoned::nanosecond"><code>Zoned::nanosecond</code></a>.</p>
<p>This overrides any previous nanosecond settings.</p>
<p>Note that this only sets the nanosecond component. It does
not change the millisecond or microsecond components. To set
the fractional second component to nanosecond precision, use
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a>.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given nanosecond is outside the range <code>0..=999</code>, or if both this and
<a href="struct.ZonedWith.html#method.subsec_nanosecond" title="method jiff::ZonedWith::subsec_nanosecond"><code>ZonedWith::subsec_nanosecond</code></a> are set.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<p>This shows the relationship between <a href="struct.Zoned.html#method.nanosecond" title="method jiff::Zoned::nanosecond"><code>Zoned::nanosecond</code></a> and
<a href="struct.Zoned.html#method.subsec_nanosecond" title="method jiff::Zoned::subsec_nanosecond"><code>Zoned::subsec_nanosecond</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().nanosecond(<span class="number">123</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.subsec_nanosecond(), <span class="number">123</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5200-5207">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self, subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the subsecond nanosecond field on a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>If you want to access this value on <code>Zoned</code>, then use
<a href="struct.Zoned.html#method.subsec_nanosecond" title="method jiff::Zoned::subsec_nanosecond"><code>Zoned::subsec_nanosecond</code></a>.</p>
<p>This overrides any previous subsecond nanosecond settings.</p>
<p>Note that this sets the entire fractional second component to
nanosecond precision, and overrides any individual millisecond,
microsecond or nanosecond settings. To set individual components,
use <a href="struct.ZonedWith.html#method.millisecond" title="method jiff::ZonedWith::millisecond"><code>ZonedWith::millisecond</code></a>, <a href="struct.ZonedWith.html#method.microsecond" title="method jiff::ZonedWith::microsecond"><code>ZonedWith::microsecond</code></a> or
<a href="struct.ZonedWith.html#method.nanosecond" title="method jiff::ZonedWith::nanosecond"><code>ZonedWith::nanosecond</code></a>.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This returns an error when <a href="struct.ZonedWith.html#method.build" title="method jiff::ZonedWith::build"><code>ZonedWith::build</code></a> is called if the
given subsecond nanosecond is outside the range <code>0..=999,999,999</code>,
or if both this and one of <a href="struct.ZonedWith.html#method.millisecond" title="method jiff::ZonedWith::millisecond"><code>ZonedWith::millisecond</code></a>,
<a href="struct.ZonedWith.html#method.microsecond" title="method jiff::ZonedWith::microsecond"><code>ZonedWith::microsecond</code></a> or <a href="struct.ZonedWith.html#method.nanosecond" title="method jiff::ZonedWith::nanosecond"><code>ZonedWith::nanosecond</code></a> are set.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>Zoned</code> value
with subsecond nanoseconds and its individual subsecond fields:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>zdt1 = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">6</span>, <span class="number">1</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().subsec_nanosecond(<span class="number">123_456_789</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(zdt2.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(zdt2.nanosecond(), <span class="number">789</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5261-5263">Source</a><h4 class="code-header">pub fn <a href="#method.offset" class="fn">offset</a>(self, offset: <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the offset to use in the new zoned datetime.</p>
<p>This can be used in some cases to explicitly disambiguate a datetime
that could correspond to multiple instants in time.</p>
<p>How the offset is used to construct a new zoned datetime
depends on the offset conflict resolution strategy
set via <a href="struct.ZonedWith.html#method.offset_conflict" title="method jiff::ZonedWith::offset_conflict"><code>ZonedWith::offset_conflict</code></a>. The default is
<a href="tz/enum.OffsetConflict.html#variant.PreferOffset" title="variant jiff::tz::OffsetConflict::PreferOffset"><code>OffsetConflict::PreferOffset</code></a>, which will always try to use the
offset to resolve a datetime to an instant, unless the offset is
incorrect for this zoned datetime’s time zone. In which case, only the
time zone is used to select the correct offset (which may involve using
the disambiguation strategy set via <a href="struct.ZonedWith.html#method.disambiguation" title="method jiff::ZonedWith::disambiguation"><code>ZonedWith::disambiguation</code></a>).</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This example shows parsing the first time the 1 o’clock hour appeared
on a clock in New York on 2024-11-03, and then changing only the
offset to flip it to the second time 1 o’clock appeared on the clock:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{tz, Zoned};

<span class="kw">let </span>zdt1: Zoned = <span class="string">"2024-11-03 01:30-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>zdt2 = zdt1.with().offset(tz::offset(-<span class="number">5</span>)).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="comment">// Everything stays the same, except for the offset.
    </span><span class="string">"2024-11-03T01:30:00-05:00[America/New_York]"</span>,
);

<span class="comment">// If we use an invalid offset for the America/New_York time zone,
// then it will be ignored and the disambiguation strategy set will
// be used.
</span><span class="kw">let </span>zdt3 = zdt1.with().offset(tz::offset(-<span class="number">12</span>)).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt3.to_string(),
    <span class="comment">// The default disambiguation is Compatible.
    </span><span class="string">"2024-11-03T01:30:00-04:00[America/New_York]"</span>,
);
<span class="comment">// But we could change the disambiguation strategy to reject such
// cases!
</span><span class="kw">let </span>result = zdt1
    .with()
    .offset(tz::offset(-<span class="number">12</span>))
    .disambiguation(tz::Disambiguation::Reject)
    .build();
<span class="macro">assert!</span>(result.is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_conflict" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5308-5310">Source</a><h4 class="code-header">pub fn <a href="#method.offset_conflict" class="fn">offset_conflict</a>(self, strategy: <a class="enum" href="tz/enum.OffsetConflict.html" title="enum jiff::tz::OffsetConflict">OffsetConflict</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the conflict resolution strategy for when an offset is inconsistent
with the time zone.</p>
<p>See the documentation on <a href="tz/enum.OffsetConflict.html" title="enum jiff::tz::OffsetConflict"><code>OffsetConflict</code></a> for more details about the
different strategies one can choose.</p>
<p>Unlike parsing (where the default is <code>OffsetConflict::Reject</code>), the
default for <code>ZonedWith</code> is <a href="tz/enum.OffsetConflict.html#variant.PreferOffset" title="variant jiff::tz::OffsetConflict::PreferOffset"><code>OffsetConflict::PreferOffset</code></a>, which
avoids daylight saving time disambiguation causing unexpected 1-hour
shifts after small changes to clock time.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Zoned;

<span class="comment">// Set to the "second" time 1:30 is on the clocks in New York on
// 2024-11-03. The offset in the datetime string makes this
// unambiguous.
</span><span class="kw">let </span>zdt1 = <span class="string">"2024-11-03T01:30-05[America/New_York]"</span>.parse::&lt;Zoned&gt;()<span class="question-mark">?</span>;
<span class="comment">// Now we change the minute field:
</span><span class="kw">let </span>zdt2 = zdt1.with().minute(<span class="number">34</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="comment">// Without taking the offset of the `Zoned` value into account,
    // this would have defaulted to using the "compatible"
    // disambiguation strategy, which would have selected the earlier
    // offset of -04 instead of sticking with the later offset of -05.
    </span><span class="string">"2024-11-03T01:34:00-05:00[America/New_York]"</span>,
);

<span class="comment">// But note that if we change the clock time such that the previous
// offset is no longer valid (by moving back before DST ended), then
// the default strategy will automatically adapt and change the offset.
</span><span class="kw">let </span>zdt2 = zdt1.with().hour(<span class="number">0</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt2.to_string(),
    <span class="string">"2024-11-03T00:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.disambiguation" class="method"><a class="src rightside" href="../src/jiff/zoned.rs.html#5445-5447">Source</a><h4 class="code-header">pub fn <a href="#method.disambiguation" class="fn">disambiguation</a>(self, strategy: <a class="enum" href="tz/enum.Disambiguation.html" title="enum jiff::tz::Disambiguation">Disambiguation</a>) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class="docblock"><p>Set the disambiguation strategy for when a zoned datetime falls into a
time zone transition “fold” or “gap.”</p>
<p>The most common manifestation of such time zone transitions is daylight
saving time. In most cases, the transition into daylight saving time
moves the civil time (“the time you see on the clock”) ahead one hour.
This is called a “gap” because an hour on the clock is skipped. While
the transition out of daylight saving time moves the civil time back
one hour. This is called a “fold” because an hour on the clock is
repeated.</p>
<p>In the case of a gap, an ambiguous datetime manifests as a time that
never appears on a clock. (For example, <code>02:30</code> on <code>2024-03-10</code> in New
York.) In the case of a fold, an ambiguous datetime manifests as a
time that repeats itself. (For example, <code>01:30</code> on <code>2024-11-03</code> in New
York.) So when a fold occurs, you don’t know whether it’s the “first”
occurrence of that time or the “second.”</p>
<p>Time zone transitions are not just limited to daylight saving time,
although those are the most common. In other cases, a transition occurs
because of a change in the offset of the time zone itself. (See the
examples below.)</p>
<h5 id="example-time-zone-offset-change"><a class="doc-anchor" href="#example-time-zone-offset-change">§</a>Example: time zone offset change</h5>
<p>In this example, we explore a time zone offset change in Hawaii that
occurred on <code>1947-06-08</code>. Namely, Hawaii went from a <code>-10:30</code> offset
to a <code>-10:00</code> offset at <code>02:00</code>. This results in a 30 minute gap in
civil time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz, ToSpan, Zoned};

<span class="comment">// This datetime is unambiguous...
</span><span class="kw">let </span>zdt1 = <span class="string">"1943-06-02T02:05[Pacific/Honolulu]"</span>.parse::&lt;Zoned&gt;()<span class="question-mark">?</span>;
<span class="comment">// but... 02:05 didn't exist on clocks on 1947-06-08.
</span><span class="kw">let </span>zdt2 = zdt1
    .with()
    .disambiguation(tz::Disambiguation::Later)
    .year(<span class="number">1947</span>)
    .day(<span class="number">8</span>)
    .build()<span class="question-mark">?</span>;
<span class="comment">// Our parser is configured to select the later time, so we jump to
// 02:35. But if we used `Disambiguation::Earlier`, then we'd get
// 01:35.
</span><span class="macro">assert_eq!</span>(zdt2.datetime(), date(<span class="number">1947</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">2</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt2.offset(), tz::offset(-<span class="number">10</span>));

<span class="comment">// If we subtract 10 minutes from 02:35, notice that we (correctly)
// jump to 01:55 *and* our offset is corrected to -10:30.
</span><span class="kw">let </span>zdt3 = zdt2.checked_sub(<span class="number">10</span>.minutes())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt3.datetime(), date(<span class="number">1947</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">1</span>, <span class="number">55</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt3.offset(), tz::offset(-<span class="number">10</span>).saturating_sub(<span class="number">30</span>.minutes()));
</code></pre></div>
<h5 id="example-offset-conflict-resolution-and-disambiguation"><a class="doc-anchor" href="#example-offset-conflict-resolution-and-disambiguation">§</a>Example: offset conflict resolution and disambiguation</h5>
<p>This example shows how the disambiguation configuration can
interact with the default offset conflict resolution strategy of
<a href="tz/enum.OffsetConflict.html#variant.PreferOffset" title="variant jiff::tz::OffsetConflict::PreferOffset"><code>OffsetConflict::PreferOffset</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz, Zoned};

<span class="comment">// This datetime is unambiguous.
</span><span class="kw">let </span>zdt1 = <span class="string">"2024-03-11T02:05[America/New_York]"</span>.parse::&lt;Zoned&gt;()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.offset(), tz::offset(-<span class="number">4</span>));
<span class="comment">// But the same time on March 10 is ambiguous because there is a gap!
</span><span class="kw">let </span>zdt2 = zdt1
    .with()
    .disambiguation(tz::Disambiguation::Earlier)
    .day(<span class="number">10</span>)
    .build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt2.offset(), tz::offset(-<span class="number">5</span>));
</code></pre></div>
<p>Namely, while we started with an offset of <code>-04</code>, it (along with all
other offsets) are considered invalid during civil time gaps due to
time zone transitions (such as the beginning of daylight saving time in
most locations).</p>
<p>The default disambiguation strategy is
<a href="tz/enum.Disambiguation.html#variant.Compatible" title="variant jiff::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>, which in the case of gaps, chooses the
time after the gap:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz, Zoned};

<span class="comment">// This datetime is unambiguous.
</span><span class="kw">let </span>zdt1 = <span class="string">"2024-03-11T02:05[America/New_York]"</span>.parse::&lt;Zoned&gt;()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.offset(), tz::offset(-<span class="number">4</span>));
<span class="comment">// But the same time on March 10 is ambiguous because there is a gap!
</span><span class="kw">let </span>zdt2 = zdt1
    .with()
    .day(<span class="number">10</span>)
    .build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt2.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt2.offset(), tz::offset(-<span class="number">4</span>));
</code></pre></div>
<p>Alternatively, one can choose to always respect the offset, and thus
civil time for the provided time zone will be adjusted to match the
instant prescribed by the offset. In this case, no disambiguation is
performed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz, Zoned};

<span class="comment">// This datetime is unambiguous. But `2024-03-10T02:05` is!
</span><span class="kw">let </span>zdt1 = <span class="string">"2024-03-11T02:05[America/New_York]"</span>.parse::&lt;Zoned&gt;()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt1.offset(), tz::offset(-<span class="number">4</span>));
<span class="comment">// But the same time on March 10 is ambiguous because there is a gap!
</span><span class="kw">let </span>zdt2 = zdt1
    .with()
    .offset_conflict(tz::OffsetConflict::AlwaysOffset)
    .day(<span class="number">10</span>)
    .build()<span class="question-mark">?</span>;
<span class="comment">// Why do we get this result? Because `2024-03-10T02:05-04` is
// `2024-03-10T06:05Z`. And in `America/New_York`, the civil time
// for that timestamp is `2024-03-10T01:05-05`.
</span><span class="macro">assert_eq!</span>(zdt2.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt2.offset(), tz::offset(-<span class="number">5</span>));
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ZonedWith" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#4397">Source</a><a href="#impl-Clone-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#4397">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ZonedWith" class="impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#4397">Source</a><a href="#impl-Debug-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/jiff/zoned.rs.html#4397">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ZonedWith" class="impl"><a href="#impl-Freeze-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section><section id="impl-RefUnwindSafe-for-ZonedWith" class="impl"><a href="#impl-RefUnwindSafe-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section><section id="impl-Send-for-ZonedWith" class="impl"><a href="#impl-Send-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section><section id="impl-Sync-for-ZonedWith" class="impl"><a href="#impl-Sync-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section><section id="impl-Unpin-for-ZonedWith" class="impl"><a href="#impl-Unpin-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section><section id="impl-UnwindSafe-for-ZonedWith" class="impl"><a href="#impl-UnwindSafe-for-ZonedWith" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ZonedWith.html" title="struct jiff::ZonedWith">ZonedWith</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>