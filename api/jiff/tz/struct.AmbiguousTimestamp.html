<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A possibly ambiguous `Timestamp`, created by `TimeZone::to_ambiguous_timestamp`."><title>AmbiguousTimestamp in jiff::tz - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Ambiguous<wbr>Timestamp</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.compatible" title="compatible">compatible</a></li><li><a href="#method.datetime" title="datetime">datetime</a></li><li><a href="#method.disambiguate" title="disambiguate">disambiguate</a></li><li><a href="#method.earlier" title="earlier">earlier</a></li><li><a href="#method.is_ambiguous" title="is_ambiguous">is_ambiguous</a></li><li><a href="#method.later" title="later">later</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.unambiguous" title="unambiguous">unambiguous</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-AmbiguousTimestamp" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-AmbiguousTimestamp" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-AmbiguousTimestamp" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-AmbiguousTimestamp" title="Eq">Eq</a></li><li><a href="#impl-PartialEq-for-AmbiguousTimestamp" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-AmbiguousTimestamp" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-AmbiguousTimestamp" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-AmbiguousTimestamp" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-AmbiguousTimestamp" title="Send">Send</a></li><li><a href="#impl-Sync-for-AmbiguousTimestamp" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-AmbiguousTimestamp" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-AmbiguousTimestamp" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>tz</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">jiff</a>::<wbr><a href="index.html">tz</a></div><h1>Struct <span class="struct">AmbiguousTimestamp</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/jiff/tz/ambiguous.rs.html#298-301">Source</a> </span></div><pre class="rust item-decl"><code>pub struct AmbiguousTimestamp { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A possibly ambiguous <a href="../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>, created by
<a href="struct.TimeZone.html#method.to_ambiguous_timestamp" title="method jiff::tz::TimeZone::to_ambiguous_timestamp"><code>TimeZone::to_ambiguous_timestamp</code></a>.</p>
<p>While this is called an ambiguous <em>timestamp</em>, the thing that is
actually ambiguous is the offset. That is, an ambiguous timestamp is
actually a pair of a <a href="../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a> and an
<a href="enum.AmbiguousOffset.html" title="enum jiff::tz::AmbiguousOffset"><code>AmbiguousOffset</code></a>.</p>
<p>When the offset is ambiguous, it either represents a gap (civil time is
skipped) or a fold (civil time is repeated). In both cases, there are, by
construction, two different offsets to choose from: the offset from before
the transition and the offset from after the transition.</p>
<p>The purpose of this type is to represent that ambiguity (when it occurs)
and enable callers to make a choice about how to resolve that ambiguity.
In some cases, you might want to reject ambiguity altogether, which is
supported by the <a href="struct.AmbiguousTimestamp.html#method.unambiguous" title="method jiff::tz::AmbiguousTimestamp::unambiguous"><code>AmbiguousTimestamp::unambiguous</code></a> routine.</p>
<p>This type provides four different out-of-the-box disambiguation strategies:</p>
<ul>
<li><a href="struct.AmbiguousTimestamp.html#method.compatible" title="method jiff::tz::AmbiguousTimestamp::compatible"><code>AmbiguousTimestamp::compatible</code></a> implements the
<a href="enum.Disambiguation.html#variant.Compatible" title="variant jiff::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a> strategy. In the case of a gap, the offset
after the gap is selected. In the case of a fold, the offset before the
fold occurs is selected.</li>
<li><a href="struct.AmbiguousTimestamp.html#method.earlier" title="method jiff::tz::AmbiguousTimestamp::earlier"><code>AmbiguousTimestamp::earlier</code></a> implements the
<a href="enum.Disambiguation.html#variant.Earlier" title="variant jiff::tz::Disambiguation::Earlier"><code>Disambiguation::Earlier</code></a> strategy. This always selects the “earlier”
offset.</li>
<li><a href="struct.AmbiguousTimestamp.html#method.later" title="method jiff::tz::AmbiguousTimestamp::later"><code>AmbiguousTimestamp::later</code></a> implements the
<a href="enum.Disambiguation.html#variant.Later" title="variant jiff::tz::Disambiguation::Later"><code>Disambiguation::Later</code></a> strategy. This always selects the “later”
offset.</li>
<li><a href="struct.AmbiguousTimestamp.html#method.unambiguous" title="method jiff::tz::AmbiguousTimestamp::unambiguous"><code>AmbiguousTimestamp::unambiguous</code></a> implements the
<a href="enum.Disambiguation.html#variant.Reject" title="variant jiff::tz::Disambiguation::Reject"><code>Disambiguation::Reject</code></a> strategy. It acts as an assertion that the
offset is unambiguous. If it is ambiguous, then an appropriate error is
returned.</li>
</ul>
<p>The <a href="struct.AmbiguousTimestamp.html#method.disambiguate" title="method jiff::tz::AmbiguousTimestamp::disambiguate"><code>AmbiguousTimestamp::disambiguate</code></a> method can be used with the
<a href="enum.Disambiguation.html" title="enum jiff::tz::Disambiguation"><code>Disambiguation</code></a> enum when the disambiguation strategy isn’t known until
runtime.</p>
<p>Note also that these aren’t the only disambiguation strategies. The
<a href="enum.AmbiguousOffset.html" title="enum jiff::tz::AmbiguousOffset"><code>AmbiguousOffset</code></a> type, accessible via <a href="struct.AmbiguousTimestamp.html#method.offset" title="method jiff::tz::AmbiguousTimestamp::offset"><code>AmbiguousTimestamp::offset</code></a>,
exposes the full details of the ambiguity. So any strategy can be
implemented.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>This example shows how the “compatible” disambiguation strategy is
implemented. Recall that the “compatible” strategy chooses the offset
corresponding to the civil datetime after a gap, and the offset
corresponding to the civil datetime before a gap.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{<span class="self">self</span>, AmbiguousOffset}};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>offset = <span class="kw">match </span>tz.to_ambiguous_timestamp(dt).offset() {
    AmbiguousOffset::Unambiguous { offset } =&gt; offset,
    <span class="comment">// This is counter-intuitive, but in order to get the civil datetime
    // *after* the gap, we need to select the offset from *before* the
    // gap.
    </span>AmbiguousOffset::Gap { before, .. } =&gt; before,
    AmbiguousOffset::Fold { before, .. } =&gt; before,
};
<span class="macro">assert_eq!</span>(offset.to_timestamp(dt)<span class="question-mark">?</span>.to_string(), <span class="string">"2024-03-10T07:30:00Z"</span>);
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#303-748">Source</a><a href="#impl-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.datetime" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#328-330">Source</a><h4 class="code-header">pub fn <a href="#method.datetime" class="fn">datetime</a>(&amp;self) -&gt; <a class="struct" href="../civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Returns the civil datetime that was used to create this ambiguous
timestamp.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">10</span>).at(<span class="number">17</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(ts.datetime(), dt);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#387-389">Source</a><h4 class="code-header">pub fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="enum" href="enum.AmbiguousOffset.html" title="enum jiff::tz::AmbiguousOffset">AmbiguousOffset</a></h4></section></summary><div class="docblock"><p>Returns the possibly ambiguous offset that is the ultimate source of
ambiguity.</p>
<p>Most civil datetimes are not ambiguous, and thus, the offset will not
be ambiguous either. In this case, the offset returned will be the
<a href="enum.AmbiguousOffset.html#variant.Unambiguous" title="variant jiff::tz::AmbiguousOffset::Unambiguous"><code>AmbiguousOffset::Unambiguous</code></a> variant.</p>
<p>But, not all civil datetimes are unambiguous. There are exactly two
cases where a civil datetime can be ambiguous: when a civil datetime
does not exist (a gap) or when a civil datetime is repeated (a fold).
In both such cases, the <em>offset</em> is the thing that is ambiguous as
there are two possible choices for the offset in both cases: the offset
before the transition (whether it’s a gap or a fold) or the offset
after the transition.</p>
<p>This type captures the fact that computing an offset from a civil
datetime in a particular time zone is in one of three possible states:</p>
<ol>
<li>It is unambiguous.</li>
<li>It is ambiguous because there is a gap in time.</li>
<li>It is ambiguous because there is a fold in time.</li>
</ol>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{<span class="self">self</span>, AmbiguousOffset}};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(ts.offset(), AmbiguousOffset::Unambiguous {
    offset: tz::offset(-<span class="number">4</span>),
});

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(ts.offset(), AmbiguousOffset::Gap {
    before: tz::offset(-<span class="number">5</span>),
    after: tz::offset(-<span class="number">4</span>),
});

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(ts.offset(), AmbiguousOffset::Fold {
    before: tz::offset(-<span class="number">4</span>),
    after: tz::offset(-<span class="number">5</span>),
});
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ambiguous" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#422-424">Source</a><h4 class="code-header">pub fn <a href="#method.is_ambiguous" class="fn">is_ambiguous</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this possibly ambiguous timestamp is
actually ambiguous.</p>
<p>This occurs precisely in cases when the offset is <em>not</em>
<a href="enum.AmbiguousOffset.html#variant.Unambiguous" title="variant jiff::tz::AmbiguousOffset::Unambiguous"><code>AmbiguousOffset::Unambiguous</code></a>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{<span class="self">self</span>, AmbiguousOffset}};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert!</span>(!ts.is_ambiguous());

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert!</span>(ts.is_ambiguous());

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert!</span>(ts.is_ambiguous());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compatible" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#479-486">Source</a><h4 class="code-header">pub fn <a href="#method.compatible" class="fn">compatible</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Disambiguates this timestamp according to the
<a href="enum.Disambiguation.html#variant.Compatible" title="variant jiff::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a> strategy.</p>
<p>If this timestamp is unambiguous, then this is a no-op.</p>
<p>The “compatible” strategy selects the offset corresponding to the civil
time after a gap, and the offset corresponding to the civil time before
a fold. This is what is specified in <a href="https://datatracker.ietf.org/doc/html/rfc5545">RFC 5545</a>.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when the combination of the civil datetime
and offset would lead to a <code>Timestamp</code> outside of the
<a href="../struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="../struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> limits. This only occurs
when the civil datetime is “close” to its own <a href="../civil/struct.DateTime.html#associatedconstant.MIN" title="associated constant jiff::civil::DateTime::MIN"><code>DateTime::MIN</code></a>
and <a href="../civil/struct.DateTime.html#associatedconstant.MAX" title="associated constant jiff::civil::DateTime::MAX"><code>DateTime::MAX</code></a> limits.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.compatible()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-07-15T21:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.compatible()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-03-10T07:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.compatible()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-11-03T05:30:00Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.earlier" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#539-546">Source</a><h4 class="code-header">pub fn <a href="#method.earlier" class="fn">earlier</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Disambiguates this timestamp according to the
<a href="enum.Disambiguation.html#variant.Earlier" title="variant jiff::tz::Disambiguation::Earlier"><code>Disambiguation::Earlier</code></a> strategy.</p>
<p>If this timestamp is unambiguous, then this is a no-op.</p>
<p>The “earlier” strategy selects the offset corresponding to the civil
time before a gap, and the offset corresponding to the civil time
before a fold.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when the combination of the civil datetime
and offset would lead to a <code>Timestamp</code> outside of the
<a href="../struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="../struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> limits. This only occurs
when the civil datetime is “close” to its own <a href="../civil/struct.DateTime.html#associatedconstant.MIN" title="associated constant jiff::civil::DateTime::MIN"><code>DateTime::MIN</code></a>
and <a href="../civil/struct.DateTime.html#associatedconstant.MAX" title="associated constant jiff::civil::DateTime::MAX"><code>DateTime::MAX</code></a> limits.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.earlier()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-07-15T21:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.earlier()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-03-10T06:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.earlier()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-11-03T05:30:00Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.later" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#599-606">Source</a><h4 class="code-header">pub fn <a href="#method.later" class="fn">later</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Disambiguates this timestamp according to the
<a href="enum.Disambiguation.html#variant.Later" title="variant jiff::tz::Disambiguation::Later"><code>Disambiguation::Later</code></a> strategy.</p>
<p>If this timestamp is unambiguous, then this is a no-op.</p>
<p>The “later” strategy selects the offset corresponding to the civil
time after a gap, and the offset corresponding to the civil time
after a fold.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when the combination of the civil datetime
and offset would lead to a <code>Timestamp</code> outside of the
<a href="../struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="../struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> limits. This only occurs
when the civil datetime is “close” to its own <a href="../civil/struct.DateTime.html#associatedconstant.MIN" title="associated constant jiff::civil::DateTime::MIN"><code>DateTime::MIN</code></a>
and <a href="../civil/struct.DateTime.html#associatedconstant.MAX" title="associated constant jiff::civil::DateTime::MAX"><code>DateTime::MAX</code></a> limits.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.later()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-07-15T21:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.later()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-03-10T07:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.later()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-11-03T06:30:00Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unambiguous" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#654-673">Source</a><h4 class="code-header">pub fn <a href="#method.unambiguous" class="fn">unambiguous</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Disambiguates this timestamp according to the
<a href="enum.Disambiguation.html#variant.Reject" title="variant jiff::tz::Disambiguation::Reject"><code>Disambiguation::Reject</code></a> strategy.</p>
<p>If this timestamp is unambiguous, then this is a no-op.</p>
<p>The “reject” strategy always returns an error when the timestamp
is ambiguous.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when the combination of the civil datetime
and offset would lead to a <code>Timestamp</code> outside of the
<a href="../struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="../struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> limits. This only occurs
when the civil datetime is “close” to its own <a href="../civil/struct.DateTime.html#associatedconstant.MIN" title="associated constant jiff::civil::DateTime::MIN"><code>DateTime::MIN</code></a>
and <a href="../civil/struct.DateTime.html#associatedconstant.MAX" title="associated constant jiff::civil::DateTime::MAX"><code>DateTime::MAX</code></a> limits.</p>
<p>This also returns an error when the timestamp is ambiguous.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz};

<span class="kw">let </span>tz = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;

<span class="comment">// Not ambiguous.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">15</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert_eq!</span>(
    ts.later()<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-07-15T21:30:00Z"</span>,
);

<span class="comment">// Ambiguous because of a gap.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert!</span>(ts.unambiguous().is_err());

<span class="comment">// Ambiguous because of a fold.
</span><span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = tz.to_ambiguous_timestamp(dt);
<span class="macro">assert!</span>(ts.unambiguous().is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.disambiguate" class="method"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#722-732">Source</a><h4 class="code-header">pub fn <a href="#method.disambiguate" class="fn">disambiguate</a>(self, option: <a class="enum" href="enum.Disambiguation.html" title="enum jiff::tz::Disambiguation">Disambiguation</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Disambiguates this (possibly ambiguous) timestamp into a specific
timestamp.</p>
<p>This is the same as calling one of the disambiguation methods, but
the method chosen is indicated by the option given. This is useful
when the disambiguation option needs to be chosen at runtime.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error if this would have returned a timestamp
outside of its minimum and maximum values.</p>
<p>This can also return an error when using the <a href="enum.Disambiguation.html#variant.Reject" title="variant jiff::tz::Disambiguation::Reject"><code>Disambiguation::Reject</code></a>
strategy. Namely, when using the <code>Reject</code> strategy, any ambiguous
timestamp always results in an error.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This example shows the various disambiguation modes when given a
datetime that falls in a “fold” (i.e., a backwards DST transition).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::{<span class="self">self</span>, Disambiguation}};

<span class="kw">let </span>newyork = tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>dt = date(<span class="number">2024</span>, <span class="number">11</span>, <span class="number">3</span>).at(<span class="number">1</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>ambiguous = newyork.to_ambiguous_timestamp(dt);

<span class="comment">// In compatible mode, backward transitions select the earlier
// time. In the EDT-&gt;EST transition, that's the -04 (EDT) offset.
</span><span class="kw">let </span>ts = ambiguous.clone().disambiguate(Disambiguation::Compatible)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-11-03T05:30:00Z"</span>);

<span class="comment">// The earlier time in the EDT-&gt;EST transition is the -04 (EDT) offset.
</span><span class="kw">let </span>ts = ambiguous.clone().disambiguate(Disambiguation::Earlier)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-11-03T05:30:00Z"</span>);

<span class="comment">// The later time in the EDT-&gt;EST transition is the -05 (EST) offset.
</span><span class="kw">let </span>ts = ambiguous.clone().disambiguate(Disambiguation::Later)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-11-03T06:30:00Z"</span>);

<span class="comment">// Since our datetime is ambiguous, the 'reject' strategy errors.
</span><span class="macro">assert!</span>(ambiguous.disambiguate(Disambiguation::Reject).is_err());
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-Clone-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-Debug-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-PartialEq-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Copy-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-Copy-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-Eq-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-Eq-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-StructuralPartialEq-for-AmbiguousTimestamp" class="impl"><a class="src rightside" href="../../src/jiff/tz/ambiguous.rs.html#297">Source</a><a href="#impl-StructuralPartialEq-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-AmbiguousTimestamp" class="impl"><a href="#impl-Freeze-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-RefUnwindSafe-for-AmbiguousTimestamp" class="impl"><a href="#impl-RefUnwindSafe-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-Send-for-AmbiguousTimestamp" class="impl"><a href="#impl-Send-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-Sync-for-AmbiguousTimestamp" class="impl"><a href="#impl-Sync-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-Unpin-for-AmbiguousTimestamp" class="impl"><a href="#impl-Unpin-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section><section id="impl-UnwindSafe-for-AmbiguousTimestamp" class="impl"><a href="#impl-UnwindSafe-for-AmbiguousTimestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AmbiguousTimestamp.html" title="struct jiff::tz::AmbiguousTimestamp">AmbiguousTimestamp</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>