<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Parse an RFC 2822 datetime string into a `Zoned`."><title>parse in jiff::fmt::rfc2822 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">parse</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#warning" title="Warning">Warning</a></li><li><a href="#errors" title="Errors">Errors</a></li><li><a href="#example" title="Example">Example</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>fmt::<wbr>rfc2822</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">jiff</a>::<wbr><a href="../index.html">fmt</a>::<wbr><a href="index.html">rfc2822</a></div><h1>Function <span class="fn">parse</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/jiff/fmt/rfc2822.rs.html#171-173">Source</a> </span></div><pre class="rust item-decl"><code>pub fn parse(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Parse an <a href="https://datatracker.ietf.org/doc/html/rfc2822">RFC 2822</a> datetime string into a <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.</p>
<p>This is a convenience function for using <a href="struct.DateTimeParser.html" title="struct jiff::fmt::rfc2822::DateTimeParser"><code>DateTimeParser</code></a>. In particular,
this takes a <code>&amp;str</code> while the <code>DateTimeParser</code> accepts a <code>&amp;[u8]</code>.
Moreover, if any configuration options are added to RFC 2822 parsing (none
currently exist at time of writing), then it will be necessary to use a
<code>DateTimeParser</code> to toggle them. Additionally, a <code>DateTimeParser</code> is needed
for parsing into a <a href="../../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>.</p>
<h2 id="warning"><a class="doc-anchor" href="#warning">§</a>Warning</h2>
<p>The RFC 2822 format only supports writing a precise instant in time
expressed via a time zone offset. It does <em>not</em> support serializing
the time zone itself. This means that if you format a zoned datetime
in a time zone like <code>America/New_York</code> and then deserialize it, the
zoned datetime you get back will be a “fixed offset” zoned datetime.
This in turn means it will not perform daylight saving time safe
arithmetic.</p>
<p>Basically, you should use the RFC 2822 format if it’s required (for
example, when dealing with email). But you should not choose it as a
general interchange format for new applications.</p>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesn’t fit in the datetime range supported by Jiff. For
example, RFC 2822 supports offsets up to 99 hours and 59 minutes,
but Jiff’s maximum offset is 25 hours, 59 minutes and 59 seconds.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>This example shows how serializing a zoned datetime to RFC 2822 format
and then deserializing will drop information:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::rfc2822};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">13</span>)
    .at(<span class="number">15</span>, <span class="number">9</span>, <span class="number">59</span>, <span class="number">789_000_000</span>)
    .in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// The default format (i.e., Temporal) guarantees lossless
// serialization.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-13T15:09:59.789-04:00[America/New_York]"</span>);

<span class="kw">let </span>rfc2822 = rfc2822::to_string(<span class="kw-2">&amp;</span>zdt)<span class="question-mark">?</span>;
<span class="comment">// Notice that the time zone name and fractional seconds have been dropped!
</span><span class="macro">assert_eq!</span>(rfc2822, <span class="string">"Sat, 13 Jul 2024 15:09:59 -0400"</span>);
<span class="comment">// And of course, if we parse it back, all that info is still lost.
// Which means this `zdt` cannot do DST safe arithmetic!
</span><span class="kw">let </span>zdt = rfc2822::parse(<span class="kw-2">&amp;</span>rfc2822)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-13T15:09:59-04:00[-04:00]"</span>);
</code></pre></div>
</div></details></section></div></main></body></html>