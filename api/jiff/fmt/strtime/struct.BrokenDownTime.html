<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The “broken down time” used by parsing and formatting."><title>BrokenDownTime in jiff::fmt::strtime - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Broken<wbr>Down<wbr>Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.day" title="day">day</a></li><li><a href="#method.day_of_year" title="day_of_year">day_of_year</a></li><li><a href="#method.format" title="format">format</a></li><li><a href="#method.format_with_config" title="format_with_config">format_with_config</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.iana_time_zone" title="iana_time_zone">iana_time_zone</a></li><li><a href="#method.iso_week" title="iso_week">iso_week</a></li><li><a href="#method.iso_week_year" title="iso_week_year">iso_week_year</a></li><li><a href="#method.meridiem" title="meridiem">meridiem</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.monday_based_week" title="monday_based_week">monday_based_week</a></li><li><a href="#method.month" title="month">month</a></li><li><a href="#method.offset" title="offset">offset</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.parse_prefix" title="parse_prefix">parse_prefix</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.set_day" title="set_day">set_day</a></li><li><a href="#method.set_day_of_year" title="set_day_of_year">set_day_of_year</a></li><li><a href="#method.set_hour" title="set_hour">set_hour</a></li><li><a href="#method.set_iana_time_zone" title="set_iana_time_zone">set_iana_time_zone</a></li><li><a href="#method.set_iso_week" title="set_iso_week">set_iso_week</a></li><li><a href="#method.set_iso_week_year" title="set_iso_week_year">set_iso_week_year</a></li><li><a href="#method.set_minute" title="set_minute">set_minute</a></li><li><a href="#method.set_monday_based_week" title="set_monday_based_week">set_monday_based_week</a></li><li><a href="#method.set_month" title="set_month">set_month</a></li><li><a href="#method.set_offset" title="set_offset">set_offset</a></li><li><a href="#method.set_second" title="set_second">set_second</a></li><li><a href="#method.set_subsec_nanosecond" title="set_subsec_nanosecond">set_subsec_nanosecond</a></li><li><a href="#method.set_sunday_based_week" title="set_sunday_based_week">set_sunday_based_week</a></li><li><a href="#method.set_weekday" title="set_weekday">set_weekday</a></li><li><a href="#method.set_year" title="set_year">set_year</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.sunday_based_week" title="sunday_based_week">sunday_based_week</a></li><li><a href="#method.to_date" title="to_date">to_date</a></li><li><a href="#method.to_datetime" title="to_datetime">to_datetime</a></li><li><a href="#method.to_string" title="to_string">to_string</a></li><li><a href="#method.to_string_with_config" title="to_string_with_config">to_string_with_config</a></li><li><a href="#method.to_time" title="to_time">to_time</a></li><li><a href="#method.to_timestamp" title="to_timestamp">to_timestamp</a></li><li><a href="#method.to_zoned" title="to_zoned">to_zoned</a></li><li><a href="#method.to_zoned_with" title="to_zoned_with">to_zoned_with</a></li><li><a href="#method.weekday" title="weekday">weekday</a></li><li><a href="#method.year" title="year">year</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-BrokenDownTime" title="Debug">Debug</a></li><li><a href="#impl-Default-for-BrokenDownTime" title="Default">Default</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDate%3E-for-BrokenDownTime" title="From&#60;Date&#62;">From&#60;Date&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CISOWeekDate%3E-for-BrokenDownTime" title="From&#60;ISOWeekDate&#62;">From&#60;ISOWeekDate&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-BrokenDownTime" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-BrokenDownTime" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-BrokenDownTime" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-BrokenDownTime" title="Send">Send</a></li><li><a href="#impl-Sync-for-BrokenDownTime" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-BrokenDownTime" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-BrokenDownTime" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>fmt::<wbr>strtime</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">jiff</a>::<wbr><a href="../index.html">fmt</a>::<wbr><a href="index.html">strtime</a></div><h1>Struct <span class="struct">BrokenDownTime</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/jiff/fmt/strtime/mod.rs.html#868-902">Source</a> </span></div><pre class="rust item-decl"><code>pub struct BrokenDownTime { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The “broken down time” used by parsing and formatting.</p>
<p>This is a lower level aspect of the <code>strptime</code> and <code>strftime</code> APIs that you
probably won’t need to use directly. The main use case is if you want to
observe formatting errors or if you want to format a datetime to something
other than a <code>String</code> via the <a href="../trait.Write.html" title="trait jiff::fmt::Write"><code>fmt::Write</code></a> trait.</p>
<p>Otherwise, typical use of this module happens indirectly via APIs like
<a href="../../struct.Zoned.html#method.strptime" title="associated function jiff::Zoned::strptime"><code>Zoned::strptime</code></a> and <a href="../../struct.Zoned.html#method.strftime" title="method jiff::Zoned::strftime"><code>Zoned::strftime</code></a>.</p>
<h2 id="design"><a class="doc-anchor" href="#design">§</a>Design</h2>
<p>This is the type that parsing writes to and formatting reads from. That
is, parsing proceeds by writing individual parsed fields to this type, and
then converting the fields to datetime types like <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> only after
parsing is complete. Similarly, formatting always begins by converting
datetime types like <code>Zoned</code> into a <code>BrokenDownTime</code>, and then formatting
the individual fields from there.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#904-2959">Source</a><a href="#impl-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#930-935">Source</a><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given <code>input</code> according to the given <code>format</code> string.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is the same as the module level free function
<a href="fn.parse.html" title="fn jiff::fmt::strtime::parse"><code>strtime::parse</code></a>.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_prefix" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1035-1040">Source</a><h4 class="code-header">pub fn <a href="#method.parse_prefix" class="fn">parse_prefix</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a>, <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a prefix of the given <code>input</code> according to the given <code>format</code>
string. The offset returned corresponds to the number of bytes parsed.
That is, the length of the prefix (which may be the length of the
entire input if there are no unparsed bytes remaining).</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This is like <a href="struct.BrokenDownTime.html#method.parse" title="associated function jiff::fmt::strtime::BrokenDownTime::parse"><code>BrokenDownTime::parse</code></a>, but it won’t return an error
if there is input remaining after parsing the format directives.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="comment">// %y only parses two-digit years, so the 99 following
// 24 is unparsed!
</span><span class="kw">let </span>input = <span class="string">"7/14/2499"</span>;
<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(<span class="string">"%m/%d/%y"</span>, input)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">7</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>input[offset..], <span class="string">"99"</span>);
</code></pre></div>
<p>If the entire input is parsed, then the offset is the length of the
input:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(
    <span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>,
)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">14</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">7</span>);
</code></pre></div>
<h5 id="example-how-to-parse-only-a-part-of-a-timestamp"><a class="doc-anchor" href="#example-how-to-parse-only-a-part-of-a-timestamp">§</a>Example: how to parse only a part of a timestamp</h5>
<p>If you only need, for example, the date from a timestamp, then you
can parse it as a prefix:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>input = <span class="string">"2024-01-20T17:55Z"</span>;
<span class="kw">let </span>(tm, offset) = BrokenDownTime::parse_prefix(<span class="string">"%Y-%m-%d"</span>, input)<span class="question-mark">?</span>;
<span class="kw">let </span>date = tm.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">20</span>));
<span class="macro">assert_eq!</span>(offset, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>input[offset..], <span class="string">"T17:55Z"</span>);
</code></pre></div>
<p>Note though that Jiff’s default parsing functions are already quite
flexible, and one can just parse a civil date directly from a timestamp
automatically:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil;

<span class="kw">let </span>input = <span class="string">"2024-01-20T17:55-05"</span>;
<span class="kw">let </span>date: civil::Date = input.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date, civil::date(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">20</span>));
</code></pre></div>
<p>Although in this case, you don’t get the length of the prefix parsed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.format" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1095-1101">Source</a><h4 class="code-header">pub fn <a href="#method.format" class="fn">format</a>&lt;W: <a class="trait" href="../trait.Write.html" title="trait jiff::fmt::Write">Write</a>&gt;(
    &amp;self,
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    wtr: W,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Format this broken down time using the format string given.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like the module level free function
<a href="fn.parse.html" title="fn jiff::fmt::strtime::parse"><code>strtime::format</code></a>, except it takes a
<a href="../trait.Write.html" title="trait jiff::fmt::Write"><code>fmt::Write</code></a> trait implementations instead of assuming
you want a <code>String</code>.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<p>Formatting also fails if writing to the given writer fails.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>This example shows a formatting option, <code>%Z</code>, that isn’t available
during parsing. Namely, <code>%Z</code> inserts a time zone abbreviation. This
is generally only intended for display purposes, since it can be
ambiguous when parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">9</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);

<span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
tm.format(<span class="string">"%a %b %e %I:%M:%S %p %Z %Y"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(buf, <span class="string">"Tue Jul  9 04:24:00 PM EDT 2024"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.format_with_config" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1145-1155">Source</a><h4 class="code-header">pub fn <a href="#method.format_with_config" class="fn">format_with_config</a>&lt;W: <a class="trait" href="../trait.Write.html" title="trait jiff::fmt::Write">Write</a>, L: <a class="trait" href="trait.Custom.html" title="trait jiff::fmt::strtime::Custom">Custom</a>&gt;(
    &amp;self,
    config: &amp;<a class="struct" href="struct.Config.html" title="struct jiff::fmt::strtime::Config">Config</a>&lt;L&gt;,
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    wtr: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut W</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Format this broken down time with a specific configuration using the
format string given.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like <a href="struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a>, except that it
permits callers to provide their own configuration instead of using
the default. This routine also accepts a <code>&amp;mut W</code> instead of a <code>W</code>,
which may be more flexible in some situations.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<p>Formatting also fails if writing to the given writer fails.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This example shows how to use <a href="struct.PosixCustom.html" title="struct jiff::fmt::strtime::PosixCustom"><code>PosixCustom</code></a> to get formatting
for conversion specifiers like <code>%c</code> in the POSIX locale:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::{BrokenDownTime, PosixCustom, Config}};

<span class="kw">let </span><span class="kw-2">mut </span>buf = String::new();
<span class="kw">let </span>dt = civil::date(<span class="number">2025</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>tm = BrokenDownTime::from(dt);
tm.format(<span class="string">"%c"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(buf, <span class="string">"2025 M07 1, Tue 17:30:00"</span>);

<span class="kw">let </span>config = Config::new().custom(PosixCustom::new());
buf.clear();
tm.format_with_config(<span class="kw-2">&amp;</span>config, <span class="string">"%c"</span>, <span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(buf, <span class="string">"Tue Jul  1 17:30:00 2025"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1194-1202">Source</a><h4 class="code-header">pub fn <a href="#method.to_string" class="fn">to_string</a>(&amp;self, format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Format this broken down time using the format string given into a new
<code>String</code>.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This is like <a href="struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a>, but always uses a <code>String</code> to
format the time into. If you need to reuse allocations or write a
formatted time into a different type, then you should use
<a href="struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>BrokenDownTime::format</code></a> instead.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows a formatting option, <code>%Z</code>, that isn’t available
during parsing. Namely, <code>%Z</code> inserts a time zone abbreviation. This
is generally only intended for display purposes, since it can be
ambiguous when parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">9</span>).at(<span class="number">16</span>, <span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
<span class="kw">let </span>string = tm.to_string(<span class="string">"%a %b %e %I:%M:%S %p %Z %Y"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(string, <span class="string">"Tue Jul  9 04:24:00 PM EDT 2024"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_string_with_config" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1246-1255">Source</a><h4 class="code-header">pub fn <a href="#method.to_string_with_config" class="fn">to_string_with_config</a>&lt;L: <a class="trait" href="trait.Custom.html" title="trait jiff::fmt::strtime::Custom">Custom</a>&gt;(
    &amp;self,
    config: &amp;<a class="struct" href="struct.Config.html" title="struct jiff::fmt::strtime::Config">Config</a>&lt;L&gt;,
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Format this broken down time with a specific configuration using the
format string given into a new <code>String</code>.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::strtime">module documentation</a> for details on what’s supported.</p>
<p>This routine is like <a href="struct.BrokenDownTime.html#method.to_string" title="method jiff::fmt::strtime::BrokenDownTime::to_string"><code>BrokenDownTime::to_string</code></a>, except that it
permits callers to provide their own configuration instead of using
the default.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error when formatting failed. Formatting can fail
either because of an invalid format string, or if formatting requires
a field in <code>BrokenDownTime</code> to be set that isn’t. For example, trying
to format a <a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>DateTime</code></a> with the <code>%z</code> specifier will fail because a
<code>DateTime</code> has no time zone or offset information associated with it.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to use <a href="struct.PosixCustom.html" title="struct jiff::fmt::strtime::PosixCustom"><code>PosixCustom</code></a> to get formatting
for conversion specifiers like <code>%c</code> in the POSIX locale:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::strtime::{BrokenDownTime, PosixCustom, Config}};

<span class="kw">let </span>dt = civil::date(<span class="number">2025</span>, <span class="number">7</span>, <span class="number">1</span>).at(<span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>tm = BrokenDownTime::from(dt);
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%c"</span>)<span class="question-mark">?</span>,
    <span class="string">"2025 M07 1, Tue 17:30:00"</span>,
);

<span class="kw">let </span>config = Config::new().custom(PosixCustom::new());
<span class="macro">assert_eq!</span>(
    tm.to_string_with_config(<span class="kw-2">&amp;</span>config, <span class="string">"%c"</span>)<span class="question-mark">?</span>,
    <span class="string">"Tue Jul  1 17:30:00 2025"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1327-1329">Source</a><h4 class="code-header">pub fn <a href="#method.to_zoned" class="fn">to_zoned</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a zoned datetime from this broken down time.</p>
<p>When an IANA time zone identifier is
present but an offset is not, then the
<a href="../../tz/enum.Disambiguation.html#variant.Compatible" title="variant jiff::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy is used if the parsed datetime is ambiguous in the time zone.</p>
<p>If you need to use a custom time zone database for doing IANA time
zone identifier lookups (via the <code>%Q</code> directive), then use
<a href="struct.BrokenDownTime.html#method.to_zoned_with" title="method jiff::fmt::strtime::BrokenDownTime::to_zoned_with"><code>BrokenDownTime::to_zoned_with</code></a>.</p>
<h5 id="warning"><a class="doc-anchor" href="#warning">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not require an IANA time zone identifier
to parse a <code>Zoned</code>. If one is not used, then if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>However, the <code>%Q</code> directive may be used to both format and parse an
IANA time zone identifier. It is strongly recommended to use this
directive whenever one is formatting or parsing <code>Zoned</code> values.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil datetime <em>and</em> either a UTC offset or a IANA time zone
identifier. When both a UTC offset and an IANA time zone identifier
are found, then <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a> is used to detect any
inconsistency between the offset and the time zone.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This example shows how to parse a zoned datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>zdt = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-14T21:14:00-04:00[US/Eastern]"</span>);
</code></pre></div>
<p>This shows that an error is returned when the offset is inconsistent
with the time zone. For example, <code>US/Eastern</code> is in daylight saving
time in July 2024:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>result = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -05:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned();
<span class="macro">assert_eq!</span>(
    result.unwrap_err().to_string(),
    <span class="string">"datetime 2024-07-14T21:14:00 could not resolve to a \
     timestamp since 'reject' conflict resolution was chosen, \
     and because datetime has offset -05, but the time zone \
     US/Eastern for the given datetime unambiguously has offset -04"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned_with" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1380-1416">Source</a><h4 class="code-header">pub fn <a href="#method.to_zoned_with" class="fn">to_zoned_with</a>(&amp;self, db: &amp;<a class="struct" href="../../tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase">TimeZoneDatabase</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a zoned datetime from this broken down time and uses the time
zone database given for any IANA time zone identifier lookups.</p>
<p>An IANA time zone identifier lookup is only performed when this
<code>BrokenDownTime</code> contains an IANA time zone identifier. An IANA time
zone identifier can be parsed with the <code>%Q</code> directive.</p>
<p>When an IANA time zone identifier is
present but an offset is not, then the
<a href="../../tz/enum.Disambiguation.html#variant.Compatible" title="variant jiff::tz::Disambiguation::Compatible"><code>Disambiguation::Compatible</code></a>
strategy is used if the parsed datetime is ambiguous in the time zone.</p>
<h5 id="warning-1"><a class="doc-anchor" href="#warning-1">§</a>Warning</h5>
<p>The <code>strtime</code> module APIs do not require an IANA time zone identifier
to parse a <code>Zoned</code>. If one is not used, then if you format a zoned
datetime in a time zone like <code>America/New_York</code> and then parse it back
again, the zoned datetime you get back will be a “fixed offset” zoned
datetime. This in turn means it will not perform daylight saving time
safe arithmetic.</p>
<p>However, the <code>%Q</code> directive may be used to both format and parse an
IANA time zone identifier. It is strongly recommended to use this
directive whenever one is formatting or parsing <code>Zoned</code> values.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil datetime <em>and</em> either a UTC offset or a IANA time zone
identifier. When both a UTC offset and an IANA time zone identifier
are found, then <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a> is used to detect any
inconsistency between the offset and the time zone.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This example shows how to parse a zoned datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>zdt = strtime::parse(
    <span class="string">"%F %H:%M %:z %:Q"</span>,
    <span class="string">"2024-07-14 21:14 -04:00 US/Eastern"</span>,
)<span class="question-mark">?</span>.to_zoned_with(jiff::tz::db())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2024-07-14T21:14:00-04:00[US/Eastern]"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_timestamp" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1441-1454">Source</a><h4 class="code-header">pub fn <a href="#method.to_timestamp" class="fn">to_timestamp</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a timestamp from this broken down time.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil datetime <em>and</em> a UTC offset.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This example shows how to parse a timestamp from a broken down time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>ts = strtime::parse(
    <span class="string">"%F %H:%M %:z"</span>,
    <span class="string">"2024-07-14 21:14 -04:00"</span>,
)<span class="question-mark">?</span>.to_timestamp()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-07-15T01:14:00Z"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_datetime" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1492-1498">Source</a><h4 class="code-header">pub fn <a href="#method.to_datetime" class="fn">to_datetime</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil datetime from this broken down time.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil datetime. This means there must be at least a year, month and
day.</p>
<p>It’s okay if there are more units than are needed to construct a civil
datetime. For example, if this broken down time contains an offset,
then it won’t prevent a conversion to a civil datetime.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<p>This example shows how to parse a civil datetime from a broken down
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>dt = strtime::parse(<span class="string">"%F %H:%M"</span>, <span class="string">"2024-07-14 21:14"</span>)<span class="question-mark">?</span>.to_datetime()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dt.to_string(), <span class="string">"2024-07-14T21:14:00"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_date" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1529-1569">Source</a><h4 class="code-header">pub fn <a href="#method.to_date" class="fn">to_date</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Date.html" title="struct jiff::civil::Date">Date</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil date from this broken down time.</p>
<p>This requires that the year is set along with a way to identify the day
in the year. This can be done by either setting the month and the day
of the month (<code>%m</code> and <code>%d</code>), or by setting the day of the year (<code>%j</code>).</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil date. This means there must be at least a year and either the
month and day or the day of the year.</p>
<p>It’s okay if there are more units than are needed to construct a civil
datetime. For example, if this broken down time contain a civil time,
then it won’t prevent a conversion to a civil date.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This example shows how to parse a civil date from a broken down time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>date = strtime::parse(<span class="string">"%m/%d/%y"</span>, <span class="string">"7/14/24"</span>)<span class="question-mark">?</span>.to_date()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(date.to_string(), <span class="string">"2024-07-14"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_time" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1783-1839">Source</a><h4 class="code-header">pub fn <a href="#method.to_time" class="fn">to_time</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Extracts a civil time from this broken down time.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>This returns an error if there weren’t enough components to construct
a civil time. Interestingly, this succeeds if there are no time units,
since this will assume an absent time is midnight. However, this can
still error when, for example, there are minutes but no hours.</p>
<p>It’s okay if there are more units than are needed to construct a civil
time. For example, if this broken down time contains a date, then it
won’t prevent a conversion to a civil time.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<p>This example shows how to parse a civil time from a broken down
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>time = strtime::parse(<span class="string">"%H:%M:%S"</span>, <span class="string">"21:14:59"</span>)<span class="question-mark">?</span>.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"21:14:59"</span>);
</code></pre></div>
<h5 id="example-time-defaults-to-midnight"><a class="doc-anchor" href="#example-time-defaults-to-midnight">§</a>Example: time defaults to midnight</h5>
<p>Since time defaults to midnight, one can parse an empty input string
with an empty format string and still extract a <code>Time</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="kw">let </span>time = strtime::parse(<span class="string">""</span>, <span class="string">""</span>)<span class="question-mark">?</span>.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"00:00:00"</span>);
</code></pre></div>
<h5 id="example-invalid-time"><a class="doc-anchor" href="#example-invalid-time">§</a>Example: invalid time</h5>
<p>Other than using illegal values (like <code>24</code> for hours), if lower units
are parsed without higher units, then this results in an error:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="macro">assert!</span>(strtime::parse(<span class="string">"%M:%S"</span>, <span class="string">"15:36"</span>)<span class="question-mark">?</span>.to_time().is_err());
</code></pre></div>
<h5 id="example-invalid-date"><a class="doc-anchor" href="#example-invalid-date">§</a>Example: invalid date</h5>
<p>Since validation of a date is only done when a date is requested, it is
actually possible to parse an invalid date and extract the time without
an error occurring:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime;

<span class="comment">// 31 is a legal day value, but not for June.
// However, this is not validated unless you
// ask for a `Date` from the parsed `BrokenDownTime`.
// Everything except for `BrokenDownTime::time`
// creates a date, so asking for only a `time`
// will circumvent date validation!
</span><span class="kw">let </span>tm = strtime::parse(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, <span class="string">"2024-06-31 21:14:59"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = tm.to_time()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"21:14:59"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1878-1880">Source</a><h4 class="code-header">pub fn <a href="#method.year" class="fn">year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed year, if available.</p>
<p>This is also set when a 2 digit year is parsed. (But that’s limited to
the years 1969 to 2068, inclusive.)</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<p>This shows how to parse just a year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y"</span>, <span class="string">"2024"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
</code></pre></div>
<p>And 2-digit years are supported too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"24"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2000</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"69"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">1969</span>));

<span class="comment">// 2-digit years have limited range. They must
// be in the range 0-99.
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%y"</span>, <span class="string">"2024"</span>).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1903-1905">Source</a><h4 class="code-header">pub fn <a href="#method.month" class="fn">month</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed month, if available.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<p>This shows a few different ways of parsing just a month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%m"</span>, <span class="string">"12"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%B"</span>, <span class="string">"December"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%b"</span>, <span class="string">"Dec"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.month(), <span class="prelude-val">Some</span>(<span class="number">12</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#1942-1944">Source</a><h4 class="code-header">pub fn <a href="#method.day" class="fn">day</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed day, if available.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<p>This shows how to parse the day of the month:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"05"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%03d"</span>, <span class="string">"005"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="comment">// Parsing a day only works for all possible legal
// values, even if, e.g., 31 isn't valid for all
// possible year/month combinations.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"31"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">31</span>));
<span class="comment">// This is true even if you're parsing a full date:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%m-%d"</span>, <span class="string">"2024-04-31"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day(), <span class="prelude-val">Some</span>(<span class="number">31</span>));
<span class="comment">// An error only occurs when you try to extract a date:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// But parsing a value that is always illegal will
// result in an error:
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%d"</span>, <span class="string">"32"</span>).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.day_of_year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2013-2015">Source</a><h4 class="code-header">pub fn <a href="#method.day_of_year" class="fn">day_of_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed day of the year (1-366), if available.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<p>This shows how to parse the day of the year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%j"</span>)<span class="question-mark">?</span>, <span class="string">"005"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%-j"</span>)<span class="question-mark">?</span>, <span class="string">"5"</span>);

<span class="comment">// Parsing the day of the year works for all possible legal
// values, even if, e.g., 366 isn't valid for all possible
// year/month combinations.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"366"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">366</span>));
<span class="comment">// This is true even if you're parsing a year:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y/%j"</span>, <span class="string">"2023/366"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">366</span>));
<span class="comment">// An error only occurs when you try to extract a date:
</span><span class="macro">assert_eq!</span>(
    tm.to_date().unwrap_err().to_string(),
    <span class="string">"invalid date: day-of-year=366 is out of range \
     for year=2023, must be in range 1..=365"</span>,
);
<span class="comment">// But parsing a value that is always illegal will
// result in an error:
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"0"</span>).is_err());
<span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%j"</span>, <span class="string">"367"</span>).is_err());
</code></pre></div>
<h5 id="example-extract-a-date"><a class="doc-anchor" href="#example-extract-a-date">§</a>Example: extract a <a href="../../civil/struct.Date.html" title="struct jiff::civil::Date"><code>Date</code></a></h5>
<p>This example shows how parsing a year and a day of the year enables
the extraction of a date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%j"</span>, <span class="string">"2024-60"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>));
</code></pre></div>
<p>When all of <code>%m</code>, <code>%d</code> and <code>%j</code> are used, then <code>%m</code> and <code>%d</code> take
priority over <code>%j</code> when extracting a <code>Date</code> from a <code>BrokenDownTime</code>.
However, <code>%j</code> is still parsed and accessible:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d (day of year: %j)"</span>,
    <span class="string">"2024-02-29 (day of year: 1)"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">29</span>));
<span class="macro">assert_eq!</span>(tm.day_of_year(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week_year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2054-2056">Source</a><h4 class="code-header">pub fn <a href="#method.iso_week_year" class="fn">iso_week_year</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed ISO 8601 week-based year, if available.</p>
<p>This is also set when a 2 digit ISO 8601 week-based year is parsed.
(But that’s limited to the years 1969 to 2068, inclusive.)</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<p>This shows how to parse just an ISO 8601 week-based year:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%G"</span>, <span class="string">"2024"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
</code></pre></div>
<p>And 2-digit years are supported too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"24"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2024</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2000</span>));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"69"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">1969</span>));

<span class="comment">// 2-digit years have limited range. They must
// be in the range 0-99.
</span><span class="macro">assert!</span>(BrokenDownTime::parse(<span class="string">"%g"</span>, <span class="string">"2024"</span>).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2080-2082">Source</a><h4 class="code-header">pub fn <a href="#method.iso_week" class="fn">iso_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed ISO 8601 week-based number, if available.</p>
<p>The week number is guaranteed to be in the range <code>1..53</code>. Week <code>1</code> is
the first week of the year to contain 4 days.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This shows how to parse just an ISO 8601 week-based dates:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%G-W%V-%u"</span>, <span class="string">"2020-W01-1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iso_week_year(), <span class="prelude-val">Some</span>(<span class="number">2020</span>));
<span class="macro">assert_eq!</span>(tm.iso_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">30</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sunday_based_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2104-2106">Source</a><h4 class="code-header">pub fn <a href="#method.sunday_based_week" class="fn">sunday_based_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the Sunday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Sunday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%U-%w"</span>, <span class="string">"2025-01-0"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2025</span>));
<span class="macro">assert_eq!</span>(tm.sunday_based_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Sunday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">5</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.monday_based_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2128-2130">Source</a><h4 class="code-header">pub fn <a href="#method.monday_based_week" class="fn">monday_based_week</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the Monday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Monday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Y-%U-%w"</span>, <span class="string">"2025-01-1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.year(), <span class="prelude-val">Some</span>(<span class="number">2025</span>));
<span class="macro">assert_eq!</span>(tm.sunday_based_week(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">6</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2166-2168">Source</a><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed hour, if available.</p>
<p>The hour returned incorporates <a href="struct.BrokenDownTime.html#method.meridiem" title="method jiff::fmt::strtime::BrokenDownTime::meridiem"><code>BrokenDownTime::meridiem</code></a> if it’s
set. That is, if the actual parsed hour value is <code>1</code> but the meridiem
is <code>PM</code>, then the hour returned by this method will be <code>13</code>.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This shows a how to parse an hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%H"</span>, <span class="string">"13"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">13</span>));

<span class="comment">// When parsing a 12-hour clock without a
// meridiem, the hour value is as parsed.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%I"</span>, <span class="string">"1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">1</span>));

<span class="comment">// If a meridiem is parsed, then it is used
// to calculate the correct hour value.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%I%P"</span>, <span class="string">"1pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">13</span>));

<span class="comment">// This works even if the hour and meridiem are
// inconsistent with each other:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%H%P"</span>, <span class="string">"13am"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.hour(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2195-2197">Source</a><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed minute, if available.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This shows how to parse the minute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%M"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.minute(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2214-2216">Source</a><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed second, if available.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This shows how to parse the second:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S"</span>, <span class="string">"5"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2249-2251">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed subsecond nanosecond, if available.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<p>This shows how to parse fractional seconds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%f"</span>, <span class="string">"123456"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">Some</span>(<span class="number">123_456_000</span>));
</code></pre></div>
<p>Note that when using <code>%.f</code>, the fractional component is optional!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S%.f"</span>, <span class="string">"1"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">None</span>);

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%S%.f"</span>, <span class="string">"1.789"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.second(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(tm.subsec_nanosecond(), <span class="prelude-val">Some</span>(<span class="number">789_000_000</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2283-2285">Source</a><h4 class="code-header">pub fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed offset, if available.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<p>This shows how to parse the offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz::Offset};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%z"</span>, <span class="string">"-0430"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60</span>).unwrap()),
);
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%z"</span>, <span class="string">"-043059"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60 </span>- <span class="number">59</span>).unwrap()),
);

<span class="comment">// Or, if you want colons:
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%:z"</span>, <span class="string">"-04:30"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    tm.offset(),
    <span class="prelude-val">Some</span>(Offset::from_seconds(-<span class="number">4 </span>* <span class="number">60 </span>* <span class="number">60 </span>- <span class="number">30 </span>* <span class="number">60</span>).unwrap()),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iana_time_zone" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2313-2322">Source</a><h4 class="code-header">pub fn <a href="#method.iana_time_zone" class="fn">iana_time_zone</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the time zone IANA identifier, if available.</p>
<p>Note that when <code>alloc</code> is disabled, this always returns <code>None</code>. (And
there is no way to set it.)</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<p>This shows how to parse an IANA time zone identifier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Q"</span>, <span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iana_time_zone(), <span class="prelude-val">Some</span>(<span class="string">"US/Eastern"</span>));
<span class="macro">assert_eq!</span>(tm.offset(), <span class="prelude-val">None</span>);

<span class="comment">// Note that %Q (and %:Q) also support parsing an offset
// as a fallback. If that occurs, an IANA time zone
// identifier is not available.
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%Q"</span>, <span class="string">"-0400"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.iana_time_zone(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.offset(), <span class="prelude-val">Some</span>(tz::offset(-<span class="number">4</span>)));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weekday" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2366-2368">Source</a><h4 class="code-header">pub fn <a href="#method.weekday" class="fn">weekday</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../civil/enum.Weekday.html" title="enum jiff::civil::Weekday">Weekday</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed weekday, if available.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<p>This shows a few different ways of parsing just a weekday:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%A"</span>, <span class="string">"Saturday"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Saturday));

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%a"</span>, <span class="string">"Sat"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Saturday));

<span class="comment">// A weekday is only available if it is explicitly parsed!
</span><span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%F"</span>, <span class="string">"2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">None</span>);
<span class="comment">// If you need a weekday derived from a parsed date, then:
</span><span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>.weekday(), Weekday::Saturday);
</code></pre></div>
<p>Note that this will return the parsed weekday even if
it’s inconsistent with a parsed date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Weekday, date}, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(<span class="string">"%a, %F"</span>, <span class="string">"Wed, 2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="comment">// 2024-07-27 is a Saturday, but Wednesday was parsed:
</span><span class="macro">assert_eq!</span>(tm.weekday(), <span class="prelude-val">Some</span>(Weekday::Wednesday));
<span class="comment">// An error only occurs when extracting a date:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// To skip the weekday, error checking, zero it out first:
</span>tm.set_weekday(<span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">27</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.meridiem" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2392-2394">Source</a><h4 class="code-header">pub fn <a href="#method.meridiem" class="fn">meridiem</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Meridiem.html" title="enum jiff::fmt::strtime::Meridiem">Meridiem</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the parsed meridiem, if available.</p>
<p>Note that unlike other fields, there is no
<code>BrokenDownTime::set_meridiem</code>. Instead, when formatting, the meridiem
label (if it’s used in the formatting string) is determined purely as a
function of the hour in a 24 hour clock.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<p>This shows a how to parse the meridiem:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::{BrokenDownTime, Meridiem};

<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%p"</span>, <span class="string">"AM"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.meridiem(), <span class="prelude-val">Some</span>(Meridiem::AM));
<span class="kw">let </span>tm = BrokenDownTime::parse(<span class="string">"%P"</span>, <span class="string">"pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.meridiem(), <span class="prelude-val">Some</span>(Meridiem::PM));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2416-2422">Source</a><h4 class="code-header">pub fn <a href="#method.set_year" class="fn">set_year</a>(&amp;mut self, year: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the year on this broken down time.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This returns an error if the given year is out of range.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_year(<span class="prelude-val">Some</span>(<span class="number">10_000</span>)).is_err());
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%Y"</span>)<span class="question-mark">?</span>, <span class="string">"2024"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_month" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2444-2450">Source</a><h4 class="code-header">pub fn <a href="#method.set_month" class="fn">set_month</a>(&amp;mut self, month: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the month on this broken down time.</p>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>This returns an error if the given month is out of range.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_month(<span class="prelude-val">Some</span>(<span class="number">0</span>)).is_err());
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">12</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%B"</span>)<span class="question-mark">?</span>, <span class="string">"December"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_day" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2483-2489">Source</a><h4 class="code-header">pub fn <a href="#method.set_day" class="fn">set_day</a>(&amp;mut self, day: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the day on this broken down time.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>This returns an error if the given day is out of range.</p>
<p>Note that setting a day to a value that is legal in any context is
always valid, even if it isn’t valid for the year and month
components already set.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_day(<span class="prelude-val">Some</span>(<span class="number">32</span>)).is_err());
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%d"</span>)<span class="question-mark">?</span>, <span class="string">"31"</span>);

<span class="comment">// Works even if the resulting date is invalid.
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
tm.set_month(<span class="prelude-val">Some</span>(<span class="number">4</span>))<span class="question-mark">?</span>;
tm.set_day(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>; <span class="comment">// April has 30 days, not 31
</span><span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%F"</span>)<span class="question-mark">?</span>, <span class="string">"2024-04-31"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_day_of_year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2521-2527">Source</a><h4 class="code-header">pub fn <a href="#method.set_day_of_year" class="fn">set_day_of_year</a>(&amp;mut self, day: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the day of year on this broken down time.</p>
<h5 id="errors-15"><a class="doc-anchor" href="#errors-15">§</a>Errors</h5>
<p>This returns an error if the given day is out of range.</p>
<p>Note that setting a day to a value that is legal in any context
is always valid, even if it isn’t valid for the year, month and
day-of-month components already set.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">367</span>)).is_err());
tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">31</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%j"</span>)<span class="question-mark">?</span>, <span class="string">"031"</span>);

<span class="comment">// Works even if the resulting date is invalid.
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_year(<span class="prelude-val">Some</span>(<span class="number">2023</span>))<span class="question-mark">?</span>;
tm.set_day_of_year(<span class="prelude-val">Some</span>(<span class="number">366</span>))<span class="question-mark">?</span>; <span class="comment">// 2023 wasn't a leap year
</span><span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%Y/%j"</span>)<span class="question-mark">?</span>, <span class="string">"2023/366"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_iso_week_year" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2549-2558">Source</a><h4 class="code-header">pub fn <a href="#method.set_iso_week_year" class="fn">set_iso_week_year</a>(&amp;mut self, year: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i16.html">i16</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the ISO 8601 week-based year on this broken down time.</p>
<h5 id="errors-16"><a class="doc-anchor" href="#errors-16">§</a>Errors</h5>
<p>This returns an error if the given year is out of range.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">10_000</span>)).is_err());
tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">2024</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%G"</span>)<span class="question-mark">?</span>, <span class="string">"2024"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_iso_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2589-2598">Source</a><h4 class="code-header">pub fn <a href="#method.set_iso_week" class="fn">set_iso_week</a>(&amp;mut self, week_number: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the ISO 8601 week-based number on this broken down time.</p>
<p>The week number must be in the range <code>1..53</code>. Week <code>1</code> is
the first week of the year to contain 4 days.</p>
<h5 id="errors-17"><a class="doc-anchor" href="#errors-17">§</a>Errors</h5>
<p>This returns an error if the given week number is out of range.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">0</span>)).is_err());
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">54</span>)).is_err());

tm.set_iso_week_year(<span class="prelude-val">Some</span>(<span class="number">2020</span>))<span class="question-mark">?</span>;
tm.set_iso_week(<span class="prelude-val">Some</span>(<span class="number">1</span>))<span class="question-mark">?</span>;
tm.set_weekday(<span class="prelude-val">Some</span>(Weekday::Monday));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%G-W%V-%u"</span>)<span class="question-mark">?</span>, <span class="string">"2020-W01-1"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%F"</span>)<span class="question-mark">?</span>, <span class="string">"2019-12-30"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_sunday_based_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2620-2629">Source</a><h4 class="code-header">pub fn <a href="#method.set_sunday_based_week" class="fn">set_sunday_based_week</a>(
    &amp;mut self,
    week_number: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the Sunday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Sunday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_sunday_based_week(<span class="prelude-val">Some</span>(<span class="number">56</span>)).is_err());
tm.set_sunday_based_week(<span class="prelude-val">Some</span>(<span class="number">9</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%U"</span>)<span class="question-mark">?</span>, <span class="string">"09"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_monday_based_week" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2651-2660">Source</a><h4 class="code-header">pub fn <a href="#method.set_monday_based_week" class="fn">set_monday_based_week</a>(
    &amp;mut self,
    week_number: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the Monday based week number.</p>
<p>The week number returned is always in the range <code>0..=53</code>. Week <code>1</code>
begins on the first Monday of the year. Any days in the year prior to
week <code>1</code> are in week <code>0</code>.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_monday_based_week(<span class="prelude-val">Some</span>(<span class="number">56</span>)).is_err());
tm.set_monday_based_week(<span class="prelude-val">Some</span>(<span class="number">9</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%W"</span>)<span class="question-mark">?</span>, <span class="string">"09"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_hour" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2683-2689">Source</a><h4 class="code-header">pub fn <a href="#method.set_hour" class="fn">set_hour</a>(&amp;mut self, hour: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the hour on this broken down time.</p>
<h5 id="errors-18"><a class="doc-anchor" href="#errors-18">§</a>Errors</h5>
<p>This returns an error if the given hour is out of range.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">24</span>)).is_err());
tm.set_hour(<span class="prelude-val">Some</span>(<span class="number">0</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%H"</span>)<span class="question-mark">?</span>, <span class="string">"00"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%-H"</span>)<span class="question-mark">?</span>, <span class="string">"0"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_minute" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2713-2719">Source</a><h4 class="code-header">pub fn <a href="#method.set_minute" class="fn">set_minute</a>(&amp;mut self, minute: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the minute on this broken down time.</p>
<h5 id="errors-19"><a class="doc-anchor" href="#errors-19">§</a>Errors</h5>
<p>This returns an error if the given minute is out of range.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">60</span>)).is_err());
tm.set_minute(<span class="prelude-val">Some</span>(<span class="number">59</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%M"</span>)<span class="question-mark">?</span>, <span class="string">"59"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%03M"</span>)<span class="question-mark">?</span>, <span class="string">"059"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%_3M"</span>)<span class="question-mark">?</span>, <span class="string">" 59"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_second" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2745-2751">Source</a><h4 class="code-header">pub fn <a href="#method.set_second" class="fn">set_second</a>(&amp;mut self, second: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the second on this broken down time.</p>
<h5 id="errors-20"><a class="doc-anchor" href="#errors-20">§</a>Errors</h5>
<p>This returns an error if the given second is out of range.</p>
<p>Jiff does not support leap seconds, so the range of valid seconds is
<code>0</code> to <code>59</code>, inclusive. Note though that when parsing, a parsed value
of <code>60</code> is automatically constrained to <code>59</code>.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_second(<span class="prelude-val">Some</span>(<span class="number">60</span>)).is_err());
tm.set_second(<span class="prelude-val">Some</span>(<span class="number">59</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%S"</span>)<span class="question-mark">?</span>, <span class="string">"59"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_subsec_nanosecond" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2775-2787">Source</a><h4 class="code-header">pub fn <a href="#method.set_subsec_nanosecond" class="fn">set_subsec_nanosecond</a>(
    &amp;mut self,
    subsec_nanosecond: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Set the subsecond nanosecond on this broken down time.</p>
<h5 id="errors-21"><a class="doc-anchor" href="#errors-21">§</a>Errors</h5>
<p>This returns an error if the given number of nanoseconds is out of
range. It must be non-negative and less than 1 whole second.</p>
<h5 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::strtime::BrokenDownTime;

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
<span class="comment">// out of range
</span><span class="macro">assert!</span>(tm.set_subsec_nanosecond(<span class="prelude-val">Some</span>(<span class="number">1_000_000_000</span>)).is_err());
tm.set_subsec_nanosecond(<span class="prelude-val">Some</span>(<span class="number">123_000_000</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%f"</span>)<span class="question-mark">?</span>, <span class="string">"123"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%.6f"</span>)<span class="question-mark">?</span>, <span class="string">".123000"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_offset" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2844-2846">Source</a><h4 class="code-header">pub fn <a href="#method.set_offset" class="fn">set_offset</a>(&amp;mut self, offset: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the time zone offset on this broken down time.</p>
<p>This can be useful for setting the offset after parsing if the offset
is known from the context or from some out-of-band information.</p>
<p>Note that one can set any legal offset value, regardless of whether
it’s consistent with the IANA time zone identifier on this broken down
time (if it’s set). Similarly, setting the offset does not actually
change any other value in this broken down time.</p>
<h5 id="example-setting-the-offset-after-parsing"><a class="doc-anchor" href="#example-setting-the-offset-after-parsing">§</a>Example: setting the offset after parsing</h5>
<p>One use case for this routine is when parsing a datetime <em>without</em>
an offset, but where one wants to set an offset based on the context.
For example, while it’s usually not correct to assume a datetime is
in UTC, if you know it is, then you can parse it into a <a href="../../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>
like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz::Offset};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d at %H:%M:%S"</span>,
    <span class="string">"1970-01-01 at 01:00:00"</span>,
)<span class="question-mark">?</span>;
tm.set_offset(<span class="prelude-val">Some</span>(Offset::UTC));
<span class="comment">// Normally this would fail since the parse
// itself doesn't include an offset. It only
// works here because we explicitly set the
// offset after parsing.
</span><span class="macro">assert_eq!</span>(tm.to_timestamp()<span class="question-mark">?</span>.to_string(), <span class="string">"1970-01-01T01:00:00Z"</span>);
</code></pre></div>
<h5 id="example-setting-the-offset-is-not-smart"><a class="doc-anchor" href="#example-setting-the-offset-is-not-smart">§</a>Example: setting the offset is not “smart”</h5>
<p>This example shows how setting the offset on an existing broken down
time does not impact any other field, even if the result printed is
non-sensical:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime, tz};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">28</span>).at(<span class="number">14</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_offset(<span class="prelude-val">Some</span>(tz::offset(<span class="number">12</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in US/Eastern +12:00"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_iana_time_zone" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2913-2915">Source</a><h4 class="code-header">pub fn <a href="#method.set_iana_time_zone" class="fn">set_iana_time_zone</a>(&amp;mut self, id: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the IANA time zone identifier on this broken down time.</p>
<p>This can be useful for setting the time zone after parsing if the time
zone is known from the context or from some out-of-band information.</p>
<p>Note that one can set any string value, regardless of whether it’s
consistent with the offset on this broken down time (if it’s set).
Similarly, setting the IANA time zone identifier does not actually
change any other value in this broken down time.</p>
<h5 id="example-setting-the-iana-time-zone-identifier-after-parsing"><a class="doc-anchor" href="#example-setting-the-iana-time-zone-identifier-after-parsing">§</a>Example: setting the IANA time zone identifier after parsing</h5>
<p>One use case for this routine is when parsing a datetime <em>without</em> a
time zone, but where one wants to set a time zone based on the context.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::strtime::BrokenDownTime, tz::Offset};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(
    <span class="string">"%Y-%m-%d at %H:%M:%S"</span>,
    <span class="string">"1970-01-01 at 01:00:00"</span>,
)<span class="question-mark">?</span>;
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"US/Eastern"</span>)));
<span class="comment">// Normally this would fail since the parse
// itself doesn't include an offset or a time
// zone. It only works here because we
// explicitly set the time zone after parsing.
</span><span class="macro">assert_eq!</span>(
    tm.to_zoned()<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T01:00:00-05:00[US/Eastern]"</span>,
);
</code></pre></div>
<h5 id="example-setting-the-iana-time-zone-identifier-is-not-smart"><a class="doc-anchor" href="#example-setting-the-iana-time-zone-identifier-is-not-smart">§</a>Example: setting the IANA time zone identifier is not “smart”</h5>
<p>This example shows how setting the IANA time zone identifier on an
existing broken down time does not impact any other field, even if the
result printed is non-sensical:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime, tz};

<span class="kw">let </span>zdt = date(<span class="number">2024</span>, <span class="number">8</span>, <span class="number">28</span>).at(<span class="number">14</span>, <span class="number">56</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"US/Eastern"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"Australia/Tasmania"</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in Australia/Tasmania -04:00"</span>,
);

<span class="comment">// In fact, it's not even required that the string
// given be a valid IANA time zone identifier!
</span><span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::from(<span class="kw-2">&amp;</span>zdt);
tm.set_iana_time_zone(<span class="prelude-val">Some</span>(String::from(<span class="string">"Clearly/Invalid"</span>)));
<span class="macro">assert_eq!</span>(
    tm.to_string(<span class="string">"%Y-%m-%d at %H:%M:%S in %Q %:z"</span>)<span class="question-mark">?</span>,
    <span class="string">"2024-08-28 at 14:56:00 in Clearly/Invalid -04:00"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_weekday" class="method"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2956-2958">Source</a><h4 class="code-header">pub fn <a href="#method.set_weekday" class="fn">set_weekday</a>(&amp;mut self, weekday: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../civil/enum.Weekday.html" title="enum jiff::civil::Weekday">Weekday</a>&gt;)</h4></section></summary><div class="docblock"><p>Set the weekday on this broken down time.</p>
<h5 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Weekday, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::default();
tm.set_weekday(<span class="prelude-val">Some</span>(Weekday::Saturday));
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%A"</span>)<span class="question-mark">?</span>, <span class="string">"Saturday"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%a"</span>)<span class="question-mark">?</span>, <span class="string">"Sat"</span>);
<span class="macro">assert_eq!</span>(tm.to_string(<span class="string">"%^a"</span>)<span class="question-mark">?</span>, <span class="string">"SAT"</span>);
</code></pre></div>
<p>Note that one use case for this routine is to enable parsing of
weekdays in datetime, but skip checking that the weekday is valid for
the parsed date.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::strtime::BrokenDownTime};

<span class="kw">let </span><span class="kw-2">mut </span>tm = BrokenDownTime::parse(<span class="string">"%a, %F"</span>, <span class="string">"Wed, 2024-07-27"</span>)<span class="question-mark">?</span>;
<span class="comment">// 2024-07-27 was a Saturday, so asking for a date fails:
</span><span class="macro">assert!</span>(tm.to_date().is_err());
<span class="comment">// But we can remove the weekday from our broken down time:
</span>tm.set_weekday(<span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(tm.to_date()<span class="question-mark">?</span>, date(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">27</span>));
</code></pre></div>
<p>The advantage of this approach is that it still ensures the parsed
weekday is a valid weekday (for example, <code>Wat</code> will cause parsing to
fail), but doesn’t require it to be consistent with the date. This
is useful for interacting with systems that don’t do strict error
checking.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#867">Source</a><a href="#impl-Debug-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#867">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#867">Source</a><a href="#impl-Default-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#867">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2961-2978">Source</a><a href="#impl-From%3C%26Zoned%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2962-2977">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDate%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3008-3017">Source</a><a href="#impl-From%3CDate%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.Date.html" title="struct jiff::civil::Date">Date</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3009-3016">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(d: <a class="struct" href="../../civil/struct.Date.html" title="struct jiff::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2991-3006">Source</a><a href="#impl-From%3CDateTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2992-3005">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CISOWeekDate%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3019-3028">Source</a><a href="#impl-From%3CISOWeekDate%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate">ISOWeekDate</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3020-3027">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(wd: <a class="struct" href="../../civil/struct.ISOWeekDate.html" title="struct jiff::civil::ISOWeekDate">ISOWeekDate</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3030-3041">Source</a><a href="#impl-From%3CTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../civil/struct.Time.html" title="struct jiff::civil::Time">Time</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#3031-3040">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="../../civil/struct.Time.html" title="struct jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2980-2989">Source</a><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>&gt; for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/strtime/mod.rs.html#2981-2988">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(ts: <a class="struct" href="../../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-BrokenDownTime" class="impl"><a href="#impl-Freeze-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-RefUnwindSafe-for-BrokenDownTime" class="impl"><a href="#impl-RefUnwindSafe-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Send-for-BrokenDownTime" class="impl"><a href="#impl-Send-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Sync-for-BrokenDownTime" class="impl"><a href="#impl-Sync-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-Unpin-for-BrokenDownTime" class="impl"><a href="#impl-Unpin-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section><section id="impl-UnwindSafe-for-BrokenDownTime" class="impl"><a href="#impl-UnwindSafe-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>