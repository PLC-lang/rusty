<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A parser for Temporal datetimes."><title>DateTimeParser in jiff::fmt::temporal - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Date<wbr>Time<wbr>Parser</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.disambiguation" title="disambiguation">disambiguation</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.offset_conflict" title="offset_conflict">offset_conflict</a></li><li><a href="#method.parse_date" title="parse_date">parse_date</a></li><li><a href="#method.parse_datetime" title="parse_datetime">parse_datetime</a></li><li><a href="#method.parse_pieces" title="parse_pieces">parse_pieces</a></li><li><a href="#method.parse_time" title="parse_time">parse_time</a></li><li><a href="#method.parse_time_zone" title="parse_time_zone">parse_time_zone</a></li><li><a href="#method.parse_time_zone_with" title="parse_time_zone_with">parse_time_zone_with</a></li><li><a href="#method.parse_timestamp" title="parse_timestamp">parse_timestamp</a></li><li><a href="#method.parse_zoned" title="parse_zoned">parse_zoned</a></li><li><a href="#method.parse_zoned_with" title="parse_zoned_with">parse_zoned_with</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-DateTimeParser" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-DateTimeParser" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-DateTimeParser" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-DateTimeParser" title="Send">Send</a></li><li><a href="#impl-Sync-for-DateTimeParser" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-DateTimeParser" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-DateTimeParser" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In jiff::<wbr>fmt::<wbr>temporal</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">jiff</a>::<wbr><a href="../index.html">fmt</a>::<wbr><a href="index.html">temporal</a></div><h1>Struct <span class="struct">DateTimeParser</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/jiff/fmt/temporal/mod.rs.html#252-256">Source</a> </span></div><pre class="rust item-decl"><code>pub struct DateTimeParser { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A parser for Temporal datetimes.</p>
<p>This parser converts a machine (but also human) readable format of a
datetime to the various types found in Jiff: <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>, <a href="../../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>,
<a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a>, <a href="../../civil/struct.Date.html" title="struct jiff::civil::Date"><code>civil::Date</code></a> or <a href="../../civil/struct.Time.html" title="struct jiff::civil::Time"><code>civil::Time</code></a>. Note that all
of those types provide <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> implementations
that utilize the default configuration of this parser. However, this parser
can be configured to behave differently and can also parse directly from
a <code>&amp;[u8]</code>.</p>
<p>See the <a href="index.html" title="mod jiff::fmt::temporal"><code>fmt::temporal</code></a> module documentation for
more information on the specific format used.</p>
<h2 id="example"><a class="doc-anchor" href="#example">ยง</a>Example</h2>
<p>This example shows how to parse a <code>Zoned</code> datetime from a byte string.
(That is, <code>&amp;[u8]</code> and not a <code>&amp;str</code>.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="comment">// A parser can be created in a const context.
</span><span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>zdt = PARSER.parse_zoned(<span class="string">b"2024-06-15T07-04[America/New_York]"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.time_zone(), <span class="kw-2">&amp;</span>tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>);
</code></pre></div>
<p>Note that an ASCII space instead of the <code>T</code> separator is automatically
supported too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="comment">// A parser can be created in a const context.
</span><span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>zdt = PARSER.parse_zoned(<span class="string">b"2024-06-15 07-04[America/New_York]"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">15</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.time_zone(), <span class="kw-2">&amp;</span>tz::db().get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">ยง</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DateTimeParser" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#258-1113">Source</a><a href="#impl-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#261-267">Source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h4></section></summary><div class="docblock"><p>Create a new Temporal datetime parser with the default configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_conflict" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#423-428">Source</a><h4 class="code-header">pub const fn <a href="#method.offset_conflict" class="fn">offset_conflict</a>(self, strategy: <a class="enum" href="../../tz/enum.OffsetConflict.html" title="enum jiff::tz::OffsetConflict">OffsetConflict</a>) -&gt; <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h4></section></summary><div class="docblock"><p>Set the conflict resolution strategy for when an offset in a datetime
string is inconsistent with the time zone.</p>
<p>See the documentation on <a href="../../tz/enum.OffsetConflict.html" title="enum jiff::tz::OffsetConflict"><code>OffsetConflict</code></a> for more details about the
different strategies one can choose.</p>
<p>This only applies when parsing <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> values.</p>
<p>The default is <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a>, which results in an error
whenever parsing a datetime with an offset that is inconsistent with
the time zone.</p>
<h5 id="example-respecting-offsets-even-when-theyre-invalid"><a class="doc-anchor" href="#example-respecting-offsets-even-when-theyre-invalid">ยง</a>Example: respecting offsets even when theyโre invalid</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new()
    .offset_conflict(tz::OffsetConflict::AlwaysOffset);

<span class="kw">let </span>zdt = PARSER.parse_zoned(<span class="string">"2024-06-09T07:00-05[America/New_York]"</span>)<span class="question-mark">?</span>;
<span class="comment">// Notice that the time *and* offset have been corrected. The offset
// given was invalid for `America/New_York` at the given time, so
// it cannot be kept, but the instant returned is equivalent to
// `2024-06-09T07:00-05`. It is just adjusted automatically to be
// correct in the `America/New_York` time zone.
</span><span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">9</span>).at(<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">4</span>));
</code></pre></div>
<h5 id="example-all-offsets-are-invalid-for-gaps-in-civil-time-by-default"><a class="doc-anchor" href="#example-all-offsets-are-invalid-for-gaps-in-civil-time-by-default">ยง</a>Example: all offsets are invalid for gaps in civil time by default</h5>
<p>When parsing a datetime with an offset for a gap in civil time, the
offset is treated as invalid. This results in parsing failing. For
example, some parts of Indiana in the US didnโt start using daylight
saving time until 2006. If a datetime for 2006 were serialized before
the updated daylight saving time rules were known, then this parse
error will prevent you from silently changing the originally intended
time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="comment">// DST in Indiana/Vevay began at 2006-04-02T02:00 local time.
// The last time Indiana/Vevay observed DST was in 1972.
</span><span class="kw">let </span>result = PARSER.parse_zoned(
    <span class="string">"2006-04-02T02:30-05[America/Indiana/Vevay]"</span>,
);
<span class="macro">assert_eq!</span>(
    result.unwrap_err().to_string(),
    <span class="string">"parsing \"2006-04-02T02:30-05[America/Indiana/Vevay]\" failed: \
     datetime 2006-04-02T02:30:00 could not resolve to timestamp \
     since 'reject' conflict resolution was chosen, and because \
     datetime has offset -05, but the time zone America/Indiana/Vevay \
     for the given datetime falls in a gap \
     (between offsets -05 and -04), \
     and all offsets for a gap are regarded as invalid"</span>,
);</code></pre></div>
<p>If one doesnโt want an error here, then you can either prioritize the
instant in time by respecting the offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new()
    .offset_conflict(tz::OffsetConflict::AlwaysOffset);

<span class="kw">let </span>zdt = PARSER.parse_zoned(
    <span class="string">"2006-04-02T02:30-05[America/Indiana/Vevay]"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.to_string(),
    <span class="string">"2006-04-02T03:30:00-04:00[America/Indiana/Vevay]"</span>,
);
</code></pre></div>
<p>or you can force your own disambiguation rules, e.g., by taking the
earlier time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new()
    .disambiguation(tz::Disambiguation::Earlier)
    .offset_conflict(tz::OffsetConflict::AlwaysTimeZone);

<span class="kw">let </span>zdt = PARSER.parse_zoned(
    <span class="string">"2006-04-02T02:30-05[America/Indiana/Vevay]"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.to_string(),
    <span class="string">"2006-04-02T01:30:00-05:00[America/Indiana/Vevay]"</span>,
);
</code></pre></div>
<h5 id="example-a-z-never-results-in-an-offset-conflict"><a class="doc-anchor" href="#example-a-z-never-results-in-an-offset-conflict">ยง</a>Example: a <code>Z</code> never results in an offset conflict</h5>
<p><a href="https://datatracker.ietf.org/doc/rfc9557/">RFC 9557</a> specifies that <code>Z</code> indicates that the offset from UTC to
get local time is unknown. Since it doesnโt prescribe a particular
offset, when a <code>Z</code> is parsed with a time zone annotation, the
<code>OffsetConflict::ALwaysOffset</code> strategy is used regardless of what
is set here. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::temporal::DateTimeParser;

<span class="comment">// NOTE: The default is reject.
</span><span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>zdt = PARSER.parse_zoned(
    <span class="string">"2025-06-20T17:30Z[America/New_York]"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    zdt.to_string(),
    <span class="string">"2025-06-20T13:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>Conversely, if the <code>+00:00</code> offset was used, then an error would
occur because of the offset conflict:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::temporal::DateTimeParser;

<span class="comment">// NOTE: The default is reject.
</span><span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>result = PARSER.parse_zoned(
    <span class="string">"2025-06-20T17:30+00[America/New_York]"</span>,
);
<span class="macro">assert_eq!</span>(
    result.unwrap_err().to_string(),
    <span class="string">"parsing \"2025-06-20T17:30+00[America/New_York]\" failed: \
     datetime 2025-06-20T17:30:00 could not resolve to a timestamp \
     since 'reject' conflict resolution was chosen, and because \
     datetime has offset +00, but the time zone America/New_York \
     for the given datetime unambiguously has offset -04"</span>,
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.disambiguation" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#504-509">Source</a><h4 class="code-header">pub const fn <a href="#method.disambiguation" class="fn">disambiguation</a>(self, strategy: <a class="enum" href="../../tz/enum.Disambiguation.html" title="enum jiff::tz::Disambiguation">Disambiguation</a>) -&gt; <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h4></section></summary><div class="docblock"><p>Set the disambiguation strategy for when a datetime falls into a time
zone transition โfoldโ or โgap.โ</p>
<p>The most common manifestation of such time zone transitions is daylight
saving time. In most cases, the transition into daylight saving time
moves the civil time (โthe time you see on the clockโ) ahead one hour.
This is called a โgapโ because an hour on the clock is skipped. While
the transition out of daylight saving time moves the civil time back
one hour. This is called a โfoldโ because an hour on the clock is
repeated.</p>
<p>In the case of a gap, an ambiguous datetime manifests as a time that
never appears on a clock. (For example, <code>02:30</code> on <code>2024-03-10</code> in New
York.) In the case of a fold, an ambiguous datetime manifests as a
time that repeats itself. (For example, <code>01:30</code> on <code>2024-11-03</code> in New
York.) So when a fold occurs, you donโt know whether itโs the โfirstโ
occurrence of that time or the โsecond.โ</p>
<p>Time zone transitions are not just limited to daylight saving time,
although those are the most common. In other cases, a transition occurs
because of a change in the offset of the time zone itself. (See the
examples below.)</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">ยง</a>Example</h5>
<p>This example shows how to set the disambiguation configuration while
parsing a <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> datetime. In this example, we always prefer the
earlier time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new()
    .disambiguation(tz::Disambiguation::Earlier);

<span class="kw">let </span>zdt = PARSER.parse_zoned(<span class="string">"2024-03-10T02:05[America/New_York]"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">5</span>));
</code></pre></div>
<h5 id="example-time-zone-offset-change"><a class="doc-anchor" href="#example-time-zone-offset-change">ยง</a>Example: time zone offset change</h5>
<p>In this example, we explore a time zone offset change in Hawaii that
occurred on <code>1947-06-08</code>. Namely, Hawaii went from a <code>-10:30</code> offset
to a <code>-10:00</code> offset at <code>02:00</code>. This results in a 30 minute gap in
civil time.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz, ToSpan};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new()
    .disambiguation(tz::Disambiguation::Later);

<span class="comment">// 02:05 didn't exist on clocks on 1947-06-08.
</span><span class="kw">let </span>zdt = PARSER.parse_zoned(
    <span class="string">"1947-06-08T02:05[Pacific/Honolulu]"</span>,
)<span class="question-mark">?</span>;
<span class="comment">// Our parser is configured to select the later time, so we jump to
// 02:35. But if we used `Disambiguation::Earlier`, then we'd get
// 01:35.
</span><span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">1947</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">2</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">10</span>));

<span class="comment">// If we subtract 10 minutes from 02:35, notice that we (correctly)
// jump to 01:55 *and* our offset is corrected to -10:30.
</span><span class="kw">let </span>zdt = zdt.checked_sub(<span class="number">10</span>.minutes())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">1947</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">1</span>, <span class="number">55</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">10</span>).saturating_sub(<span class="number">30</span>.minutes()));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_zoned" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#577-582">Source</a><h4 class="code-header">pub fn <a href="#method.parse_zoned" class="fn">parse_zoned</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, input: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a datetime string with a time zone annotation into a <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>
value using the system time zone database.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">ยง</a>Errors</h5>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesnโt fit in the datetime range supported by Jiff.</p>
<p>The <a href="struct.DateTimeParser.html#method.offset_conflict" title="method jiff::fmt::temporal::DateTimeParser::offset_conflict"><code>DateTimeParser::offset_conflict</code></a> and
<a href="struct.DateTimeParser.html#method.disambiguation" title="method jiff::fmt::temporal::DateTimeParser::disambiguation"><code>DateTimeParser::disambiguation</code></a> settings can also influence
whether an error occurs or not. Namely, if <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a>
is used (which is the default), then an error occurs when there
is an inconsistency between the offset and the time zone. And if
<a href="../../tz/enum.Disambiguation.html#variant.Reject" title="variant jiff::tz::Disambiguation::Reject"><code>Disambiguation::Reject</code></a> is used, then an error occurs when the civil
time in the string is ambiguous.</p>
<h5 id="example-parsing-without-an-iana-time-zone"><a class="doc-anchor" href="#example-parsing-without-an-iana-time-zone">ยง</a>Example: parsing without an IANA time zone</h5>
<p>Note that when parsing a <code>Zoned</code> value, it is required for the datetime
string to contain a time zone annotation in brackets. For example,
this fails to parse even though it refers to a precise instant in time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::temporal::DateTimeParser;

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert!</span>(PARSER.parse_zoned(<span class="string">"2024-06-08T07:00-04"</span>).is_err());</code></pre></div>
<p>While it is better to include a time zone name, if the only thing
thatโs available is an offset, the offset can be repeated as a time
zone annotation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>zdt = PARSER.parse_zoned(<span class="string">"2024-06-08T07:00-04[-04]"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">4</span>));
</code></pre></div>
<p>Otherwise, if you need to be able to parse something like
<code>2024-06-08T07:00-04</code> as-is, you should parse it into an <a href="../../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser, tz};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>timestamp = PARSER.parse_timestamp(<span class="string">"2024-06-08T07:00-04"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = timestamp.to_zoned(tz::TimeZone::UTC);
<span class="macro">assert_eq!</span>(zdt.datetime(), date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">8</span>).at(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(<span class="number">0</span>));
</code></pre></div>
<p>If you <em>really</em> need to parse something like <code>2024-06-08T07:00-04</code>
into a <code>Zoned</code> with a fixed offset of <code>-04:00</code> as its <code>TimeZone</code>,
then youโll need to use lower level parsing routines. See the
documentation on <a href="struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces"><code>Pieces</code></a> for a case study of how to achieve this.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_zoned_with" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#651-662">Source</a><h4 class="code-header">pub fn <a href="#method.parse_zoned_with" class="fn">parse_zoned_with</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    db: &amp;<a class="struct" href="../../tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase">TimeZoneDatabase</a>,
    input: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a datetime string with a time zone annotation into a <a href="../../struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>
value using the time zone database given.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">ยง</a>Errors</h5>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesnโt fit in the datetime range supported by Jiff.</p>
<p>The <a href="struct.DateTimeParser.html#method.offset_conflict" title="method jiff::fmt::temporal::DateTimeParser::offset_conflict"><code>DateTimeParser::offset_conflict</code></a> and
<a href="struct.DateTimeParser.html#method.disambiguation" title="method jiff::fmt::temporal::DateTimeParser::disambiguation"><code>DateTimeParser::disambiguation</code></a> settings can also influence
whether an error occurs or not. Namely, if <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a>
is used (which is the default), then an error occurs when there
is an inconsistency between the offset and the time zone. And if
<a href="../../tz/enum.Disambiguation.html#variant.Reject" title="variant jiff::tz::Disambiguation::Reject"><code>Disambiguation::Reject</code></a> is used, then an error occurs when the civil
time in the string is ambiguous.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">ยง</a>Example</h5>
<p>This example demonstrates the utility of this routine by parsing a
datetime using an older copy of the IANA Time Zone Database. This
example leverages the fact that the 2018 copy of <code>tzdb</code> preceded
Brazilโs announcement that daylight saving time would be abolished.
This meant that datetimes in the future, when parsed with the older
copy of <code>tzdb</code>, would still follow the old daylight saving time rules.
But a mere update of <code>tzdb</code> would otherwise change the meaning of the
datetime.</p>
<p>This scenario can come up if one stores datetimes in the future.
This is also why the default offset conflict resolution strategy
is <a href="../../tz/enum.OffsetConflict.html#variant.Reject" title="variant jiff::tz::OffsetConflict::Reject"><code>OffsetConflict::Reject</code></a>, which prevents one from silently
re-interpreting datetimes to a different timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz::{<span class="self">self</span>, TimeZoneDatabase}};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="comment">// Open a version of tzdb from before Brazil announced its abolition
// of daylight saving time.
</span><span class="kw">let </span>tzdb2018 = TimeZoneDatabase::from_dir(<span class="string">"path/to/tzdb-2018b"</span>)<span class="question-mark">?</span>;
<span class="comment">// Open the system tzdb.
</span><span class="kw">let </span>tzdb = tz::db();

<span class="comment">// Parse the same datetime string with the same parser, but using two
// different versions of tzdb.
</span><span class="kw">let </span>dt = <span class="string">"2020-01-15T12:00[America/Sao_Paulo]"</span>;
<span class="kw">let </span>zdt2018 = PARSER.parse_zoned_with(<span class="kw-2">&amp;</span>tzdb2018, dt)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = PARSER.parse_zoned_with(tzdb, dt)<span class="question-mark">?</span>;

<span class="comment">// Before DST was abolished, 2020-01-15 was in DST, which corresponded
// to UTC offset -02. Since DST rules applied to datetimes in the
// future, the 2018 version of tzdb would lead one to interpret
// 2020-01-15 as being in DST.
</span><span class="macro">assert_eq!</span>(zdt2018.offset(), tz::offset(-<span class="number">2</span>));
<span class="comment">// But DST was abolished in 2019, which means that 2020-01-15 was no
// no longer in DST. So after a tzdb update, the same datetime as above
// now has a different offset.
</span><span class="macro">assert_eq!</span>(zdt.offset(), tz::offset(-<span class="number">3</span>));

<span class="comment">// So if you try to parse a datetime serialized from an older copy of
// tzdb, you'll get an error under the default configuration because
// of `OffsetConflict::Reject`. This would succeed if you parsed it
// using tzdb2018!
</span><span class="macro">assert!</span>(PARSER.parse_zoned_with(tzdb, zdt2018.to_string()).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_timestamp" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#706-715">Source</a><h4 class="code-header">pub fn <a href="#method.parse_timestamp" class="fn">parse_timestamp</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    input: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a datetime string into a <a href="../../struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a>.</p>
<p>The datetime string must correspond to a specific instant in time. This
requires an offset in the datetime string.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">ยง</a>Errors</h5>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesnโt fit in the datetime range supported by Jiff.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">ยง</a>Example</h5>
<p>This shows a basic example of parsing an <code>Timestamp</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::temporal::DateTimeParser;

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>timestamp = PARSER.parse_timestamp(<span class="string">"2024-03-10T02:05-04"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(timestamp.to_string(), <span class="string">"2024-03-10T06:05:00Z"</span>);
</code></pre></div>
<h5 id="example-parsing-a-timestamp-from-a-datetime-with-a-time-zone"><a class="doc-anchor" href="#example-parsing-a-timestamp-from-a-datetime-with-a-time-zone">ยง</a>Example: parsing a timestamp from a datetime with a time zone</h5>
<p>A timestamp can also be parsed fron a time zone aware datetime string.
The time zone is ignored and the offset is always used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::fmt::temporal::DateTimeParser;

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>timestamp = PARSER.parse_timestamp(
    <span class="string">"2024-03-10T02:05-04[America/New_York]"</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(timestamp.to_string(), <span class="string">"2024-03-10T06:05:00Z"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_datetime" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#765-774">Source</a><h4 class="code-header">pub fn <a href="#method.parse_datetime" class="fn">parse_datetime</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    input: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime">DateTime</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a civil datetime string into a <a href="../../civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a>.</p>
<p>A civil datetime can be parsed from anything that contains a datetime.
For example, a time zone aware string.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">ยง</a>Errors</h5>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesnโt fit in the datetime range supported by Jiff.</p>
<p>This also returns an error if a <code>Z</code> (Zulu) offset is found, since
interpreting such strings as civil time is usually a bug.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">ยง</a>Example</h5>
<p>This shows a basic example of parsing a <code>civil::DateTime</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>datetime = PARSER.parse_datetime(<span class="string">"2024-03-10T02:05"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(datetime, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-parsing-fails-if-a-z-zulu-offset-is-encountered"><a class="doc-anchor" href="#example-parsing-fails-if-a-z-zulu-offset-is-encountered">ยง</a>Example: parsing fails if a <code>Z</code> (Zulu) offset is encountered</h5>
<p>Because parsing a datetime with a <code>Z</code> offset and interpreting it as
a civil time is usually a bug, it is forbidden:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert!</span>(PARSER.parse_datetime(<span class="string">"2024-03-10T02:05Z"</span>).is_err());

<span class="comment">// Note though that -00 and +00 offsets parse successfully.
</span><span class="kw">let </span>datetime = PARSER.parse_datetime(<span class="string">"2024-03-10T02:05+00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(datetime, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="kw">let </span>datetime = PARSER.parse_datetime(<span class="string">"2024-03-10T02:05-00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(datetime, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>).at(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_date" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#824-833">Source</a><h4 class="code-header">pub fn <a href="#method.parse_date" class="fn">parse_date</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, input: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Date.html" title="struct jiff::civil::Date">Date</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a civil date string into a <a href="../../civil/struct.Date.html" title="struct jiff::civil::Date"><code>civil::Date</code></a>.</p>
<p>A civil date can be parsed from anything that contains a date. For
example, a time zone aware string.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">ยง</a>Errors</h5>
<p>This returns an error if the date string given is invalid or if it
is valid but doesnโt fit in the date range supported by Jiff.</p>
<p>This also returns an error if a <code>Z</code> (Zulu) offset is found, since
interpreting such strings as civil date or time is usually a bug.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">ยง</a>Example</h5>
<p>This shows a basic example of parsing a <code>civil::Date</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>d = PARSER.parse_date(<span class="string">"2024-03-10"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(d, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>));
</code></pre></div>
<h5 id="example-parsing-fails-if-a-z-zulu-offset-is-encountered-1"><a class="doc-anchor" href="#example-parsing-fails-if-a-z-zulu-offset-is-encountered-1">ยง</a>Example: parsing fails if a <code>Z</code> (Zulu) offset is encountered</h5>
<p>Because parsing a date with a <code>Z</code> offset and interpreting it as
a civil date or time is usually a bug, it is forbidden:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert!</span>(PARSER.parse_date(<span class="string">"2024-03-10T00:00:00Z"</span>).is_err());

<span class="comment">// Note though that -00 and +00 offsets parse successfully.
</span><span class="kw">let </span>d = PARSER.parse_date(<span class="string">"2024-03-10T00:00:00+00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(d, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>));
<span class="kw">let </span>d = PARSER.parse_date(<span class="string">"2024-03-10T00:00:00-00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(d, date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_time" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#883-892">Source</a><h4 class="code-header">pub fn <a href="#method.parse_time" class="fn">parse_time</a>&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, input: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../civil/struct.Time.html" title="struct jiff::civil::Time">Time</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a civil time string into a <a href="../../civil/struct.Time.html" title="struct jiff::civil::Time"><code>civil::Time</code></a>.</p>
<p>A civil time can be parsed from anything that contains a time.
For example, a time zone aware string.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">ยง</a>Errors</h5>
<p>This returns an error if the time string given is invalid or if it
is valid but doesnโt fit in the time range supported by Jiff.</p>
<p>This also returns an error if a <code>Z</code> (Zulu) offset is found, since
interpreting such strings as civil time is usually a bug.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">ยง</a>Example</h5>
<p>This shows a basic example of parsing a <code>civil::Time</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>t = PARSER.parse_time(<span class="string">"02:05"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-parsing-fails-if-a-z-zulu-offset-is-encountered-2"><a class="doc-anchor" href="#example-parsing-fails-if-a-z-zulu-offset-is-encountered-2">ยง</a>Example: parsing fails if a <code>Z</code> (Zulu) offset is encountered</h5>
<p>Because parsing a time with a <code>Z</code> offset and interpreting it as
a civil time is usually a bug, it is forbidden:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert!</span>(PARSER.parse_time(<span class="string">"02:05Z"</span>).is_err());

<span class="comment">// Note though that -00 and +00 offsets parse successfully.
</span><span class="kw">let </span>t = PARSER.parse_time(<span class="string">"02:05+00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="kw">let </span>t = PARSER.parse_time(<span class="string">"02:05-00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_time_zone" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#941-946">Source</a><h4 class="code-header">pub fn <a href="#method.parse_time_zone" class="fn">parse_time_zone</a>&lt;'i, I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    input: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone">TimeZone</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a string representing a time zone into a <a href="../../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a>.</p>
<p>This will parse one of three different categories of strings:</p>
<ol>
<li>An IANA Time Zone Database identifier. For example,
<code>America/New_York</code> or <code>UTC</code>.</li>
<li>A fixed offset. For example, <code>-05:00</code> or <code>-00:44:30</code>.</li>
<li>A POSIX time zone string. For example, <code>EST5EDT,M3.2.0,M11.1.0</code>.</li>
</ol>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">ยง</a>Example</h5>
<p>This shows a few examples of parsing different kinds of time zones:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz::{<span class="self">self</span>, TimeZone}};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone(<span class="string">"-05:00"</span>)<span class="question-mark">?</span>,
    TimeZone::fixed(tz::offset(-<span class="number">5</span>)),
);
<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone(<span class="string">"+05:00:01"</span>)<span class="question-mark">?</span>,
    TimeZone::fixed(tz::Offset::from_seconds(<span class="number">5 </span>* <span class="number">60 </span>* <span class="number">60 </span>+ <span class="number">1</span>).unwrap()),
);
<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
    TimeZone::get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone(<span class="string">"Israel"</span>)<span class="question-mark">?</span>,
    TimeZone::get(<span class="string">"Israel"</span>)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone(<span class="string">"EST5EDT,M3.2.0,M11.1.0"</span>)<span class="question-mark">?</span>,
    TimeZone::posix(<span class="string">"EST5EDT,M3.2.0,M11.1.0"</span>)<span class="question-mark">?</span>,
);

<span class="comment">// Some error cases!
</span><span class="macro">assert!</span>(PARSER.parse_time_zone(<span class="string">"Z"</span>).is_err());
<span class="macro">assert!</span>(PARSER.parse_time_zone(<span class="string">"05:00"</span>).is_err());
<span class="macro">assert!</span>(PARSER.parse_time_zone(<span class="string">"+05:00:01.5"</span>).is_err());
<span class="macro">assert!</span>(PARSER.parse_time_zone(<span class="string">"Does/Not/Exist"</span>).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_time_zone_with" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#981-989">Source</a><h4 class="code-header">pub fn <a href="#method.parse_time_zone_with" class="fn">parse_time_zone_with</a>&lt;'i, I: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    db: &amp;<a class="struct" href="../../tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase">TimeZoneDatabase</a>,
    input: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone">TimeZone</a>, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a string representing a time zone into a <a href="../../tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a> and
performs any time zone database lookups using the <a href="../../tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase"><code>TimeZoneDatabase</code></a>
given.</p>
<p>This is like <a href="struct.DateTimeParser.html#method.parse_time_zone" title="method jiff::fmt::temporal::DateTimeParser::parse_time_zone"><code>DateTimeParser::parse_time_zone</code></a>, but uses the time
zone database given instead of the implicit global time zone database.</p>
<p>This will parse one of three different categories of strings:</p>
<ol>
<li>An IANA Time Zone Database identifier. For example,
<code>America/New_York</code> or <code>UTC</code>.</li>
<li>A fixed offset. For example, <code>-05:00</code> or <code>-00:44:30</code>.</li>
<li>A POSIX time zone string. For example, <code>EST5EDT,M3.2.0,M11.1.0</code>.</li>
</ol>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">ยง</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz::{<span class="self">self</span>, TimeZone}};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>db = jiff::tz::db();
<span class="macro">assert_eq!</span>(
    PARSER.parse_time_zone_with(db, <span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
    TimeZone::get(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>See also the example for <a href="struct.DateTimeParser.html#method.parse_zoned_with" title="method jiff::fmt::temporal::DateTimeParser::parse_zoned_with"><code>DateTimeParser::parse_zoned_with</code></a> for a
more interesting example using a time zone database other than the
default.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_pieces" class="method"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#1104-1112">Source</a><h4 class="code-header">pub fn <a href="#method.parse_pieces" class="fn">parse_pieces</a>&lt;'i, I: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt; + 'i&gt;(
    &amp;self,
    input: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;'i I</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces">Pieces</a>&lt;'i&gt;, <a class="struct" href="../../struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a Temporal datetime string into <a href="struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces"><code>Pieces</code></a>.</p>
<p>This is a lower level routine meant to give callers raw access to the
individual โpiecesโ of a parsed Temporal ISO 8601 datetime string.
Note that this only includes strings that have a date component.</p>
<p>The benefit of this routine is that it only checks that the datetime
is itself valid. It doesnโt do any automatic diambiguation, offset
conflict resolution or attempt to prevent you from shooting yourself
in the foot. For example, this routine will let you parse a fixed
offset datetime into a <code>Zoned</code> without a time zone abbreviation.</p>
<p>Note that when using this routine, the
<a href="struct.DateTimeParser.html#method.offset_conflict" title="method jiff::fmt::temporal::DateTimeParser::offset_conflict"><code>DateTimeParser::offset_conflict</code></a> and
<a href="struct.DateTimeParser.html#method.disambiguation" title="method jiff::fmt::temporal::DateTimeParser::disambiguation"><code>DateTimeParser::disambiguation</code></a> configuration knobs are completely
ignored. This is because with the lower level <code>Pieces</code>, callers must
handle offset conflict resolution (if they want it) themselves. See
the <a href="struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces"><code>Pieces</code></a> documentation for a case study on how to do this if
you need it.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">ยง</a>Errors</h5>
<p>This returns an error if the datetime string given is invalid or if it
is valid but doesnโt fit in the date range supported by Jiff.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">ยง</a>Example</h5>
<p>This shows how to parse a fixed offset timestamp into a <code>Zoned</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{fmt::temporal::DateTimeParser, tz::TimeZone};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>timestamp = <span class="string">"2025-01-02T15:13-05"</span>;

<span class="comment">// Normally this operation will fail.
</span><span class="macro">assert_eq!</span>(
    PARSER.parse_zoned(timestamp).unwrap_err().to_string(),
    <span class="string">"failed to find time zone in square brackets in \
     \"2025-01-02T15:13-05\", which is required for \
     parsing a zoned instant"</span>,
);

<span class="comment">// But you can work-around this with `Pieces`, which gives you direct
// access to the components parsed from the string.
</span><span class="kw">let </span>pieces = PARSER.parse_pieces(timestamp)<span class="question-mark">?</span>;
<span class="kw">let </span>time = pieces.time().unwrap_or_else(jiff::civil::Time::midnight);
<span class="kw">let </span>dt = pieces.date().to_datetime(time);
<span class="kw">let </span>tz = <span class="kw">match </span>pieces.to_time_zone()<span class="question-mark">? </span>{
    <span class="prelude-val">Some</span>(tz) =&gt; tz,
    <span class="prelude-val">None </span>=&gt; {
        <span class="kw">let </span><span class="prelude-val">Some</span>(offset) = pieces.to_numeric_offset() <span class="kw">else </span>{
            <span class="kw">let </span>msg = <span class="macro">format!</span>(
                <span class="string">"timestamp `{timestamp}` has no time zone \
                 or offset, and thus cannot be parsed into \
                 an instant"</span>,
            );
            <span class="kw">return </span><span class="prelude-val">Err</span>(msg.into());
        };
        TimeZone::fixed(offset)
    }
};
<span class="comment">// We don't bother with offset conflict resolution. And note that
// this uses automatic "compatible" disambiguation in the case of
// discontinuities. Of course, this is all moot if `TimeZone` is
// fixed. The above code handles the case where it isn't!
</span><span class="kw">let </span>zdt = tz.to_zoned(dt)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"2025-01-02T15:13:00-05:00[-05:00]"</span>);
</code></pre></div>
<h5 id="example-work-around-errors-when-a-z-zulu-offset-is-encountered"><a class="doc-anchor" href="#example-work-around-errors-when-a-z-zulu-offset-is-encountered">ยง</a>Example: work around errors when a <code>Z</code> (Zulu) offset is encountered</h5>
<p>Because parsing a date with a <code>Z</code> offset and interpreting it as
a civil date or time is usually a bug, it is forbidden:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, fmt::temporal::DateTimeParser};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="macro">assert_eq!</span>(
    PARSER.parse_date(<span class="string">"2024-03-10T00:00:00Z"</span>).unwrap_err().to_string(),
    <span class="string">"cannot parse civil date from string with a Zulu offset, \
     parse as a `Timestamp` and convert to a civil date instead"</span>,
);
</code></pre></div>
<p>But this sort of error checking doesnโt happen when you parse into a
<a href="struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces"><code>Pieces</code></a>. You just get what was parsed, which lets you extract a
date even if the higher level APIs forbid it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, fmt::temporal::DateTimeParser, tz::Offset};

<span class="kw">static </span>PARSER: DateTimeParser = DateTimeParser::new();

<span class="kw">let </span>pieces = PARSER.parse_pieces(<span class="string">"2024-03-10T00:00:00Z"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(pieces.date(), civil::date(<span class="number">2024</span>, <span class="number">3</span>, <span class="number">10</span>));
<span class="macro">assert_eq!</span>(pieces.time(), <span class="prelude-val">Some</span>(civil::time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));
<span class="macro">assert_eq!</span>(pieces.to_numeric_offset(), <span class="prelude-val">Some</span>(Offset::UTC));
<span class="macro">assert_eq!</span>(pieces.to_time_zone()<span class="question-mark">?</span>, <span class="prelude-val">None</span>);
</code></pre></div>
<p>This is usually not the right thing to do. It isnโt even suggested in
the error message above. But if you know itโs the right thing, then
<code>Pieces</code> will let you do it.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">ยง</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-DateTimeParser" class="impl"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#251">Source</a><a href="#impl-Debug-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/jiff/fmt/temporal/mod.rs.html#251">Source</a><a href="#method.fmt" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">ยง</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-DateTimeParser" class="impl"><a href="#impl-Freeze-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section><section id="impl-RefUnwindSafe-for-DateTimeParser" class="impl"><a href="#impl-RefUnwindSafe-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section><section id="impl-Send-for-DateTimeParser" class="impl"><a href="#impl-Send-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section><section id="impl-Sync-for-DateTimeParser" class="impl"><a href="#impl-Sync-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section><section id="impl-Unpin-for-DateTimeParser" class="impl"><a href="#impl-Unpin-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section><section id="impl-UnwindSafe-for-DateTimeParser" class="impl"><a href="#impl-UnwindSafe-for-DateTimeParser" class="anchor">ยง</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.DateTimeParser.html" title="struct jiff::fmt::temporal::DateTimeParser">DateTimeParser</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">ยง</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>