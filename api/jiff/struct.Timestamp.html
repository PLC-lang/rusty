<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An instant in time represented as the number of nanoseconds since the Unix epoch."><title>Timestamp in jiff - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="jiff" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../jiff/index.html">jiff</a><span class="version">0.2.15</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Timestamp</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#default-value" title="Default value">Default value</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding-timestamps" title="Rounding timestamps">Rounding timestamps</a></li><li><a href="#an-instant-in-time" title="An instant in time">An instant in time</a></li><li><a href="#converting-a-civil-datetime-to-a-timestamp" title="Converting a civil datetime to a timestamp">Converting a civil datetime to a timestamp</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.UNIX_EPOCH" title="UNIX_EPOCH">UNIX_EPOCH</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.as_duration" title="as_duration">as_duration</a></li><li><a href="#method.as_microsecond" title="as_microsecond">as_microsecond</a></li><li><a href="#method.as_millisecond" title="as_millisecond">as_millisecond</a></li><li><a href="#method.as_nanosecond" title="as_nanosecond">as_nanosecond</a></li><li><a href="#method.as_second" title="as_second">as_second</a></li><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.constant" title="constant">constant</a></li><li><a href="#method.display_with_offset" title="display_with_offset">display_with_offset</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.from_duration" title="from_duration">from_duration</a></li><li><a href="#method.from_microsecond" title="from_microsecond">from_microsecond</a></li><li><a href="#method.from_millisecond" title="from_millisecond">from_millisecond</a></li><li><a href="#method.from_nanosecond" title="from_nanosecond">from_nanosecond</a></li><li><a href="#method.from_second" title="from_second">from_second</a></li><li><a href="#method.in_tz" title="in_tz">in_tz</a></li><li><a href="#method.is_zero" title="is_zero">is_zero</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.now" title="now">now</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.series" title="series">series</a></li><li><a href="#method.signum" title="signum">signum</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_microsecond" title="subsec_microsecond">subsec_microsecond</a></li><li><a href="#method.subsec_millisecond" title="subsec_millisecond">subsec_millisecond</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.to_zoned" title="to_zoned">to_zoned</a></li><li><a href="#method.until" title="until">until</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-Timestamp" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-Timestamp" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Timestamp" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-Timestamp" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-Timestamp" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Timestamp" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Timestamp" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Timestamp" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Timestamp" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Timestamp" title="Default">Default</a></li><li><a href="#impl-Display-for-Timestamp" title="Display">Display</a></li><li><a href="#impl-Eq-for-Timestamp" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Timestamp" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-Pieces%3C'static%3E" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-SystemTime" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li><li><a href="#impl-From%3CTimestamp%3E-for-TimestampDifference" title="From&#60;Timestamp&#62;">From&#60;Timestamp&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Timestamp" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromStr-for-Timestamp" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-Timestamp" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-Timestamp" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-Timestamp" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-Timestamp" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-Sub-for-Timestamp" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-Timestamp" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-Timestamp" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Timestamp" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-Timestamp" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-Timestamp" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Timestamp" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li><li><a href="#impl-TryFrom%3CSystemTime%3E-for-Timestamp" title="TryFrom&#60;SystemTime&#62;">TryFrom&#60;SystemTime&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Timestamp" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Timestamp" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Timestamp" title="Send">Send</a></li><li><a href="#impl-Sync-for-Timestamp" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Timestamp" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Timestamp" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate jiff</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">jiff</a></div><h1>Struct <span class="struct">Timestamp</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/jiff/timestamp.rs.html#318-321">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Timestamp { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An instant in time represented as the number of nanoseconds since the Unix
epoch.</p>
<p>A timestamp is always in the Unix timescale with a UTC offset of zero.</p>
<p>To obtain civil or “local” datetime units like year, month, day or hour, a
timestamp needs to be combined with a <a href="tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a> to create a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a>.
That can be done with <a href="struct.Timestamp.html#method.in_tz" title="method jiff::Timestamp::in_tz"><code>Timestamp::in_tz</code></a> or <a href="struct.Timestamp.html#method.to_zoned" title="method jiff::Timestamp::to_zoned"><code>Timestamp::to_zoned</code></a>.</p>
<p>The integer count of nanoseconds since the Unix epoch is signed, where
the Unix epoch is <code>1970-01-01 00:00:00Z</code>. A positive timestamp indicates
a point in time after the Unix epoch. A negative timestamp indicates a
point in time before the Unix epoch.</p>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Timestamp</code> type provides convenient trait implementations of
<a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19 15:22:45-04"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-06-19T19:22:45Z"</span>);
</code></pre></div>
<p>A <code>Timestamp</code> can also be parsed from something that <em>contains</em> a
timestamp, but with perhaps other data (such as a time zone):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19T15:22:45-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-06-19T19:22:45Z"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="fmt/temporal/index.html" title="mod jiff::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="default-value"><a class="doc-anchor" href="#default-value">§</a>Default value</h2>
<p>For convenience, this type implements the <code>Default</code> trait. Its default
value corresponds to <code>1970-01-01T00:00:00.000000000</code>. That is, it is the
Unix epoch. One can also access this value via the <code>Timestamp::UNIX_EPOCH</code>
constant.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a timestamp with a second
component of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts: Timestamp = <span class="string">"2016-12-31 23:59:60Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2016-12-31T23:59:59Z"</span>);
</code></pre></div>
<h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>Timestamp</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations
to facilitate easy comparisons. When a timestamp <code>ts1</code> occurs before a
timestamp <code>ts2</code>, then <code>dt1 &lt; dt2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts1 = Timestamp::from_second(<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>ts2 = Timestamp::from_second(<span class="number">123_456_790</span>)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(ts1 &lt; ts2);
</code></pre></div>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>Timestamp</code> values.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a> or <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a> for checked
arithmetic.</li>
<li><a href="struct.Timestamp.html#method.saturating_add" title="method jiff::Timestamp::saturating_add"><code>Timestamp::saturating_add</code></a> or <a href="struct.Timestamp.html#method.saturating_sub" title="method jiff::Timestamp::saturating_sub"><code>Timestamp::saturating_sub</code></a> for
saturating arithmetic.</li>
</ul>
<p>Additionally, checked arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations. When the result overflows, a panic occurs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"2024-02-25T15:45Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2 = ts1 - <span class="number">24</span>.hours();
<span class="macro">assert_eq!</span>(ts2.to_string(), <span class="string">"2024-02-24T15:45:00Z"</span>);
</code></pre></div>
<p>One can compute the span of time between two timestamps using either
<a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a> or <a href="struct.Timestamp.html#method.since" title="method jiff::Timestamp::since"><code>Timestamp::since</code></a>. It’s also possible to
subtract two <code>Timestamp</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"2024-05-03 23:30:00.123Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2024-02-25 07Z"</span>.parse()<span class="question-mark">?</span>;
<span class="comment">// The default is to return spans with units no bigger than seconds.
</span><span class="macro">assert_eq!</span>(ts1 - ts2, <span class="number">5934600</span>.seconds().milliseconds(<span class="number">123</span>).fieldwise());
</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is
seconds (as exemplified above), but we can ask for bigger units (up to
hours):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan, Unit};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"2024-05-03 23:30:00.123Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2024-02-25 07Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="comment">// If you want to deal in units bigger than hours, then you'll have to
    // convert your timestamp to a [`Zoned`] first.
    </span>ts1.since((Unit::Hour, ts2))<span class="question-mark">?</span>,
    <span class="number">1648</span>.hours().minutes(<span class="number">30</span>).milliseconds(<span class="number">123</span>).fieldwise(),
);
</code></pre></div>
<p>You can also round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{RoundMode, Timestamp, TimestampDifference, ToSpan, Unit};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"2024-05-03 23:30:59.123Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2024-05-02 07Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts1.since(
        TimestampDifference::new(ts2)
            .smallest(Unit::Minute)
            .largest(Unit::Hour),
    )<span class="question-mark">?</span>,
    <span class="number">40</span>.hours().minutes(<span class="number">30</span>).fieldwise(),
);
<span class="comment">// `TimestampDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    ts1.since(
        TimestampDifference::new(ts2)
            .smallest(Unit::Minute)
            .largest(Unit::Hour)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 31 minutes.
    </span><span class="number">40</span>.hours().minutes(<span class="number">31</span>).fieldwise(),
);
</code></pre></div>
<h2 id="rounding-timestamps"><a class="doc-anchor" href="#rounding-timestamps">§</a>Rounding timestamps</h2>
<p>A <code>Timestamp</code> can be rounded based on a <a href="struct.TimestampRound.html" title="struct jiff::TimestampRound"><code>TimestampRound</code></a> configuration of
smallest units, rounding increment and rounding mode. Here’s an example
showing how to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, TimestampRound, Unit};

<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19 16:27:29.999999999Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round(TimestampRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    <span class="string">"2024-06-19 15Z"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for TimestampRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(
    ts.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T15:00:00Z"</span>,
);
</code></pre></div>
<p>See <a href="struct.Timestamp.html#method.round" title="method jiff::Timestamp::round"><code>Timestamp::round</code></a> for more details.</p>
<h2 id="an-instant-in-time"><a class="doc-anchor" href="#an-instant-in-time">§</a>An instant in time</h2>
<p>Unlike a <a href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a>, a <code>Timestamp</code>
<em>always</em> corresponds, unambiguously, to a precise instant in time (to
nanosecond precision). This means that attaching a time zone to a timestamp
is always unambiguous because there’s never any question as to which
instant it refers to. This is true even for gaps in civil time.</p>
<p>For example, in <code>America/New_York</code>, clocks were moved ahead one hour
at clock time <code>2024-03-10 02:00:00</code>. That is, the 2 o’clock hour never
appeared on clocks in the <code>America/New_York</code> region. Since parsing a
timestamp always requires an offset, the time it refers to is unambiguous.
We can see this by writing a clock time, <code>02:30</code>, that never existed but
with two different offsets:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="comment">// All we're doing here is attaching an offset to a civil datetime.
// There is no time zone information here, and thus there is no
// accounting for ambiguity due to daylight saving time transitions.
</span><span class="kw">let </span>before_hour_jump: Timestamp = <span class="string">"2024-03-10 02:30-04"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>after_hour_jump: Timestamp = <span class="string">"2024-03-10 02:30-05"</span>.parse()<span class="question-mark">?</span>;
<span class="comment">// This shows the instant in time in UTC.
</span><span class="macro">assert_eq!</span>(before_hour_jump.to_string(), <span class="string">"2024-03-10T06:30:00Z"</span>);
<span class="macro">assert_eq!</span>(after_hour_jump.to_string(), <span class="string">"2024-03-10T07:30:00Z"</span>);

<span class="comment">// Now let's attach each instant to an `America/New_York` time zone.
</span><span class="kw">let </span>zdt_before = before_hour_jump.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt_after = after_hour_jump.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="comment">// And now we can see that even though the original instant refers to
// the 2 o'clock hour, since that hour never existed on the clocks in
// `America/New_York`, an instant with a time zone correctly adjusts.
</span><span class="macro">assert_eq!</span>(
    zdt_before.to_string(),
    <span class="string">"2024-03-10T01:30:00-05:00[America/New_York]"</span>,
);
<span class="macro">assert_eq!</span>(
    zdt_after.to_string(),
    <span class="string">"2024-03-10T03:30:00-04:00[America/New_York]"</span>,
);
</code></pre></div>
<p>In the example above, there is never a step that is incorrect or has an
alternative answer. Every step is unambiguous because we never involve
any <a href="civil/index.html" title="mod jiff::civil"><code>civil</code></a> datetimes.</p>
<p>But note that if the datetime string you’re parsing from lacks an offset,
then it <em>could</em> be ambiguous even if a time zone is specified. In this
case, parsing will always fail:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>result = <span class="string">"2024-06-30 08:30[America/New_York]"</span>.parse::&lt;Timestamp&gt;();
<span class="macro">assert_eq!</span>(
    result.unwrap_err().to_string(),
    <span class="string">"failed to find offset component in \
     \"2024-06-30 08:30[America/New_York]\", \
     which is required for parsing a timestamp"</span>,
);</code></pre></div>
<h2 id="converting-a-civil-datetime-to-a-timestamp"><a class="doc-anchor" href="#converting-a-civil-datetime-to-a-timestamp">§</a>Converting a civil datetime to a timestamp</h2>
<p>Sometimes you want to convert the “time on the clock” to a precise instant
in time. One way to do this was demonstrated in the previous section, but
it only works if you know your current time zone offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-30 08:36-04"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-06-30T12:36:00Z"</span>);
</code></pre></div>
<p>The above happened to be the precise instant in time I wrote the example.
Since I happened to know the offset, this worked okay. But what if I
didn’t? We could instead construct a civil datetime and attach a time zone
to it. This will create a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> value, from which we can access the
timestamp:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="kw">let </span>clock = date(<span class="number">2024</span>, <span class="number">6</span>, <span class="number">30</span>).at(<span class="number">8</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">0</span>).in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(clock.timestamp().to_string(), <span class="string">"2024-06-30T12:36:00Z"</span>);
</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#323-2137">Source</a><a href="#impl-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><a class="src rightside" href="../src/jiff/timestamp.rs.html#338-341">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>The minimum representable timestamp.</p>
<p>The minimum is chosen such that it can be combined with
any legal <a href="tz/struct.Offset.html" title="struct jiff::tz::Offset"><code>Offset</code></a> and turned into a
<a href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a>.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::Offset, Timestamp};

<span class="kw">let </span>dt = Offset::MIN.to_datetime(Timestamp::MIN);
<span class="macro">assert_eq!</span>(dt, date(-<span class="number">9999</span>, <span class="number">1</span>, <span class="number">1</span>).at(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><a class="src rightside" href="../src/jiff/timestamp.rs.html#357-360">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>The maximum representable timestamp.</p>
<p>The maximum is chosen such that it can be combined with
any legal <a href="tz/struct.Offset.html" title="struct jiff::tz::Offset"><code>Offset</code></a> and turned into a
<a href="civil/struct.DateTime.html" title="struct jiff::civil::DateTime"><code>civil::DateTime</code></a>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, tz::Offset, Timestamp};

<span class="kw">let </span>dt = Offset::MAX.to_datetime(Timestamp::MAX);
<span class="macro">assert_eq!</span>(dt, date(<span class="number">9999</span>, <span class="number">12</span>, <span class="number">31</span>).at(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>));</code></pre></div>
</div></details><details class="toggle" open><summary><section id="associatedconstant.UNIX_EPOCH" class="associatedconstant"><a class="src rightside" href="../src/jiff/timestamp.rs.html#370-373">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.UNIX_EPOCH" class="constant">UNIX_EPOCH</a>: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>The Unix epoch represented as a timestamp.</p>
<p>The Unix epoch corresponds to the instant at <code>1970-01-01T00:00:00Z</code>.
As a timestamp, it corresponds to <code>0</code> nanoseconds.</p>
<p>A timestamp is positive if and only if it is greater than the Unix
epoch. A timestamp is negative if and only if it is less than the Unix
epoch.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.now" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#403-406">Source</a><h4 class="code-header">pub fn <a href="#method.now" class="fn">now</a>() -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>Returns the current system time as a timestamp.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the system clock is set to a time value outside of the
range <code>-009999-01-01T00:00:00Z..=9999-12-31T11:59:59.999999999Z</code>. The
justification here is that it is reasonable to expect the system clock
to be set to a somewhat sane, if imprecise, value.</p>
<p>If you want to get the current Unix time fallibly, use
<a href="struct.Timestamp.html#method.try_from" title="associated function jiff::Timestamp::try_from"><code>Timestamp::try_from</code></a> with a <code>std::time::SystemTime</code> as input.</p>
<p>This may also panic when <code>SystemTime::now()</code> itself panics. The most
common context in which this happens is on the <code>wasm32-unknown-unknown</code>
target. If you’re using that target in the context of the web (for
example, via <code>wasm-pack</code>), and you’re an application, then you should
enable Jiff’s <code>js</code> feature. This will automatically instruct Jiff in
this very specific circumstance to execute JavaScript code to determine
the current time from the web browser.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert!</span>(Timestamp::now() &gt; Timestamp::UNIX_EPOCH);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#492-497">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>, nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new instant in time represented as a timestamp.</p>
<p>While a timestamp is logically a count of nanoseconds since the Unix
epoch, this constructor provides a convenience way of constructing
the timestamp from two components: seconds and fractional seconds
expressed as nanoseconds.</p>
<p>The signs of <code>second</code> and <code>nanosecond</code> need not be the same.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error if the given components would correspond to
an instant outside the supported range. Also, <code>nanosecond</code> is limited
to the range <code>-999,999,999..=999,999,999</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This example shows the instant in time 123,456,789 seconds after the
Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::new(<span class="number">123_456_789</span>, <span class="number">0</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1973-11-29T21:33:09Z"</span>,
);
</code></pre></div>
<h5 id="example-normalized-sign"><a class="doc-anchor" href="#example-normalized-sign">§</a>Example: normalized sign</h5>
<p>This example shows how <code>second</code> and <code>nanosecond</code> are resolved when
their signs differ.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">2</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), <span class="number">1</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">2</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), -<span class="number">1</span>);
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), -<span class="number">1</span>);
</code></pre></div>
<h5 id="example-limits"><a class="doc-anchor" href="#example-limits">§</a>Example: limits</h5>
<p>The minimum timestamp has nanoseconds set to zero, while the maximum
timestamp has nanoseconds set to <code>999,999,999</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(Timestamp::MIN.subsec_nanosecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Timestamp::MAX.subsec_nanosecond(), <span class="number">999_999_999</span>);</code></pre></div>
<p>As a consequence, nanoseconds cannot be negative when a timestamp has
minimal seconds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert!</span>(Timestamp::new(Timestamp::MIN.as_second(), -<span class="number">1</span>).is_err());
<span class="comment">// But they can be positive!
</span><span class="kw">let </span>one_ns_more = Timestamp::new(Timestamp::MIN.as_second(), <span class="number">1</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    one_ns_more.to_string(),
    <span class="string">"-009999-01-02T01:59:59.000000001Z"</span>,
);
<span class="comment">// Or, when combined with a minimal offset:
</span><span class="macro">assert_eq!</span>(
    jiff::tz::Offset::MIN.to_datetime(one_ns_more).to_string(),
    <span class="string">"-009999-01-01T00:00:00.000000001"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.constant" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#522-551">Source</a><h4 class="code-header">pub const fn <a href="#method.constant" class="fn">constant</a>(second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>, nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Timestamp</code> value in a <code>const</code> context.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This routine panics when <a href="struct.Timestamp.html#method.new" title="associated function jiff::Timestamp::new"><code>Timestamp::new</code></a> would return an error.
That is, when the given components would correspond to
an instant outside the supported range. Also, <code>nanosecond</code> is limited
to the range <code>-999,999,999..=999,999,999</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows the instant in time 123,456,789 seconds after the
Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::constant(<span class="number">123_456_789</span>, <span class="number">0</span>).to_string(),
    <span class="string">"1973-11-29T21:33:09Z"</span>,
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_second" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#619-621">Source</a><h4 class="code-header">pub fn <a href="#method.from_second" class="fn">from_second</a>(second: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new instant in time from the number of seconds elapsed since
the Unix epoch.</p>
<p>When <code>second</code> is negative, it corresponds to an instant in time before
the Unix epoch. A smaller number corresponds to an instant in time
further into the past.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error if the given second corresponds to a timestamp
outside of the <a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> boundaries.</p>
<p>It is a semver guarantee that the only way for this to return an error
is if the given value is out of range. That is, when it is less than
<code>Timestamp::MIN</code> or greater than <code>Timestamp::MAX</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows the instants in time 1 second immediately after and
before the Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::from_second(<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T00:00:01Z"</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::from_second(-<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1969-12-31T23:59:59Z"</span>,
);
</code></pre></div>
<h5 id="example-saturating-construction"><a class="doc-anchor" href="#example-saturating-construction">§</a>Example: saturating construction</h5>
<p>If you need a way to build a <code>Timestamp</code> value that saturates to
the minimum and maximum values supported by Jiff, then this is
guaranteed to work:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">fn </span>from_second_saturating(seconds: i64) -&gt; Timestamp {
    Timestamp::from_second(seconds).unwrap_or_else(|<span class="kw">_</span>| {
        <span class="kw">if </span>seconds &lt; <span class="number">0 </span>{
            Timestamp::MIN
        } <span class="kw">else </span>{
            Timestamp::MAX
        }
    })
}

<span class="macro">assert_eq!</span>(from_second_saturating(<span class="number">0</span>), Timestamp::UNIX_EPOCH);
<span class="macro">assert_eq!</span>(
    from_second_saturating(-<span class="number">999999999999999999</span>),
    Timestamp::MIN
);
<span class="macro">assert_eq!</span>(
    from_second_saturating(<span class="number">999999999999999999</span>),
    Timestamp::MAX
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_millisecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#690-696">Source</a><h4 class="code-header">pub fn <a href="#method.from_millisecond" class="fn">from_millisecond</a>(millisecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new instant in time from the number of milliseconds elapsed
since the Unix epoch.</p>
<p>When <code>millisecond</code> is negative, it corresponds to an instant in time
before the Unix epoch. A smaller number corresponds to an instant in
time further into the past.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error if the given millisecond corresponds to a
timestamp outside of the <a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a>
boundaries.</p>
<p>It is a semver guarantee that the only way for this to return an error
is if the given value is out of range. That is, when it is less than
<code>Timestamp::MIN</code> or greater than <code>Timestamp::MAX</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This example shows the instants in time 1 millisecond immediately after
and before the Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::from_millisecond(<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T00:00:00.001Z"</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::from_millisecond(-<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1969-12-31T23:59:59.999Z"</span>,
);
</code></pre></div>
<h5 id="example-saturating-construction-1"><a class="doc-anchor" href="#example-saturating-construction-1">§</a>Example: saturating construction</h5>
<p>If you need a way to build a <code>Timestamp</code> value that saturates to
the minimum and maximum values supported by Jiff, then this is
guaranteed to work:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">fn </span>from_millisecond_saturating(millis: i64) -&gt; Timestamp {
    Timestamp::from_millisecond(millis).unwrap_or_else(|<span class="kw">_</span>| {
        <span class="kw">if </span>millis &lt; <span class="number">0 </span>{
            Timestamp::MIN
        } <span class="kw">else </span>{
            Timestamp::MAX
        }
    })
}

<span class="macro">assert_eq!</span>(from_millisecond_saturating(<span class="number">0</span>), Timestamp::UNIX_EPOCH);
<span class="macro">assert_eq!</span>(
    from_millisecond_saturating(-<span class="number">999999999999999999</span>),
    Timestamp::MIN
);
<span class="macro">assert_eq!</span>(
    from_millisecond_saturating(<span class="number">999999999999999999</span>),
    Timestamp::MAX
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_microsecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#765-771">Source</a><h4 class="code-header">pub fn <a href="#method.from_microsecond" class="fn">from_microsecond</a>(microsecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new instant in time from the number of microseconds elapsed
since the Unix epoch.</p>
<p>When <code>microsecond</code> is negative, it corresponds to an instant in time
before the Unix epoch. A smaller number corresponds to an instant in
time further into the past.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>This returns an error if the given microsecond corresponds to a
timestamp outside of the <a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a>
boundaries.</p>
<p>It is a semver guarantee that the only way for this to return an error
is if the given value is out of range. That is, when it is less than
<code>Timestamp::MIN</code> or greater than <code>Timestamp::MAX</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This example shows the instants in time 1 microsecond immediately after
and before the Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::from_microsecond(<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T00:00:00.000001Z"</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::from_microsecond(-<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1969-12-31T23:59:59.999999Z"</span>,
);
</code></pre></div>
<h5 id="example-saturating-construction-2"><a class="doc-anchor" href="#example-saturating-construction-2">§</a>Example: saturating construction</h5>
<p>If you need a way to build a <code>Timestamp</code> value that saturates to
the minimum and maximum values supported by Jiff, then this is
guaranteed to work:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">fn </span>from_microsecond_saturating(micros: i64) -&gt; Timestamp {
    Timestamp::from_microsecond(micros).unwrap_or_else(|<span class="kw">_</span>| {
        <span class="kw">if </span>micros &lt; <span class="number">0 </span>{
            Timestamp::MIN
        } <span class="kw">else </span>{
            Timestamp::MAX
        }
    })
}

<span class="macro">assert_eq!</span>(from_microsecond_saturating(<span class="number">0</span>), Timestamp::UNIX_EPOCH);
<span class="macro">assert_eq!</span>(
    from_microsecond_saturating(-<span class="number">999999999999999999</span>),
    Timestamp::MIN
);
<span class="macro">assert_eq!</span>(
    from_microsecond_saturating(<span class="number">999999999999999999</span>),
    Timestamp::MAX
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_nanosecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#840-844">Source</a><h4 class="code-header">pub fn <a href="#method.from_nanosecond" class="fn">from_nanosecond</a>(nanosecond: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i128.html">i128</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new instant in time from the number of nanoseconds elapsed
since the Unix epoch.</p>
<p>When <code>nanosecond</code> is negative, it corresponds to an instant in time
before the Unix epoch. A smaller number corresponds to an instant in
time further into the past.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This returns an error if the given nanosecond corresponds to a
timestamp outside of the <a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a>
boundaries.</p>
<p>It is a semver guarantee that the only way for this to return an error
is if the given value is out of range. That is, when it is less than
<code>Timestamp::MIN</code> or greater than <code>Timestamp::MAX</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This example shows the instants in time 1 nanosecond immediately after
and before the Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert_eq!</span>(
    Timestamp::from_nanosecond(<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1970-01-01T00:00:00.000000001Z"</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::from_nanosecond(-<span class="number">1</span>)<span class="question-mark">?</span>.to_string(),
    <span class="string">"1969-12-31T23:59:59.999999999Z"</span>,
);
</code></pre></div>
<h5 id="example-saturating-construction-3"><a class="doc-anchor" href="#example-saturating-construction-3">§</a>Example: saturating construction</h5>
<p>If you need a way to build a <code>Timestamp</code> value that saturates to
the minimum and maximum values supported by Jiff, then this is
guaranteed to work:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">fn </span>from_nanosecond_saturating(nanos: i128) -&gt; Timestamp {
    Timestamp::from_nanosecond(nanos).unwrap_or_else(|<span class="kw">_</span>| {
        <span class="kw">if </span>nanos &lt; <span class="number">0 </span>{
            Timestamp::MIN
        } <span class="kw">else </span>{
            Timestamp::MAX
        }
    })
}

<span class="macro">assert_eq!</span>(from_nanosecond_saturating(<span class="number">0</span>), Timestamp::UNIX_EPOCH);
<span class="macro">assert_eq!</span>(
    from_nanosecond_saturating(-<span class="number">9999999999999999999999999999999999</span>),
    Timestamp::MIN
);
<span class="macro">assert_eq!</span>(
    from_nanosecond_saturating(<span class="number">9999999999999999999999999999999999</span>),
    Timestamp::MAX
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_duration" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#939-964">Source</a><h4 class="code-header">pub fn <a href="#method.from_duration" class="fn">from_duration</a>(duration: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new timestamp from a <code>Duration</code> with the given sign since the
Unix epoch.</p>
<p>Positive durations result in a timestamp after the Unix epoch. Negative
durations result in a timestamp before the Unix epoch.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error if the given duration corresponds to a timestamp
outside of the <a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> and <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> boundaries.</p>
<p>It is a semver guarantee that the only way for this to return an error
is if the given value is out of range. That is, when it is less than
<code>Timestamp::MIN</code> or greater than <code>Timestamp::MAX</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<p>How one might construct a <code>Timestamp</code> from a <code>SystemTime</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::SystemTime;
<span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="kw">let </span>unix_epoch = SystemTime::UNIX_EPOCH;
<span class="kw">let </span>now = SystemTime::now();
<span class="kw">let </span>duration = SignedDuration::system_until(unix_epoch, now)<span class="question-mark">?</span>;
<span class="kw">let </span>ts = Timestamp::from_duration(duration)<span class="question-mark">?</span>;
<span class="macro">assert!</span>(ts &gt; Timestamp::UNIX_EPOCH);
</code></pre></div>
<p>Of course, one should just use <a href="struct.Timestamp.html#method.try_from" title="associated function jiff::Timestamp::try_from"><code>Timestamp::try_from</code></a> for this
instead. Indeed, the above example is copied almost exactly from the
<code>TryFrom</code> implementation.</p>
<h5 id="example-out-of-bounds"><a class="doc-anchor" href="#example-out-of-bounds">§</a>Example: out of bounds</h5>
<p>This example shows how some of the boundary conditions are dealt with.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="comment">// OK, we get the minimum timestamp supported by Jiff:
</span><span class="kw">let </span>duration = SignedDuration::new(-<span class="number">377705023201</span>, <span class="number">0</span>);
<span class="kw">let </span>ts = Timestamp::from_duration(duration)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts, Timestamp::MIN);

<span class="comment">// We use the minimum number of seconds, but even subtracting
// one more nanosecond after it will result in an error.
</span><span class="kw">let </span>duration = SignedDuration::new(-<span class="number">377705023201</span>, -<span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    Timestamp::from_duration(duration).unwrap_err().to_string(),
    <span class="string">"parameter 'seconds and nanoseconds' with value -1 is not \
     in the required range of 0..=1000000000"</span>,
);
</code></pre></div>
<h5 id="example-saturating-construction-4"><a class="doc-anchor" href="#example-saturating-construction-4">§</a>Example: saturating construction</h5>
<p>If you need a way to build a <code>Timestamp</code> value that saturates to
the minimum and maximum values supported by Jiff, then this is
guaranteed to work:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="kw">fn </span>from_duration_saturating(dur: SignedDuration) -&gt; Timestamp {
    Timestamp::from_duration(dur).unwrap_or_else(|<span class="kw">_</span>| {
        <span class="kw">if </span>dur.is_negative() {
            Timestamp::MIN
        } <span class="kw">else </span>{
            Timestamp::MAX
        }
    })
}

<span class="macro">assert_eq!</span>(
    from_duration_saturating(SignedDuration::ZERO),
    Timestamp::UNIX_EPOCH,
);
<span class="macro">assert_eq!</span>(
    from_duration_saturating(SignedDuration::from_secs(-<span class="number">999999999999</span>)),
    Timestamp::MIN
);
<span class="macro">assert_eq!</span>(
    from_duration_saturating(SignedDuration::from_secs(<span class="number">999999999999</span>)),
    Timestamp::MAX
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_second" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#989-991">Source</a><h4 class="code-header">pub fn <a href="#method.as_second" class="fn">as_second</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns this timestamp as a number of seconds since the Unix epoch.</p>
<p>This only returns the number of whole seconds. That is, if there are
any fractional seconds in this timestamp, then they are truncated.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), <span class="number">5</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), <span class="number">5</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), -<span class="number">5</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_second(), -<span class="number">5</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_millisecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1018-1020">Source</a><h4 class="code-header">pub fn <a href="#method.as_millisecond" class="fn">as_millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns this timestamp as a number of milliseconds since the Unix
epoch.</p>
<p>This only returns the number of whole milliseconds. That is, if there
are any fractional milliseconds in this timestamp, then they are
truncated.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_millisecond(), <span class="number">5_123</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_millisecond(), <span class="number">5_999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_millisecond(), -<span class="number">5_123</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_millisecond(), -<span class="number">5_999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_microsecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1047-1049">Source</a><h4 class="code-header">pub fn <a href="#method.as_microsecond" class="fn">as_microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i64.html">i64</a></h4></section></summary><div class="docblock"><p>Returns this timestamp as a number of microseconds since the Unix
epoch.</p>
<p>This only returns the number of whole microseconds. That is, if there
are any fractional microseconds in this timestamp, then they are
truncated.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_microsecond(), <span class="number">5_123_456</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_microsecond(), <span class="number">5_999_999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_microsecond(), -<span class="number">5_123_456</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_microsecond(), -<span class="number">5_999_999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_nanosecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1077-1079">Source</a><h4 class="code-header">pub fn <a href="#method.as_nanosecond" class="fn">as_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i128.html">i128</a></h4></section></summary><div class="docblock"><p>Returns this timestamp as a number of nanoseconds since the Unix
epoch.</p>
<p>Since a <code>Timestamp</code> has a nanosecond precision, the nanoseconds
returned here represent this timestamp losslessly. That is, the
nanoseconds returned can be used with <a href="struct.Timestamp.html#method.from_nanosecond" title="associated function jiff::Timestamp::from_nanosecond"><code>Timestamp::from_nanosecond</code></a> to
create an identical timestamp with no loss of precision.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_nanosecond(), <span class="number">5_123_456_789</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_nanosecond(), <span class="number">5_999_999_999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_nanosecond(), -<span class="number">5_123_456_789</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.as_nanosecond(), -<span class="number">5_999_999_999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_millisecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1109-1111">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_millisecond" class="fn">subsec_millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional second component of this timestamp in units
of milliseconds.</p>
<p>It is guaranteed that this will never return a value that is greater
than 1 second (or less than -1 second).</p>
<p>This only returns the number of whole milliseconds. That is, if there
are any fractional milliseconds in this timestamp, then they are
truncated.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_millisecond(), <span class="number">123</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_millisecond(), <span class="number">999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_millisecond(), -<span class="number">123</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_millisecond(), -<span class="number">999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_microsecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1141-1143">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_microsecond" class="fn">subsec_microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional second component of this timestamp in units of
microseconds.</p>
<p>It is guaranteed that this will never return a value that is greater
than 1 second (or less than -1 second).</p>
<p>This only returns the number of whole microseconds. That is, if there
are any fractional microseconds in this timestamp, then they are
truncated.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_microsecond(), <span class="number">123_456</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_microsecond(), <span class="number">999_999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_microsecond(), -<span class="number">123_456</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_microsecond(), -<span class="number">999_999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1169-1171">Source</a><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional second component of this timestamp in units of
nanoseconds.</p>
<p>It is guaranteed that this will never return a value that is greater
than 1 second (or less than -1 second).</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), <span class="number">123_456_789</span>);
<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), <span class="number">999_999_999</span>);

<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), -<span class="number">123_456_789</span>);
<span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), -<span class="number">999_999_999</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_duration" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1196-1198">Source</a><h4 class="code-header">pub fn <a href="#method.as_duration" class="fn">as_duration</a>(self) -&gt; <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns this timestamp as a <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> since the Unix epoch.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="macro">assert_eq!</span>(
    Timestamp::UNIX_EPOCH.as_duration(),
    SignedDuration::ZERO,
);
<span class="macro">assert_eq!</span>(
    Timestamp::new(<span class="number">5</span>, <span class="number">123_456_789</span>)<span class="question-mark">?</span>.as_duration(),
    SignedDuration::new(<span class="number">5</span>, <span class="number">123_456_789</span>),
);
<span class="macro">assert_eq!</span>(
    Timestamp::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>)<span class="question-mark">?</span>.as_duration(),
    SignedDuration::new(-<span class="number">5</span>, -<span class="number">123_456_789</span>),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.signum" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1235-1243">Source</a><h4 class="code-header">pub fn <a href="#method.signum" class="fn">signum</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the sign of this timestamp.</p>
<p>This can return one of three possible values:</p>
<ul>
<li><code>0</code> when this timestamp is precisely equivalent to
<a href="struct.Timestamp.html#associatedconstant.UNIX_EPOCH" title="associated constant jiff::Timestamp::UNIX_EPOCH"><code>Timestamp::UNIX_EPOCH</code></a>.</li>
<li><code>1</code> when this timestamp occurs after the Unix epoch.</li>
<li><code>-1</code> when this timestamp occurs before the Unix epoch.</li>
</ul>
<p>The sign returned is guaranteed to match the sign of all “getter”
methods on <code>Timestamp</code>. For example, <a href="struct.Timestamp.html#method.as_second" title="method jiff::Timestamp::as_second"><code>Timestamp::as_second</code></a> and
<a href="struct.Timestamp.html#method.subsec_nanosecond" title="method jiff::Timestamp::subsec_nanosecond"><code>Timestamp::subsec_nanosecond</code></a>. This is true even if the signs
of the <code>second</code> and <code>nanosecond</code> components were mixed when given to
the <a href="struct.Timestamp.html#method.new" title="associated function jiff::Timestamp::new"><code>Timestamp::new</code></a> constructor.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">5</span>, -<span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.signum(), <span class="number">1</span>);
<span class="comment">// The mixed signs were normalized away!
</span><span class="macro">assert_eq!</span>(ts.as_second(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), <span class="number">1</span>);

<span class="comment">// The same applies for negative timestamps.
</span><span class="kw">let </span>ts = Timestamp::new(-<span class="number">5</span>, <span class="number">999_999_999</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.signum(), -<span class="number">1</span>);
<span class="macro">assert_eq!</span>(ts.as_second(), -<span class="number">4</span>);
<span class="macro">assert_eq!</span>(ts.subsec_nanosecond(), -<span class="number">1</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_zero" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1256-1258">Source</a><h4 class="code-header">pub fn <a href="#method.is_zero" class="fn">is_zero</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this timestamp corresponds to the instant
in time known as the Unix epoch.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert!</span>(Timestamp::UNIX_EPOCH.is_zero());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.in_tz" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1322-1325">Source</a><h4 class="code-header">pub fn <a href="#method.in_tz" class="fn">in_tz</a>(self, time_zone_name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> value by attaching a time zone for the given name
to this instant in time.</p>
<p>The name given is resolved to a <a href="tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a> by using the default
<a href="tz/struct.TimeZoneDatabase.html" title="struct jiff::tz::TimeZoneDatabase"><code>TimeZoneDatabase</code></a> created by
<a href="tz/fn.db.html" title="fn jiff::tz::db"><code>tz::db</code></a>. Indeed, this is a convenience function
for <a href="struct.Timestamp.html#method.to_zoned" title="method jiff::Timestamp::to_zoned"><code>Timestamp::to_zoned</code></a> where the time zone database lookup
is done automatically.</p>
<p>Assuming the time zone name could be resolved to a <a href="tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone"><code>TimeZone</code></a>, this
routine is otherwise infallible and never results in any ambiguity
since both a <a href="struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a> and a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> correspond to precise
instant in time. This is unlike
<a href="civil/struct.DateTime.html#method.to_zoned" title="method jiff::civil::DateTime::to_zoned"><code>civil::DateTime::to_zoned</code></a>,
where a civil datetime might correspond to more than one instant in
time (i.e., a fold, typically DST ending) or no instants in time (i.e.,
a gap, typically DST starting).</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when the given time zone name could not be found
in the default time zone database.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This is a simple example of converting the instant that is <code>123,456,789</code>
seconds after the Unix epoch to an instant that is aware of its time
zone:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">123_456_789</span>, <span class="number">0</span>).unwrap();
<span class="kw">let </span>zdt = ts.in_tz(<span class="string">"America/New_York"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"1973-11-29T16:33:09-05:00[America/New_York]"</span>);
</code></pre></div>
<p>This can be used to answer questions like, “What time was it at the
Unix epoch in Tasmania?”</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="comment">// Time zone database lookups are case insensitive!
</span><span class="kw">let </span>zdt = Timestamp::UNIX_EPOCH.in_tz(<span class="string">"australia/tasmania"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"1970-01-01T11:00:00+11:00[Australia/Tasmania]"</span>);
</code></pre></div>
<h5 id="example-errors"><a class="doc-anchor" href="#example-errors">§</a>Example: errors</h5>
<p>This routine can return an error when the time zone is unrecognized:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="macro">assert!</span>(Timestamp::UNIX_EPOCH.in_tz(<span class="string">"does not exist"</span>).is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_zoned" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1381-1383">Source</a><h4 class="code-header">pub fn <a href="#method.to_zoned" class="fn">to_zoned</a>(self, tz: <a class="struct" href="tz/struct.TimeZone.html" title="struct jiff::tz::TimeZone">TimeZone</a>) -&gt; <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a></h4></section></summary><div class="docblock"><p>Creates a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> value by attaching the given time zone to this
instant in time.</p>
<p>This is infallible and never results in any ambiguity since both a
<a href="struct.Timestamp.html" title="struct jiff::Timestamp"><code>Timestamp</code></a> and a <a href="struct.Zoned.html" title="struct jiff::Zoned"><code>Zoned</code></a> correspond to precise instant in time.
This is unlike
<a href="civil/struct.DateTime.html#method.to_zoned" title="method jiff::civil::DateTime::to_zoned"><code>civil::DateTime::to_zoned</code></a>,
where a civil datetime might correspond to more than one instant in
time (i.e., a fold, typically DST ending) or no instants in time (i.e.,
a gap, typically DST starting).</p>
<p>In the common case of a time zone being represented as a name string,
like <code>Australia/Tasmania</code>, consider using <a href="struct.Timestamp.html#method.in_tz" title="method jiff::Timestamp::in_tz"><code>Timestamp::in_tz</code></a>
instead.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This example shows how to create a zoned value with a fixed time zone
offset:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{tz::{<span class="self">self</span>, TimeZone}, Timestamp};

<span class="kw">let </span>ts = Timestamp::new(<span class="number">123_456_789</span>, <span class="number">0</span>).unwrap();
<span class="kw">let </span>tz = TimeZone::fixed(tz::offset(-<span class="number">4</span>));
<span class="kw">let </span>zdt = ts.to_zoned(tz);
<span class="comment">// A time zone annotation is still included in the printable version
// of the Zoned value, but it is fixed to a particular offset.
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"1973-11-29T17:33:09-04:00[-04:00]"</span>);</code></pre></div>
<h5 id="example-posix-time-zone-strings"><a class="doc-anchor" href="#example-posix-time-zone-strings">§</a>Example: POSIX time zone strings</h5>
<p>This example shows how to create a time zone from a POSIX time zone
string that describes the transition to and from daylight saving
time for <code>America/St_Johns</code>. In particular, this rule uses non-zero
minutes, which is atypical.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{tz::TimeZone, Timestamp};

<span class="kw">let </span>ts = Timestamp::new(<span class="number">123_456_789</span>, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>tz = TimeZone::posix(<span class="string">"NST3:30NDT,M3.2.0,M11.1.0"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>zdt = ts.to_zoned(tz);
<span class="comment">// There isn't any agreed upon mechanism for transmitting a POSIX time
// zone string within an RFC 9557 TZ annotation, so Jiff just emits the
// offset. In practice, POSIX TZ strings are rarely user facing anyway.
// (They are still in widespread use as an implementation detail of the
// IANA Time Zone Database however.)
</span><span class="macro">assert_eq!</span>(zdt.to_string(), <span class="string">"1973-11-29T18:03:09-03:30[-03:30]"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1497-1503">Source</a><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Add the given span of time to this timestamp.</p>
<p>This operation accepts three different duration types: <a href="struct.Span.html" title="struct jiff::Span"><code>Span</code></a>,
<a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic"><code>TimestampArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>Given a timestamp <code>ts1</code> and a span <code>s</code>, and assuming <code>ts2 = ts1 + s</code>
exists, it follows then that <code>ts1 = ts2 - s</code> for all values of <code>ts1</code>
and <code>s</code> that sum to a valid <code>ts2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original timestamp.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>If the sum would overflow the minimum or maximum timestamp values, then
an error is returned.</p>
<p>This also returns an error if the given duration is a <code>Span</code> with any
non-zero units greater than hours. If you want to use bigger units,
convert this timestamp to a <code>Zoned</code> and use <a href="struct.Zoned.html#method.checked_add" title="method jiff::Zoned::checked_add"><code>Zoned::checked_add</code></a>.
This error occurs because a <code>Timestamp</code> has no time zone attached to
it, and thus cannot unambiguously resolve the length of a single day.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This shows how to add <code>5</code> hours to the Unix epoch:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts = Timestamp::UNIX_EPOCH.checked_add(<span class="number">5</span>.hours())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"1970-01-01T05:00:00Z"</span>);
</code></pre></div>
<h5 id="example-negative-spans-are-supported"><a class="doc-anchor" href="#example-negative-spans-are-supported">§</a>Example: negative spans are supported</h5>
<p>This shows how to add <code>-5</code> hours to the Unix epoch. This is the same
as subtracting <code>5</code> hours from the Unix epoch.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts = Timestamp::UNIX_EPOCH.checked_add(-<span class="number">5</span>.hours())<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"1969-12-31T19:00:00Z"</span>);
</code></pre></div>
<h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator. Note though that if it
fails, it will result in a panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts1 = Timestamp::new(<span class="number">2_999_999_999</span>, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts1.to_string(), <span class="string">"2065-01-24T05:19:59Z"</span>);

<span class="kw">let </span>ts2 = ts1 + <span class="number">1</span>.hour().minutes(<span class="number">30</span>).nanoseconds(<span class="number">123</span>);
<span class="macro">assert_eq!</span>(ts2.to_string(), <span class="string">"2065-01-24T06:49:59.000000123Z"</span>);
</code></pre></div>
<h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>ts = Timestamp::MAX;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"9999-12-30T22:00:00.999999999Z"</span>);
<span class="macro">assert!</span>(ts.checked_add(<span class="number">1</span>.nanosecond()).is_err());

<span class="kw">let </span>ts = Timestamp::MIN;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"-009999-01-02T01:59:59Z"</span>);
<span class="macro">assert!</span>(ts.checked_add(-<span class="number">1</span>.nanosecond()).is_err());</code></pre></div>
<h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>Timestamp</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="kw">let </span>ts1 = Timestamp::new(<span class="number">2_999_999_999</span>, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts1.to_string(), <span class="string">"2065-01-24T05:19:59Z"</span>);

<span class="kw">let </span>dur = SignedDuration::new(<span class="number">60 </span>* <span class="number">60 </span>+ <span class="number">30 </span>* <span class="number">60</span>, <span class="number">123</span>);
<span class="macro">assert_eq!</span>(
    ts1.checked_add(dur)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2065-01-24T06:49:59.000000123Z"</span>,
);

<span class="kw">let </span>dur = Duration::new(<span class="number">60 </span>* <span class="number">60 </span>+ <span class="number">30 </span>* <span class="number">60</span>, <span class="number">123</span>);
<span class="macro">assert_eq!</span>(
    ts1.checked_add(dur)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2065-01-24T06:49:59.000000123Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1598-1604">Source</a><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a> with the
duration negated.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Note though that if it
fails, it will result in a panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp, ToSpan};

<span class="kw">let </span>ts1 = Timestamp::new(<span class="number">2_999_999_999</span>, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts1.to_string(), <span class="string">"2065-01-24T05:19:59Z"</span>);

<span class="kw">let </span>ts2 = ts1 - <span class="number">1</span>.hour().minutes(<span class="number">30</span>).nanoseconds(<span class="number">123</span>);
<span class="macro">assert_eq!</span>(ts2.to_string(), <span class="string">"2065-01-24T03:49:58.999999877Z"</span>);
</code></pre></div>
<h5 id="example-use-with-signedduration-and-stdtimeduration"><a class="doc-anchor" href="#example-use-with-signedduration-and-stdtimeduration">§</a>Example: use with <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> and <a href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration"><code>std::time::Duration</code></a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="kw">let </span>ts1 = Timestamp::new(<span class="number">2_999_999_999</span>, <span class="number">0</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts1.to_string(), <span class="string">"2065-01-24T05:19:59Z"</span>);

<span class="kw">let </span>dur = SignedDuration::new(<span class="number">60 </span>* <span class="number">60 </span>+ <span class="number">30 </span>* <span class="number">60</span>, <span class="number">123</span>);
<span class="macro">assert_eq!</span>(
    ts1.checked_sub(dur)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2065-01-24T03:49:58.999999877Z"</span>,
);

<span class="kw">let </span>dur = Duration::new(<span class="number">60 </span>* <span class="number">60 </span>+ <span class="number">30 </span>* <span class="number">60</span>, <span class="number">123</span>);
<span class="macro">assert_eq!</span>(
    ts1.checked_sub(dur)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2065-01-24T03:49:58.999999877Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1646-1654">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.Timestamp.html#associatedconstant.MIN" title="associated constant jiff::Timestamp::MIN"><code>Timestamp::MIN</code></a> or <a href="struct.Timestamp.html#associatedconstant.MAX" title="associated constant jiff::Timestamp::MAX"><code>Timestamp::MAX</code></a> is returned.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>This returns an error if the given <code>Span</code> contains any non-zero units
greater than hours.</p>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<p>This example shows that arithmetic saturates on overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp, ToSpan};

<span class="macro">assert_eq!</span>(
    Timestamp::MAX,
    Timestamp::MAX.saturating_add(<span class="number">1</span>.nanosecond())<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MIN,
    Timestamp::MIN.saturating_add(-<span class="number">1</span>.nanosecond())<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MAX,
    Timestamp::UNIX_EPOCH.saturating_add(SignedDuration::MAX)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MIN,
    Timestamp::UNIX_EPOCH.saturating_add(SignedDuration::MIN)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MAX,
    Timestamp::UNIX_EPOCH.saturating_add(std::time::Duration::MAX)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1695-1704">Source</a><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampArithmetic.html" title="struct jiff::TimestampArithmetic">TimestampArithmetic</a>&gt;&gt;(
    self,
    duration: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Timestamp.html#method.saturating_add" title="method jiff::Timestamp::saturating_add"><code>Timestamp::saturating_add</code></a> with the
span parameter negated.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>This returns an error if the given <code>Span</code> contains any non-zero units
greater than hours.</p>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<p>This example shows that arithmetic saturates on overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp, ToSpan};

<span class="macro">assert_eq!</span>(
    Timestamp::MIN,
    Timestamp::MIN.saturating_sub(<span class="number">1</span>.nanosecond())<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MAX,
    Timestamp::MAX.saturating_sub(-<span class="number">1</span>.nanosecond())<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MIN,
    Timestamp::UNIX_EPOCH.saturating_sub(SignedDuration::MAX)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MAX,
    Timestamp::UNIX_EPOCH.saturating_sub(SignedDuration::MIN)<span class="question-mark">?</span>,
);
<span class="macro">assert_eq!</span>(
    Timestamp::MIN,
    Timestamp::UNIX_EPOCH.saturating_sub(std::time::Duration::MAX)<span class="question-mark">?</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1822-1833">Source</a><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference">TimestampDifference</a>&gt;&gt;(
    self,
    other: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this timestamp until
the given <code>other</code> timestamp.</p>
<p>When <code>other</code> occurs before this timestamp, then the span returned will
be negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced up to bigger units than the default. By default,
the span returned is balanced such that the biggest possible unit is
seconds.</p>
<p>This operation is configured by providing a <a href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference"><code>TimestampDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;TimestampDifference&gt;</code>, once can pass a <code>Timestamp</code> directly.
One can also pass a <code>(Unit, Timestamp)</code>, where <code>Unit</code> is treated as
<a href="struct.TimestampDifference.html#method.largest" title="method jiff::TimestampDifference::largest"><code>TimestampDifference::largest</code></a>.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>It is guaranteed that if the returned span is subtracted from <code>other</code>,
and if no rounding is requested, then the original timestamp will be
returned.</p>
<p>This routine is equivalent to <code>self.since(other).map(|span| -span)</code>
if no rounding options are set. If rounding options are set, then
it’s equivalent to
<code>self.since(other_without_rounding_options).map(|span| -span)</code>,
followed by a call to <a href="struct.Span.html#method.round" title="method jiff::Span::round"><code>Span::round</code></a> with the appropriate rounding
options set. This is because the negation of a span can result in
different rounding results depending on the rounding mode.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>An error can occur in some cases when the requested configuration
would result in a span that is beyond allowable limits. For example,
the nanosecond component of a span cannot represent the span of
time between the minimum and maximum timestamps supported by Jiff.
Therefore, if one requests a span with its largest unit set to
<a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then it’s possible for this routine to fail.</p>
<p>An error can also occur if <code>TimestampDifference</code> is misconfigured. For
example, if the smallest unit provided is bigger than the largest unit,
or if the largest unit provided is bigger than hours. (To use bigger
units with an instant in time, use <a href="struct.Zoned.html#method.until" title="method jiff::Zoned::until"><code>Zoned::until</code></a> instead.)</p>
<p>It is guaranteed that if one provides a timestamp with the default
<a href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference"><code>TimestampDifference</code></a> configuration, then this routine will never
fail.</p>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>earlier: Timestamp = <span class="string">"2006-08-24T22:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>later: Timestamp = <span class="string">"2019-01-31 21:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(earlier.until(later)<span class="question-mark">?</span>, <span class="number">392509800</span>.seconds().fieldwise());

<span class="comment">// Flipping the timestamps is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(later.until(earlier)<span class="question-mark">?</span>, -<span class="number">392509800</span>.seconds().fieldwise());
</code></pre></div>
<h5 id="example-using-bigger-units"><a class="doc-anchor" href="#example-using-bigger-units">§</a>Example: using bigger units</h5>
<p>This example shows how to expand the span returned to bigger units.
This makes use of a <code>From&lt;(Unit, Timestamp)&gt; for TimestampDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan, Unit};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"1995-12-07T03:24:30.000003500Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2019-01-31 15:30:00Z"</span>.parse()<span class="question-mark">?</span>;

<span class="comment">// The default limits durations to using "seconds" as the biggest unit.
</span><span class="kw">let </span>span = ts1.until(ts2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT730641929.9999965S"</span>);

<span class="comment">// But we can ask for units all the way up to hours.
</span><span class="kw">let </span>span = ts1.until((Unit::Hour, ts2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT202956H5M29.9999965S"</span>);
</code></pre></div>
<h5 id="example-rounding-the-result"><a class="doc-anchor" href="#example-rounding-the-result">§</a>Example: rounding the result</h5>
<p>This shows how one might find the difference between two timestamps and
have the result rounded such that sub-seconds are removed.</p>
<p>In this case, we need to hand-construct a <a href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference"><code>TimestampDifference</code></a>
in order to gain full configurability.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, TimestampDifference, ToSpan, Unit};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"1995-12-07 03:24:30.000003500Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2019-01-31 15:30:00Z"</span>.parse()<span class="question-mark">?</span>;

<span class="kw">let </span>span = ts1.until(
    TimestampDifference::from(ts2).smallest(Unit::Second),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT730641929S"</span>);

<span class="comment">// We can combine smallest and largest units too!
</span><span class="kw">let </span>span = ts1.until(
    TimestampDifference::from(ts2)
        .smallest(Unit::Second)
        .largest(Unit::Hour),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT202956H5M29S"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1858-1869">Source</a><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference">TimestampDifference</a>&gt;&gt;(
    self,
    other: A,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a>.</p>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible timestamps, it will never panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>earlier: Timestamp = <span class="string">"2006-08-24T22:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>later: Timestamp = <span class="string">"2019-01-31 21:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(later - earlier, <span class="number">392509800</span>.seconds().fieldwise());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1960-1962">Source</a><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(self, other: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
timestamp until the given <code>other</code> timestamp.</p>
<p>When <code>other</code> occurs before this timestamp, then the duration returned
will be negative.</p>
<p>Unlike <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a>, this always returns a duration
corresponding to a 96-bit integer of nanoseconds between two
timestamps.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a>
can return an error in some cases due to misconfiguration. But like
this routine, <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a> never panics or returns an error in
its default configuration.</p>
<h5 id="when-should-i-use-this-versus-timestampuntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-timestampuntil">§</a>When should I use this versus <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a>?</h5>
<p>See the type documentation for <a href="struct.SignedDuration.html" title="struct jiff::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="struct.Span.html" title="struct jiff::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>Timestamp::until</code>) unless you have
a specific reason to do otherwise.</p>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, SignedDuration};

<span class="kw">let </span>earlier: Timestamp = <span class="string">"2006-08-24T22:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>later: Timestamp = <span class="string">"2019-01-31 21:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    earlier.duration_until(later),
    SignedDuration::from_secs(<span class="number">392509800</span>),
);

<span class="comment">// Flipping the timestamps is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(
    later.duration_until(earlier),
    SignedDuration::from_secs(-<span class="number">392509800</span>),
);
</code></pre></div>
<h5 id="example-difference-with-timestampuntil"><a class="doc-anchor" href="#example-difference-with-timestampuntil">§</a>Example: difference with <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a></h5>
<p>The primary difference between this routine and
<code>Timestamp::until</code>, other than the return type, is that this
routine is likely to be faster. Namely, it does simple 96-bit
integer math, where as <code>Timestamp::until</code> has to do a bit more
work to deal with the different types of units on a <code>Span</code>.</p>
<p>Additionally, since the difference between two timestamps is always
expressed in units of hours or smaller, and units of hours or smaller
are always uniform, there is no “expressive” difference between this
routine and <code>Timestamp::until</code>. Because of this, one can always
convert between <code>Span</code> and <code>SignedDuration</code> as returned by methods
on <code>Timestamp</code> without a relative datetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Span, Timestamp};

<span class="kw">let </span>ts1: Timestamp = <span class="string">"2024-02-28T00:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>ts2: Timestamp = <span class="string">"2024-03-01T00:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>dur = ts1.duration_until(ts2);
<span class="comment">// Guaranteed to never fail because the duration
// between two civil times never exceeds the limits
// of a `Span`.
</span><span class="kw">let </span>span = Span::try_from(dur).unwrap();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{span:#}"</span>), <span class="string">"172800s"</span>);
<span class="comment">// Guaranteed to succeed and always return the original
// duration because the units are always hours or smaller,
// and thus uniform. This means a relative datetime is
// never required to do this conversion.
</span><span class="kw">let </span>dur = SignedDuration::try_from(span).unwrap();
<span class="macro">assert_eq!</span>(dur, SignedDuration::from_secs(<span class="number">172_800</span>));
</code></pre></div>
<p>This conversion guarantee also applies to <a href="struct.Timestamp.html#method.until" title="method jiff::Timestamp::until"><code>Timestamp::until</code></a> since it
always returns a balanced span. That is, it never returns spans like
<code>1 second 1000 milliseconds</code>. (Those cannot be losslessly converted to
a <code>SignedDuration</code> since a <code>SignedDuration</code> is only represented as a
single 96-bit integer of nanoseconds.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#1982-1984">Source</a><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(self, other: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Timestamp.html#method.duration_until" title="method jiff::Timestamp::duration_until"><code>Timestamp::duration_until</code></a>, but the
order of the parameters is flipped.</p>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{SignedDuration, Timestamp};

<span class="kw">let </span>earlier: Timestamp = <span class="string">"2006-08-24T22:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>later: Timestamp = <span class="string">"2019-01-31 21:00:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    later.duration_since(earlier),
    SignedDuration::from_secs(<span class="number">392509800</span>),
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2087-2093">Source</a><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.TimestampRound.html" title="struct jiff::TimestampRound">TimestampRound</a>&gt;&gt;(
    self,
    options: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Rounds this timestamp according to the <a href="struct.TimestampRound.html" title="struct jiff::TimestampRound"><code>TimestampRound</code></a> configuration
given.</p>
<p>The principal option is <a href="struct.TimestampRound.html#method.smallest" title="method jiff::TimestampRound::smallest"><code>TimestampRound::smallest</code></a>, which allows
one to configure the smallest units in the returned timestamp.
Rounding is what determines whether the specified smallest unit
should keep its current value or whether it should be incremented.
Moreover, the amount it should be incremented can be configured via
<a href="struct.TimestampRound.html#method.increment" title="method jiff::TimestampRound::increment"><code>TimestampRound::increment</code></a>. Finally, the rounding strategy itself
can be configured via <a href="struct.TimestampRound.html#method.mode" title="method jiff::TimestampRound::mode"><code>TimestampRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;TimestampRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for TimestampRound</code>, which will automatically create a
<code>TimestampRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for TimestampRound</code>, which will automatically
create a <code>TimestampRound::new().smallest(unit).increment(number)</code> from
the unit and increment provided.</li>
</ul>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.TimestampRound.html" title="struct jiff::TimestampRound"><code>TimestampRound</code></a> is bigger than hours.</p>
<p>The rounding increment, when combined with the smallest unit (which
defaults to <a href="enum.Unit.html#variant.Nanosecond" title="variant jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>), must divide evenly into <code>86,400</code>
seconds (one 24-hour civil day). For example, increments of both
45 seconds and 15 minutes are allowed, but 7 seconds and 25 minutes are
both not allowed.</p>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a timestamp to the
nearest hour. This also demonstrates calling this method with the
smallest unit directly, instead of constructing a <code>TimestampRound</code>
manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, Unit};

<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19 15:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round(Unit::Hour)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T16:00:00Z"</span>,
);
<span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19 15:29:59Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round(Unit::Hour)<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T15:00:00Z"</span>,
);
</code></pre></div>
<h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="enum.RoundMode.html#variant.HalfExpand" title="variant jiff::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="enum.RoundMode.html#variant.Trunc" title="variant jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{RoundMode, Timestamp, TimestampRound, Unit};

<span class="comment">// The default will round up to the next hour for any time past the
// 30 minute mark, but using truncation rounding will always round
// down.
</span><span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19 15:30:00Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round(
        TimestampRound::new()
            .smallest(Unit::Hour)
            .mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T15:00:00Z"</span>,
);
</code></pre></div>
<h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19T15:27:29.999999999Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T15:25:00Z"</span>,
);
<span class="comment">// rounds up
</span><span class="kw">let </span>ts: Timestamp = <span class="string">"2024-06-19T15:27:30Z"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>.to_string(),
    <span class="string">"2024-06-19T15:30:00Z"</span>,
);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.series" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2134-2136">Source</a><h4 class="code-header">pub fn <a href="#method.series" class="fn">series</a>(self, period: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.TimestampSeries.html" title="struct jiff::TimestampSeries">TimestampSeries</a> <a href="#" class="tooltip" data-notable-ty="TimestampSeries">ⓘ</a></h4></section></summary><div class="docblock"><p>Return an iterator of periodic timestamps determined by the given span.</p>
<p>The given span may be negative, in which case, the iterator will move
backwards through time. The iterator won’t stop until either the span
itself overflows, or it would otherwise exceed the minimum or maximum
<code>Timestamp</code> value.</p>
<h5 id="example-when-to-check-a-glucose-monitor"><a class="doc-anchor" href="#example-when-to-check-a-glucose-monitor">§</a>Example: when to check a glucose monitor</h5>
<p>When my cat had diabetes, my veterinarian installed a glucose monitor
and instructed me to scan it about every 5 hours. This example lists
all of the times I need to scan it for the 2 days following its
installation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{Timestamp, ToSpan};

<span class="kw">let </span>start: Timestamp = <span class="string">"2023-07-15 16:30:00-04"</span>.parse()<span class="question-mark">?</span>;
<span class="kw">let </span>end = start.checked_add(<span class="number">48</span>.hours())<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>scan_times = <span class="macro">vec!</span>[];
<span class="kw">for </span>ts <span class="kw">in </span>start.series(<span class="number">5</span>.hours()).take_while(|<span class="kw-2">&amp;</span>ts| ts &lt;= end) {
    scan_times.push(ts);
}
<span class="macro">assert_eq!</span>(scan_times, <span class="macro">vec!</span>[
    <span class="string">"2023-07-15 16:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-15 21:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-16 02:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-16 07:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-16 12:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-16 17:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-16 22:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-17 03:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-17 08:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
    <span class="string">"2023-07-17 13:30:00-04:00"</span>.parse::&lt;Timestamp&gt;()<span class="question-mark">?</span>,
]);
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Timestamp-1" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2140-2251">Source</a><a href="#impl-Timestamp-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Parsing and formatting APIs.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2173-2178">Source</a><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a timestamp (expressed as broken down time) in <code>input</code> matching
the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a timestamp. For example, if an offset wasn’t parsed. (The
offset is needed to turn the civil time parsed into a precise instant
in time.)</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<p>This example shows how to parse a datetime string into a timestamp:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::strptime(<span class="string">"%F %H:%M %:z"</span>, <span class="string">"2024-07-14 21:14 -04:00"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(ts.to_string(), <span class="string">"2024-07-15T01:14:00Z"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2211-2216">Source</a><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F: 'f + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>]&gt;&gt;(
    &amp;self,
    format: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;'f F</a>,
) -&gt; <a class="struct" href="fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display">Display</a>&lt;'f&gt;</h4></section></summary><div class="docblock"><p>Formats this timestamp according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="fmt/strtime/index.html" title="mod jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="fmt/strtime/struct.Display.html" title="struct jiff::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="fmt/strtime/fn.format.html" title="fn jiff::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="fmt/strtime/struct.BrokenDownTime.html#method.format" title="method jiff::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<p>This shows how to format a timestamp into a human readable datetime
in UTC:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::date, Timestamp};

<span class="kw">let </span>ts = Timestamp::from_second(<span class="number">86_400</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>string = ts.strftime(<span class="string">"%a %b %e %I:%M:%S %p UTC %Y"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"Fri Jan  2 12:00:00 AM UTC 1970"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.display_with_offset" class="method"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2245-2250">Source</a><h4 class="code-header">pub fn <a href="#method.display_with_offset" class="fn">display_with_offset</a>(&amp;self, offset: <a class="struct" href="tz/struct.Offset.html" title="struct jiff::tz::Offset">Offset</a>) -&gt; <a class="struct" href="struct.TimestampDisplayWithOffset.html" title="struct jiff::TimestampDisplayWithOffset">TimestampDisplayWithOffset</a></h4></section></summary><div class="docblock"><p>Format a <code>Timestamp</code> datetime into a string with the given offset.</p>
<p>This will format to an RFC 3339 compatible string with an offset.</p>
<p>This will never use either <code>Z</code> (for Zulu time) or <code>-00:00</code> as an
offset. This is because Zulu time (and <code>-00:00</code>) mean “the time in UTC
is known, but the offset to local time is unknown.” Since this routine
accepts an explicit offset, the offset is known. For example,
<code>Offset::UTC</code> will be formatted as <code>+00:00</code>.</p>
<p>To format an RFC 3339 string in Zulu time, use the default
<a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display"><code>std::fmt::Display</code></a> trait implementation on <code>Timestamp</code>.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{tz, Timestamp};

<span class="kw">let </span>ts = Timestamp::from_second(<span class="number">1</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    ts.display_with_offset(tz::offset(-<span class="number">5</span>)).to_string(),
    <span class="string">"1969-12-31T19:00:01-05:00"</span>,
);
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2762-2770">Source</a><a href="#impl-Add%3CDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2763">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2766-2769">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2709-2717">Source</a><a href="#impl-Add%3CSignedDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a signed duration of time to a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2710">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2713-2716">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2635-2642">Source</a><a href="#impl-Add%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a span of time to a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2636">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2639-2641">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2776-2781">Source</a><a href="#impl-AddAssign%3CDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds an unsigned duration of time to a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2778-2780">Source</a><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2723-2728">Source</a><a href="#impl-AddAssign%3CSignedDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a signed duration of time to a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2725-2727">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2650-2655">Source</a><a href="#impl-AddAssign%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Adds a span of time to a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_add" title="method jiff::Timestamp::checked_add"><code>Timestamp::checked_add</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2652-2654">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#317">Source</a><a href="#impl-Clone-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#317">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2505-2510">Source</a><a href="#impl-Debug-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Converts a <code>Timestamp</code> datetime into a human readable datetime string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">1_123_456_789</span>, <span class="number">123_000_000</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.6?}"</span>),
    <span class="string">"2005-08-07T23:19:49.123000Z"</span>,
);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.300?}"</span>),
    <span class="string">"2005-08-07T23:19:49.123000000Z"</span>,
);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.0?}"</span>),
    <span class="string">"2005-08-07T23:19:49Z"</span>,
);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2507-2509">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2464-2469">Source</a><a href="#impl-Default-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2466-2468">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.90.0/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2569-2581">Source</a><a href="#impl-Display-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Converts a <code>Timestamp</code> datetime into a RFC 3339 compliant string.</p>
</div></section></summary><div class="docblock"><p>Since a <code>Timestamp</code> never has an offset associated with it and is always
in UTC, the string emitted by this trait implementation uses <code>Z</code> for “Zulu”
time. The significance of Zulu time is prescribed by RFC 9557 and means
that “the time in UTC is known, but the offset to local time is unknown.”
If you need to emit an RFC 3339 compliant string with a specific offset,
then use <a href="struct.Timestamp.html#method.display_with_offset" title="method jiff::Timestamp::display_with_offset"><code>Timestamp::display_with_offset</code></a>.</p>
<h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html#method.precision" title="method core::fmt::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h4>
<p>This shows the default rendering:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="comment">// No fractional seconds.
</span><span class="kw">let </span>ts = Timestamp::from_second(<span class="number">1_123_456_789</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{ts}"</span>), <span class="string">"2005-08-07T23:19:49Z"</span>);

<span class="comment">// With fractional seconds.
</span><span class="kw">let </span>ts = Timestamp::new(<span class="number">1_123_456_789</span>, <span class="number">123_000_000</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{ts}"</span>), <span class="string">"2005-08-07T23:19:49.123Z"</span>);
</code></pre></div>
<h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::Timestamp;

<span class="kw">let </span>ts = Timestamp::new(<span class="number">1_123_456_789</span>, <span class="number">123_000_000</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.6}"</span>),
    <span class="string">"2005-08-07T23:19:49.123000Z"</span>,
);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.300}"</span>),
    <span class="string">"2005-08-07T23:19:49.123000000Z"</span>,
);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(
    <span class="macro">format!</span>(<span class="string">"{ts:.0}"</span>),
    <span class="string">"2005-08-07T23:19:49Z"</span>,
);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2571-2580">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2815-2820">Source</a><a href="#impl-From%3C%26Zoned%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2817-2819">Source</a><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-BrokenDownTime" class="impl"><a class="src rightside" href="../src/jiff/fmt/strtime/mod.rs.html#2980-2989">Source</a><a href="#impl-From%3CTimestamp%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>&gt; for <a class="struct" href="fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/jiff/fmt/strtime/mod.rs.html#2981-2988">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(ts: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="fmt/strtime/struct.BrokenDownTime.html" title="struct jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-Pieces%3C'static%3E" class="impl"><a class="src rightside" href="../src/jiff/fmt/temporal/pieces.rs.html#1077-1083">Source</a><a href="#impl-From%3CTimestamp%3E-for-Pieces%3C'static%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>&gt; for <a class="struct" href="fmt/temporal/struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces">Pieces</a>&lt;'static&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/fmt/temporal/pieces.rs.html#1079-1082">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(ts: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="fmt/temporal/struct.Pieces.html" title="struct jiff::fmt::temporal::Pieces">Pieces</a>&lt;'static&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-SystemTime" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2823-2838">Source</a><a href="#impl-From%3CTimestamp%3E-for-SystemTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>&gt; for <a class="struct" href="https://doc.rust-lang.org/1.90.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2825-2837">Source</a><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(time: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTimestamp%3E-for-TimestampDifference" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3444-3449">Source</a><a href="#impl-From%3CTimestamp%3E-for-TimestampDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>&gt; for <a class="struct" href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference">TimestampDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#3446-3448">Source</a><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(ts: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.TimestampDifference.html" title="struct jiff::TimestampDifference">TimestampDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2808-2813">Source</a><a href="#impl-From%3CZoned%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2810-2812">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="struct.Zoned.html" title="struct jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2583-2590">Source</a><a href="#impl-FromStr-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2584">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2587-2589">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.90.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2621-2627">Source</a><a href="#impl-Hash-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2623-2626">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.90.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2603-2612">Source</a><a href="#impl-Ord-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2605-2611">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1013-1015">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1052-1054">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1078-1080">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2594-2601">Source</a><a href="#impl-PartialEq-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2596-2600">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2614-2619">Source</a><a href="#impl-PartialOrd-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2616-2618">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.90.0/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2787-2795">Source</a><a href="#impl-Sub%3CDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2788">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2791-2794">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2734-2745">Source</a><a href="#impl-Sub%3CSignedDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2735">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2738-2744">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2663-2671">Source</a><a href="#impl-Sub%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a span of time from a timestamp.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2664">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2667-2670">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2696-2703">Source</a><a href="#impl-Sub-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Computes the span of time between two timestamps.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the timestamp being subtracted is
greater.</p>
<p>Since this uses the default configuration for calculating a span between
two timestamps (no rounding and largest units is seconds), this will never
panic or fail in any way.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.Timestamp.html#method.since" title="method jiff::Timestamp::since"><code>Timestamp::since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2697">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2700-2702">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>) -&gt; <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2801-2806">Source</a><a href="#impl-SubAssign%3CDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time from a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2803-2805">Source</a><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/time/struct.Duration.html" title="struct core::time::Duration">UnsignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2751-2756">Source</a><a href="#impl-SubAssign%3CSignedDuration%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a signed duration of time from a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics on overflow. To handle overflow
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2753-2755">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.SignedDuration.html" title="struct jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2679-2684">Source</a><a href="#impl-SubAssign%3CSpan%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3><div class="docblock"><p>Subtracts a span of time from a timestamp in place.</p>
</div></section></summary><div class="docblock"><p>This uses checked arithmetic and panics when it fails. To handle arithmetic
without panics, use <a href="struct.Timestamp.html#method.checked_sub" title="method jiff::Timestamp::checked_sub"><code>Timestamp::checked_sub</code></a>. Note that the failure
condition includes overflow and using a <code>Span</code> with non-zero units greater
than hours.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2681-2683">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.Span.html" title="struct jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/1.90.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CSystemTime%3E-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2841-2852">Source</a><a href="#impl-TryFrom%3CSystemTime%3E-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.90.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a>&gt; for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2842">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2845-2851">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(system_time: <a class="struct" href="https://doc.rust-lang.org/1.90.0/std/time/struct.SystemTime.html" title="struct std::time::SystemTime">SystemTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a>, <a class="struct" href="struct.Error.html" title="struct jiff::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Copy-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#317">Source</a><a href="#impl-Copy-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-Eq-for-Timestamp" class="impl"><a class="src rightside" href="../src/jiff/timestamp.rs.html#2592">Source</a><a href="#impl-Eq-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Timestamp" class="impl"><a href="#impl-Freeze-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-RefUnwindSafe-for-Timestamp" class="impl"><a href="#impl-RefUnwindSafe-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-Send-for-Timestamp" class="impl"><a href="#impl-Send-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-Sync-for-Timestamp" class="impl"><a href="#impl-Sync-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-Unpin-for-Timestamp" class="impl"><a href="#impl-Unpin-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section><section id="impl-UnwindSafe-for-Timestamp" class="impl"><a href="#impl-UnwindSafe-for-Timestamp" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Timestamp.html" title="struct jiff::Timestamp">Timestamp</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.90.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.90.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.90.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.90.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2806">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.90.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/alloc/string.rs.html#2808">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.90.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.90.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.90.0/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"TimestampSeries":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TimestampSeries.html\" title=\"struct jiff::TimestampSeries\">TimestampSeries</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TimestampSeries.html\" title=\"struct jiff::TimestampSeries\">TimestampSeries</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.90.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Timestamp.html\" title=\"struct jiff::Timestamp\">Timestamp</a>;</div>"}</script></section></div></main></body></html>