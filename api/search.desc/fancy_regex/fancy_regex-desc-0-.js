searchState.loadedDescShard("fancy_regex", 0, "An implementation of regexes, supporting a relatively rich …\nAlternative of multiple expressions, one of them must …\nAny character, regex <code>.</code>\nAtomic non-capturing group, e.g. <code>(?&gt;ab|a)</code> in text that …\nBack reference to a capture group, e.g. <code>\\1</code> in <code>(abc|def)\\1</code> …\nConditional expression based on whether the numbered …\nMax limit for backtracking count exceeded while executing …\nAn iterator that yields all non-overlapping capture groups …\nAn iterator over capture names in a Regex.  The iterator …\nA set of capture groups found for a regex.\nAn error as the result of compiling a regex.\nAn error as a result of compiling a regex\nConcatenation of multiple expressions, must match in …\nIf/Then/Else Condition. If there is no Then/Else, these …\nAnchor to match at the position where the previous match …\nDelegate a regex to the regex crate. This is used as a …\nAn empty expression, e.g. the last branch in <code>(a|b|)</code>\nEnd of a line\nEnd of input text\nContains the error value\nAn error as the result of parsing, compiling or running a …\nA set of options for expanding a template string using the …\nRegular expression AST. This is public for now but may …\nGeneral parsing error\nCapturing group of expression, e.g. <code>(a.)</code> matches <code>a</code> and any …\nRegex crate error\nInvalid back reference\nInvalid back reference\nInvalid character class\nInvalid codepoint for hex or unicode escape\nInvalid escape\nCouldn’t parse group name\nCouldn’t parse group name\nInvalid group id in escape sequence\nInvalid group id in escape sequence\nInvalid hex escape\nInvalid repeat syntax\nKeep matched text so far out of overall match\nThe string as a literal, e.g. <code>a</code>\nLook-ahead assertion, e.g. <code>(?=a)</code>\nNegative look-ahead assertion, e.g. <code>(?!a)</code>\nType of look-around assertion as used for a look-around …\nLook-around (e.g. positive/negative look-ahead or …\nLook-behind assertion, e.g. <code>(?&lt;=a)</code>\nNegative look-behind assertion, e.g. <code>(?&lt;!a)</code>\nLook-behind assertion without constant size\nA single match of a regex or group in an input text\nAn iterator over all non-overlapping matches for a …\nOnce named groups are used you cannot refer to groups by …\n<code>NoExpand</code> indicates literal string replacement.\nDisabling Unicode not supported\nContains the success value\nAn error for the result of parsing a regex pattern.\nAn error as a result of parsing a regex pattern, with the …\nPattern too deeply nested\nA compiled regular expression.\nA builder for a <code>Regex</code> to allow configuring options.\nRepeat of an expression, e.g. <code>a*</code> or <code>a+</code> or <code>a{1,3}</code>\nReplacer describes types that can be used to replace …\nBy-reference adaptor for a <code>Replacer</code>\nResult type for this crate with specific error enum.\nAn error as the result of executing a regex.\nAn error as a result of running a regex\nMax stack size exceeded for backtracking while executing …\nStart of a line\nStart of input text\nIterator for captured groups in order in which they appear …\nQuantifier on lookaround or other zero-width assertion\nBackslash without following character\nOpening parenthesis without closing parenthesis, e.g. <code>(a|b</code>\nUnicode escape not closed\nUnknown group flag\nAppends the expansion produced by <code>expansion</code> to <code>dst</code>.  …\nReturns the original string of this regex.\nReturns the matched text.\nLimit for how many times backtracking should be attempted …\nBuild the <code>Regex</code>.\nReturn a <code>Replacer</code> that borrows and wraps this <code>Replacer</code>.\nReturn a <code>Replacer</code> that borrows and wraps this <code>Replacer</code>.\nReturns an iterator over the capture names.\nReturns the capture groups for the first match in <code>text</code>.\nReturns the capture groups for the first match in <code>text</code>, …\nReturns an iterator over all the non-overlapping capture …\nReturns the number of captures, including the implicit …\nChecks <code>template</code> for errors.  The following conditions are …\nReturns the default expander used by <code>Captures::expand</code>.\nSet the approximate size of the cache used by the DFA.\nSet the approximate size limit of the compiled regular …\nReturns the ending byte offset of the match in the text.\nEscapes special characters in <code>text</code> with ‘\\’.  Returns …\nEscapes the substitution character in <code>text</code> so it appears …\nExpands all instances of <code>$group</code> in <code>replacement</code> to the …\nExpands the template string <code>template</code> using the syntax …\nFind the first match in the input text.\nReturns the first match in <code>text</code>, starting from the …\nReturns an iterator for each successive non-overlapping …\nShows the original regular expression.\nShows the original regular expression\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to parse a string into a regular expression\nGet the capture group by its index in the regex.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the regex matches the input text.\nIterate over the captured groups in order in which they …\nHow many groups were captured. This is always at least 1 …\nReturns the match for a named capture group.  Returns <code>None</code> …\nCreate a new regex builder with a regex pattern.\nParse and compile a regex with default options, see …\nAdapted from the <code>regex</code> crate. Calls <code>find_from_pos</code> …\nAdapted from the <code>regex</code> crate. Calls <code>captures_from_pos</code> …\nReturn a fixed unchanging replacement string.\nReturn a fixed unchanging replacement string.\nParse the regex and return an expression (AST) and a bit …\nReturns an expander that uses Python-compatible syntax.\nReturns the range over the starting and ending byte …\nReturn the underlying regex.\nReturn the underlying regex.\nReplaces the leftmost-first match with the replacement …\nReplaces all non-overlapping matches in <code>text</code> with the …\nAppends text to <code>dst</code> to replace the current match.\nReplaces at most <code>limit</code> non-overlapping matches in <code>text</code> …\nReturns the starting byte offset of the match in the text.\nReturn the text being searched.\nReturn the text being searched.\nConvert expression to a regex string in the regex crate’…\nWrites the expansion produced by <code>expansion</code> to <code>dst</code>.  …\nWhether match is case-insensitive or not\nWhether the matching is case-insensitive or not\nThe expression that is being repeated\nThe conditional expression to evaluate\nWhat to execute if the condition is false\nGreedy means as much as possible is matched, e.g. <code>.*b</code> …\nThe maximum number of repetitions (or <code>usize::MAX</code>)\nThe regex\nThe minimum number of repetitions\nWhether it also matches newlines or not\nHow many characters the regex matches\nWhat to execute if the condition is true\nThe string to match")