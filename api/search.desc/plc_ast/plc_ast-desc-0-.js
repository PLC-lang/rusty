searchState.loadedDescShard("plc_ast", 0, "This crates represents the Abstract syntax tree (AST) It …\nThis module defines the <code>AstVisitorMut</code> trait and its …\nA <code>try_from</code> convenience wrapper for <code>AstNode</code>, passed as the …\nA <code>try_from</code> convenience wrapper for <code>AstNode</code>, passed as the …\nThis module defines the <code>AstVisitor</code> trait and its …\n&amp;a\nAn alias pointer variable, e.g. <code>foo AT bar : DINT</code>\nColor#Red\nA plain pointer variable with the auto-deref trait, e.g. …\na^\n<code>.foo</code>\na[3]\nRepresents a conditional jump from current location to a …\nRepresents a location in code that could be jumbed to\na, a.b\nThe property container as a whole, which contains …\nA reference pointer variable, e.g. <code>foo : REFERENCE TO DINT;</code>\nThe condition based on which the current statement will …\ncreates a new binary statement\ncreates a new call statement to the given function and …\ncreates a new case-statement\ncreates a new cast statement\ncreates a new for loop statement\ncreates a new Identifier\ncreates a new if-statement\ncreates a not-expression\ncreates an or-expression\ncreates a new repeat-statement\ncreates a new while statement\nflattens expression-lists and MultipliedStatements into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the statement in a singleton list, or the …\nReturns the size of the bitaccess result\nexpects a Reference or an Assignment\nenum_elements should be the statement between then enum’…\nReturns the reference-name if this is a flat reference …\nreturns Some(owner_class) if this is a <code>Method</code> or …\nSimilar to <code>AstNode::get_stmt</code> with the exception of peeling …\nReturns true if the current statement has a direct access.\nList of statements within a POU body\nimports all elements of the other CompilationUnit into …\nA list of interfaces this POU implements\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturns true if this AST Statement is a literal or …\nreturns true, if this operator is a comparison operator, …\nReturns true if the current statement is a flat reference …\nReturns true if the given token is an integer or float and …\nThe SourceLocation of the whole POU\nThe SourceLocation of the POUs name\nNegates the given element by adding it to a not expression\nList of POU definitions (signature and some additional …\nA list of properties this POU contains\nstores the original scope for compiler-generated types\nThe target location (Label) the statement will jump to\nIndicates whether the pointer is a function pointer.\nIndicates whether to perform type validation. When false, …\nThe parent of this method, i.e. a function block, class or …\nThe property name (pre-mangled) and its type, if the …\nused for While and Repeat loops\nIndicates that the given condition must evaluate to true …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\na literal that represents an array\na literal that represents a boolean value (true, false)\na literal that represents a date\na literal that represents a date and time\na literal that represents a whole number (e.g. 7)\na null literal used to initialize pointers\na literal that represents a real number (e.g. 7.0)\na literal that represents a string\na literal that represents a time period\na literal that represents the time of day\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new literal array\nCreates a new literal bool\nCreates a new literal date\nCreates a new literal date and time\nCreates a new literal integer\nCreates a new literal null\nCreates a new literal real\nCreates a new literal string\nCreates a new literal time of day\nthe value of the date in nanoseconds since …\nthe value of the date and time in nanoseconds since …\nthe value of the time of day in nanoseconds since …\nthe nanos represented by the given time-period\nVisits a <code>Allocation</code> node.\nVisits a <code>LabelStatement</code> node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>AstVisitor</code> trait provides a set of methods for …\nThe <code>Walker</code> implements the traversal of the AST nodes and …\nVisits this <code>AstNode</code>. The default implementation calls the …\nVisits an <code>Allocation</code> node\nVisits an <code>Assignment</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>BinaryExpression</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>CallStatement</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>CaseCondition</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>CompilationUnit</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>ConfigVariable</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>ContinueStatement</code> node.\nVisits an <code>AstControlStatement</code> node. Make sure to call <code>walk</code> …\nVisits a <code>UserTypeDeclaration</code> node. Make sure to call <code>walk</code> …\nVisits a <code>DataTypeDeclaration</code> node. Make sure to call <code>walk</code> …\nVisits a <code>DefaultValue</code> node.\nVisits a <code>DirectAccess</code> node. Make sure to call <code>walk</code> on the …\nVisits an <code>EmptyStatement</code> node.\nVisits an enum element <code>AstNode</code> node. Make sure to call <code>walk</code>…\nVisits an <code>ExitStatement</code> node.\nVisits an <code>ExpressionList</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>HardwareAccess</code> node. Make sure to call <code>walk</code> on …\nVisits an <code>Identifier</code> node. Make sure to call <code>walk</code> on the …\nVisits an <code>Implementation</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>Interface</code>. Make sure to call <code>walk</code> on the <code>Interface</code>…\nVisits a <code>JumpStatement</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>LabelStatement</code> node.\nVisits an <code>AstLiteral</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>MultipliedStatement</code> node. Make sure to call <code>walk</code> …\nVisits an <code>OutputAssignment</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>ParenExpression</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>Pou</code> node. Make sure to call <code>walk</code> on the <code>Pou</code> node …\nVisits a <code>Property</code>.\nVisits a <code>RangeStatement</code> node. Make sure to call <code>walk</code> on …\nVisits an <code>RefAssignment</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>ReferenceExpr</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>ReturnStatement</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>Super</code> node.\nVisits a <code>This</code> node.\nVisits a <code>UnaryExpression</code> node. Make sure to call <code>walk</code> on …\nVisits a <code>UserTypeDeclaration</code> node. Make sure to call <code>walk</code> …\nVisits a <code>Variable</code> node. Make sure to call <code>walk</code> on the …\nVisits a <code>DataTypeDeclaration</code> node. Make sure to call <code>walk</code> …\nVisits a <code>VlaRangeStatement</code> node.")