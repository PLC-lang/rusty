searchState.loadedDescShard("nom", 0, "nom, eating data byte by byte\nImplementation of <code>Parser::and</code>\nImplementation of <code>Parser::and_then</code>\nHelper trait for types that can be viewed as a byte slice\nTransforms common types to a char for basic token parsing\nThe bounded iterator type.\nApplies the parser, but do not a produce a value\nAbstracts comparison operations\nIndicates whether a comparison was successful, an error, or\nIndicates that the input data is complete: no more data …\nProduces a value. This is the default behaviour for parsers\nThe <code>Err</code> enum indicates the parser was not successful\nContains the error value\nContains the error value\nThe parser had an error (recoverable)\nComparison failed\nDefines the Mode for the output type. Emit will generate …\nError type of this parser\nEquivalent From implementation to avoid orphan rules in …\nAbstracts something which can extend an <code>Extend</code>. Used to …\nThe type that will be produced\nThe parser had an unrecoverable error: we got to the right …\nLook for a substring in self\nLook for a token in self\nHelper trait to convert a parser’s result to a more …\nImplementation of <code>Parser::flat_map</code>\nHelper trait to show a byte slice as a hex dump\nHolds the result of parsing functions\nThere was not enough data\nWe need more data to be sure\nIndicates whether the input data is “complete”, ie we …\nParser input types must implement this trait\nImplementation of <code>Parser::into</code>\nSpecifies the behaviour when a parser encounters an error …\nThe current input type is a sequence of that <code>Item</code> type.\nThe current input type is a sequence of that <code>Item</code> type.\nAn iterator over the input type, producing the item\nAn iterator over the input type, producing the item and …\nImplementation of <code>Parser::map</code>\nImplementation of <code>Parser::map_opt</code>\nImplementation of <code>Parser::map_res</code>\nParser mode: influences how combinators build values\nContains information on needed data if a parser returned …\nAbstractions for range-like types.\nUseful functions to calculate the offset between slices …\nContains the success value\nContains the success value\nComparison was successful\nImplementation of <code>Parser::or</code>\nThe output type that may be generated\nDefines the Mode for the output type. Emit will generate …\nType of the produced value\nHolds the parser execution modifiers: output Mode, error …\nTrait Defining the parser’s execution\nParser result type\nUsed to integrate <code>str</code>’s <code>parse()</code> method\nAll nom parsers implement this trait\nThe saturating iterator type.\nA saturating iterator for usize.\nContains the required data size in bytes\nIndicates that the input data is streaming: more data may …\nHelper trait to convert numbers to usize.\nNeeds more data, but we do not know how much\nApplies a second parser after the first one, return their …\nApplies a second parser after the first one, return their …\nApplies a second parser over the output of the first one\nApplies a second parser over the output of the first one\nCasts the input type to a byte slice\nmakes a char from self\nProduces a value\nBit level parsers\nCreates a bounded iterator. A bounded iterator counts the …\nReturns the bounds of this range.\nChoice combinators\nParsers recognizing bytes streams\nCharacter specific parsers and combinators\nGeneral purpose combinators\nCombines two values generated by previous parsers\nCompares self to another value for equality\nCompares self to another value for equality independently …\n<code>true</code> if <code>item</code> is contained in the range.\nTransform to another error type\nAutomatically converts between errors if the underlying …\nError management\nCreates a parse error from a <code>nom::ErrorKind</code>, the position …\nCreates a parse error from a <code>nom::ErrorKind</code> and the …\nAccumulate the input into an accumulator\nReturns the byte position of the substring if it is found\nReturns true if self contains the token\nconverts the parser’s result to a type that is more …\nCreates a second parser from the output of the first one, …\nCreates a second parser from the output of the first one, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ncalled by parsers on partial data errors\nCalculates the input length, as indicated by its name, and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nautomatically converts the parser’s output and error …\nautomatically converts the parser’s output and error …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests that self is an alphabetic character\nTests that self is an alphabetic character or a decimal …\nTests that self is a binary digit\nTests that self is a decimal digit\nTests that self is an hex digit\nTests if the result is Incomplete\n<code>true</code> if the range is inverted.\nIndicates if we know how many bytes we need\nTests if byte is ASCII newline: \\n\nTests that self is an octal digit\nTests that self is ASCII space or tab\nIndicates whether the data is in streaming mode or not\nReturns an iterator over the elements\nReturns an iterator over the elements and their byte …\nGets the len in bytes for self\nLib module to re-export everything needed from <code>std</code> or <code>core</code>/…\nApplies a function over the produced value\nMaps a function over the result of a parser\nMaps a function over the result of a parser\nMaps a <code>Needed</code> to <code>Needed</code> by applying a function to a …\nApplies the given function to the inner error\nMaps <code>Err&lt;error::Error&lt;T&gt;&gt;</code> to <code>Err&lt;error::Error&lt;U&gt;&gt;</code> with the …\nMaps <code>Err&lt;(T, ErrorKind)&gt;</code> to <code>Err&lt;(U, ErrorKind)&gt;</code> with the …\nApplies a function returning an <code>Option</code> over the result of …\nApplies a function returning an <code>Option</code> over the result of …\nApplies a function returning a <code>Result</code> over the result of a …\nApplies a function returning a <code>Result</code> over the result of a …\nCombinators applying their child parser multiple times\nCreates <code>Needed</code> instance, returns <code>Needed::Unknown</code> if the …\nCreate a new <code>Extend</code> of the correct type\nParsers recognizing numbers\nOffset between the first byte of self and the first byte …\nApplies a second parser over the input if the first one …\nApplies a second parser over the input if the first one …\nA parser takes in input type, and returns a <code>Result</code> …\nA parser takes in input type, and returns a <code>Result</code> …\nA parser takes in input type, and returns a <code>Result</code> …\nA parser takes in input type, and returns a <code>Result</code> …\nSucceeds if <code>parse()</code> succeeded. The byte slice …\nReturns the byte position of the first element satisfying …\nA parser takes in input type, and returns a <code>Result</code> …\nCommon recipes to build nom parsers\nCreates a saturating iterator. A saturating iterator …\nCombinators applying parsers in sequence\nGet the byte offset from the element’s position in the …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nLooks for the first element of the input type for which …\nmode version of split_at_position\nmode version of split_at_position\nmode version of split_at_position\nmode version of split_at_position\nReturns a slice of <code>index</code> bytes. panics if index &gt; length\nReturns a slice starting at <code>index</code> bytes. panics if index &gt; …\nSplit the stream at the <code>index</code> byte offset. panics if index …\nConverts the value of <code>self</code> to a hex dump, returning the …\nConverts the value of <code>self</code> to a hex dump beginning at <code>from</code> …\nObtaining ownership\nObtaining ownership\nObtaining ownership\nObtaining ownership\nconverts self to usize\nConverts a byte-level input to a bit-level input, for …\nCounterpart to <code>bits</code>, <code>bytes</code> transforms its bit stream input …\nBit level parsers\nBit level parsers\nParses one specific bit as a bool.\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nParses one specific bit as a bool.\nGenerates a parser taking <code>count</code> bits and comparing them to …\nGenerates a parser taking <code>count</code> bits\nWrapping structure for the alt() combinator implementation\nWrapping structure for the permutation combinator …\nTests a list of parsers one by one until one succeeds.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplies a list of parsers in any order.\nParser implementation for escaped\nParser implementation for escaped_transform\nParser wrapper for <code>split_at_position</code>\nParser wrapper for <code>split_at_position1</code>\nTag implementation\nCase insensitive Tag implementation\nParser implementation for take\nParser implementation for take_until\nParser implementation for take_until1\nParser implementation for take_while_m_n\nParsers recognizing bytes streams, complete input version\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nParsers recognizing bytes streams, streaming version\nRecognizes a pattern.\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice that …\nMatches a byte string with escaped characters.\nMatches a byte string with escaped characters.\nReturns the longest slice of the matches the pattern.\nParse till certain characters are met.\nRecognizes a pattern.\nRecognizes a case insensitive pattern.\nReturns an input slice containing the first N input …\nReturns the longest input slice (if any) till a predicate …\nReturns the longest (at least 1) input slice till a …\nReturns the input slice up to the first occurrence of the …\nReturns the non empty input slice up to the first …\nReturns the longest input slice (if any) that matches the …\nReturns the longest (at least 1) input slice that matches …\nReturns the longest (m &lt;= len &lt;= n) input slice  that …\nParser implementation for char\nParser implementation for char()\nParser implementation for digit1\nParser implementation for multispace0()\nParser implementation for satisfy\naccept a <code>str</code>, but not a <code>&amp;[u8]</code>, unlike many other nom …\nRecognizes one character.\nCharacter specific parsers and combinators, complete input …\nRecognizes one or more ASCII numerical characters: 0-9\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests if byte is ASCII binary digit: 0-1\nRecognizes zero or more spaces, tabs, carriage returns and …\nExample\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nCharacter specific parsers and combinators, streaming …\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one byte as a character. Note that the input type …\nRecognizes zero or more binary characters: 0-1\nRecognizes one or more binary characters: 0-1\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes zero or more lowercase and uppercase ASCII …\nRecognizes one or more lowercase and uppercase ASCII …\nRecognizes zero or more ASCII numerical and alphabetic …\nRecognizes one or more ASCII numerical and alphabetic …\nMatches one element as a character.\nRecognizes zero or more binary characters: 0-1\nRecognizes one or more binary characters: 0-1\nRecognizes one character.\nRecognizes the string “\\r\\n”.\nRecognizes zero or more ASCII numerical characters: 0-9\nRecognizes one or more ASCII numerical characters: 0-9\nRecognizes zero or more ASCII hexadecimal numerical …\nRecognizes one or more ASCII hexadecimal numerical …\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nRecognizes an end of line (both ‘\\n’ and ‘\\r\\n’).\nRecognizes zero or more spaces, tabs, carriage returns and …\nRecognizes one or more spaces, tabs, carriage returns and …\nMatches a newline character ‘\\n’.\nRecognizes a character that is not in the provided …\nRecognizes a string of any char except ‘\\r\\n’ or ‘\\n…\nRecognizes zero or more octal characters: 0-7\nRecognizes one or more octal characters: 0-7\nRecognizes one of the provided characters.\nRecognizes one character and checks that it satisfies a …\nRecognizes zero or more spaces and tabs.\nRecognizes one or more spaces and tabs.\nMatches a tab character ‘\\t’.\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nwill parse a number in text form to a number\nParser implementation for all_consuming\nParser implementation for cond\nParser implementation for consumed\nParser implementation for cut\nParser implementation for fail\nParser implementation for complete\nParser implementation for not\nParser implementation for opt\nMain structure associated to the iterator function.\nParsr implementation for peek\nParser implementation for recognize\nParser implementation for success\nParser iplementation for verify\nSucceeds if all the input has been consumed by its child …\nTransforms Incomplete into <code>Error</code>.\nCalls the parser if the condition is met.\nif the child parser was successful, return the consumed …\nTransforms an <code>Err::Error</code> (recoverable) to <code>Err::Failure</code> …\nreturns its input if it is at the end of input data\nA parser which always fails.\nReturns the remaining input if parsing was successful, or …\nCreates a new parser from the output of the first parser, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nautomatically converts the child parser’s result to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an iterator from input data and a parser.\nMaps a function on the result of a parser.\nApplies a function returning an <code>Option</code> over the result of …\nApplies a parser over the result of another one.\nApplies a function returning a <code>Result</code> over the result of a …\nSucceeds if the child parser returns an error.\nOptional parser, will return <code>None</code> on <code>Err::Error</code>.\nTries to apply its parser without consuming the input.\nIf the child parser was successful, return the consumed …\nReturn the remaining input.\nReturn the length of the remaining input.\na parser which always succeeds with given value without …\nReturns the provided value if the child parser succeeds.\nReturns the result of the child parser if it satisfies a …\nParser implementation for context\nThis trait is required by the <code>context</code> combinator to add a …\ndefault error type, only contains the error’s location …\nIndicates which parser returned an error\nThis trait is required by the <code>map_res</code> combinator to …\nThis trait must be implemented by the error type of a nom …\nCreates a new error from an input position, a static …\nCombines an existing error with a new one created from the …\nCombines an existing error with a new one created from the …\nConverts <code>Error&lt;&amp;I&gt;</code> into <code>Error&lt;I::Owned&gt;</code> by cloning.\nConverts <code>Error&lt;&amp;mut I&gt;</code> into <code>Error&lt;I::Owned&gt;</code> by cloning.\nnom error code\nCreate a new error from an input position, a static string …\nConverts <code>Error&lt;&amp;mut I&gt;</code> into <code>Error&lt;I&gt;</code> by copying.\nConverts <code>Error&lt;&amp;I&gt;</code> into <code>Error&lt;I&gt;</code> by copying.\nPrints a message and the input if the parser fails.\nConverts an ErrorKind to a text description\nConverts an ErrorKind to a number\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an error from an input position and an expected …\nCreates an error from the input position and an ErrorKind\nCreates a new error from an input position, an ErrorKind …\nCreate a new error from an input position and an external …\nposition of the error in the input data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates an error from the input position and an ErrorKind\ncreates a new basic error\nCombines two existing errors. This function is used to …\ninternal std exports for no_std compatibility\nParser implementation for the count combinator\nParser implementation for the fill combinator\nParser implementation for the fold combinator\nParser implementation for the fold_many0 combinator\nParser implementation for the fold_many1 combinator\nParser implementation for the fold_many_m_n combinator\nParser implementation for the length_count combinator\nParser implementation for the length_value combinator\nParser implementation for the many combinator\nParser implementation for the many0 combinator\nParser implementation for the many0_count combinator\nParser implementation for the many1 combinator\nParser implementation for the many1_count combinator\nParser implementation for the many_m_n combinator\nParser implementation for the many_till combinator\nParser implementation for the separated_list0 combinator\nParser implementation for the separated_list1 combinator\nRuns the embedded parser <code>count</code> times, gathering the …\nRuns the embedded parser repeatedly, filling the given …\nApplies a parser and accumulates the results using a given …\nRepeats the embedded parser, calling <code>g</code> to gather the …\nRepeats the embedded parser, calling <code>g</code> to gather the …\nRepeats the embedded parser <code>m..=n</code> times, calling <code>g</code> to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets a number from the first parser, then applies the …\nGets a number from the parser and returns a subslice of …\nGets a number from the first parser, takes a subslice of …\nRepeats the embedded parser and collects the results in a …\nRepeats the embedded parser, gathering the results in a <code>Vec</code>…\nRepeats the embedded parser, counting the results\nRuns the embedded parser, gathering the results in a <code>Vec</code>.\nRuns the embedded parser, counting the results.\nRepeats the embedded parser <code>m..=n</code> times\nApplies the parser <code>f</code> until the parser <code>g</code> produces a result.\nAlternates between two parsers to produce a list of …\nAlternates between two parsers to produce a list of …\nBig endian\nConfigurable endianness\nLittle endian\nWill match the host’s endianness\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nParsers recognizing numbers, complete input version\ndouble precision floating point number parser from text\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nsingle precision floating point number parser from text\nReturns the argument unchanged.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nCalls <code>U::from(self)</code>.\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 bytes integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes a floating point number in text format and …\nfloat number text parser that also recognizes “nan”, …\nParsers recognizing numbers, streaming version\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in text format and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in text format and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 byte integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in a byte string and …\nRecognizes a floating point number in text format\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\nRecognizes a big endian 4 bytes floating point number.\nRecognizes a big endian 8 bytes floating point number.\nRecognizes a big endian signed 16 bytes integer.\nRecognizes a big endian signed 2 bytes integer.\nRecognizes a big endian signed 3 bytes integer.\nRecognizes a big endian signed 4 bytes integer.\nRecognizes a big endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a big endian unsigned 16 bytes integer.\nRecognizes a big endian unsigned 2 bytes integer.\nRecognizes a big endian unsigned 3 byte integer.\nRecognizes a big endian unsigned 4 bytes integer.\nRecognizes a big endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes floating point number in text format and …\nRecognizes a 4 byte floating point number\nRecognizes an 8 byte floating point number\nRecognizes floating point number in text format and …\nRecognizes a hex-encoded integer.\nRecognizes a signed 16 byte integer\nRecognizes a signed 2 byte integer\nRecognizes a signed 3 byte integer\nRecognizes a signed 4 byte integer\nRecognizes a signed 8 byte integer\nRecognizes a signed 1 byte integer\nRecognizes a little endian 4 bytes floating point number.\nRecognizes a little endian 8 bytes floating point number.\nRecognizes a little endian signed 16 bytes integer.\nRecognizes a little endian signed 2 bytes integer.\nRecognizes a little endian signed 3 bytes integer.\nRecognizes a little endian signed 4 bytes integer.\nRecognizes a little endian signed 8 bytes integer.\nRecognizes a signed 1 byte integer.\nRecognizes a little endian unsigned 16 bytes integer.\nRecognizes a little endian unsigned 2 bytes integer.\nRecognizes a little endian unsigned 3 bytes integer.\nRecognizes a little endian unsigned 4 bytes integer.\nRecognizes a little endian unsigned 8 bytes integer.\nRecognizes an unsigned 1 byte integer.\nRecognizes a floating point number in text format and …\nRecognizes a floating point number in text format\nRecognizes an unsigned 16 byte integer\nRecognizes an unsigned 2 bytes integer\nRecognizes an unsigned 3 byte integer\nRecognizes an unsigned 4 byte integer\nRecognizes an unsigned 8 byte integer\nRecognizes an unsigned 1 byte integer\na\na\nHelper trait for the tuple combinator.\nMatches an object from the first parser and discards it, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets an object from the first parser, then gets another …\nParses the input and returns a tuple of results of each …\nMatches an object from the first parser and discards it, …\nGets an object from the first parser, then matches an …\nGets an object from the first parser, then matches an …\nApplies a tuple of parsers one by one and returns their …")