---
source: tests/integration/header_generator_tests.rs
assertion_line: 69
expression: "fs::read_to_string(dir.path().join(\"Async.h\").to_str().unwrap()).unwrap()"
---
// ---------------------------------------------------- //
// This file is auto-generated                          //
// Manual changes made to this file will be overwritten //
// ---------------------------------------------------- //

#ifndef ASYNC
#define ASYNC

#include <stdint.h>
#include <math.h>
#include <stdbool.h>
#include <dependencies.plc.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct AsyncTask *AsyncTaskHandle;
typedef struct AsyncJob *AsyncJobHandle;
typedef bool (*AsyncFunction)(void *);
typedef bool (*AsyncFunctionCancelable)(void *, const bool *);

typedef enum {
    ASYNC_JobState_Invalid = -1,   //< Invalid (initial value)
    ASYNC_JobState_Pending = 0,    //< Queued, not running
    ASYNC_JobState_Active = 1,     //< Running
    ASYNC_JobState_Ready = 2,      //< Finished successfully
    ASYNC_JobState_Error = 3,      //< Finished with error
    ASYNC_JobState_Timeout = 4,    //< Timed out
    ASYNC_JobState_Cancelled = 5,  //< Cancelled by user request
} Async_JobState;

typedef struct {
    AsyncTaskHandle task_handle;
    uint32_t timeout;
} AsyncTaskMembers;

typedef struct {
    void *__vtable;
    AsyncTaskMembers *members;
} AsyncTask_t;

typedef struct {
    char task_name[16];
    uint32_t task_priority;
    uint32_t queue_size;
} Async_TaskParams;

void ASYNC_JobRelease(AsyncJobHandle job_handle, ErrorCode *error);

void ASYNC_TaskClearAll(AsyncTaskHandle task_handle, ErrorCode *error);

void ASYNC_Task__FB_DEINIT(AsyncTask_t *async_task);

Async_JobState ASYNC_JobGetState(AsyncJobHandle job_handle, ErrorCode *error);

bool ASYNC_JobIsCancelable(AsyncJobHandle job_handle, ErrorCode *error);

AsyncTaskHandle ASYNC_TaskCreate(const Async_TaskParams *task_params, ErrorCode *error);

void ASYNC_TaskDestroy(ErrorCode *error, AsyncTaskHandle task_handle);

AsyncJobHandle ASYNC_TaskAddJob(AsyncTaskHandle task_handle, AsyncFunction job_function, void *params, Async_JobState *state, uint32_t timeout, ErrorCode *error);

AsyncJobHandle ASYNC_TaskAddJobCancelable(AsyncTaskHandle task_handle, AsyncFunctionCancelable job_function, void *params, Async_JobState *state, uint32_t timeout, ErrorCode *error);

void ASYNC_JobCancel(ErrorCode *error, AsyncJobHandle job_handle);

AsyncTaskHandle ASYNC_GetDefaultTask();

void ASYNC_TaskGetName(char *name_buffer, AsyncTaskHandle task_handle);

uint32_t ASYNC_TaskGetPriority(AsyncTaskHandle task_handle);

void __ASYNC_Task__init(AsyncTask_t *async_task);

void ASYNC_Task(AsyncTask_t *async_task);

void ASYNC_Task__SetAsyncTask(AsyncTask_t *async_task, AsyncTaskHandle task_handle);

void ASYNC_Task__FB_INIT(AsyncTask_t *async_task);

uint32_t ASYNC_Task____get_Timeout(AsyncTask_t *async_task);

void ASYNC_Task____set_Timeout(AsyncTask_t *async_task, uint32_t timeout);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* !ASYNC */
